#separator:tab
#html:true
Basic Calculator II	Medium	Stack		<li><div><strong>Iterate through the string</strong>:</div><ul><li>Read one character at a time.</li><li>Build numbers from digits (e.g., <code>2</code>, <code>34</code>, etc.).</li><li>When encountering an operator or the end of the string, process the number and the last operator.</li></ul></li><li><div><strong>Use a Stack</strong>:</div><ul><li>The <strong>stack</strong> stores intermediate results so we can handle operator precedence properly.</li><li>For <code>+</code> and <code>-</code>, push the number directly onto the stack (positive or negative).</li><li>For <code>*</code> and <code>/</code>, pop the last number from the stack, perform the operation, and push the result back.</li></ul></li><li><div><strong>At the End</strong>:</div><ul><li>Add all numbers in the stack to get the final result.</li></ul></li>	"def calculate(s: str) -&gt; int:
<br>&nbsp; &nbsp;stack = []<br>&nbsp; &nbsp;current_number = 0<br>&nbsp; &nbsp;operation = '+'
<br>&nbsp; &nbsp;for i, c in enumerate(s):
<br>&nbsp; &nbsp; &nbsp; if c.isdigit():
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current_number = current_number * 10 + int(c)
<br>&nbsp; &nbsp; &nbsp; if c in ""+-*/"" or i == len(s) - 1:
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if operation == '+':
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.append(current_number)
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elif operation == '-':
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.append(-current_number)
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elif operation == '*':
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.append(stack.pop() * current_number)
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elif operation == '/':
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.append(int(stack.pop() / current_number)) <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;operation = c
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current_number = 0
<br>&nbsp; &nbsp;return sum(stack)"	O(N) time<br>O(1) space
LRU Cache	Medium		use OrderedDict()	"use OrderedDict() to keep the most recently used values at the end of the dict. use the move_to_end(last=____) function to do this. When you add an element to the dict, if it's already in there move it to the end and then check whether capacity is maintained.<br>to pop the first item use:&nbsp;<span style=""color: rgb(86, 156, 214);"">dict</span><span style=""color: rgb(212, 212, 212);"">.popitem</span><span style=""color: rgb(220, 220, 220);"">(</span><span style=""color: rgb(212, 212, 212);"">last = </span><span style=""color: rgb(86, 156, 214);"">False</span><span style=""color: rgb(220, 220, 220);"">)</span>"	"<div>class LRUCache:</div><br><div>&nbsp; &nbsp;def __init__(self, capacity: int):</div><div>&nbsp; &nbsp; &nbsp; self.cache = OrderedDict()</div><div>&nbsp; &nbsp; &nbsp; self.capacity = capacity</div><br><div>&nbsp; &nbsp;def get(self, key: int) -&gt; int:</div><div>&nbsp; &nbsp; &nbsp; if key not in self.cache: return -1</div><div>&nbsp; &nbsp; &nbsp; self.cache.move_to_end(key)</div><div>&nbsp; &nbsp; &nbsp; return self.cache.get(key)</div><br><div>&nbsp; &nbsp;def put(self, key: int, value: int) -&gt; None:</div><div>&nbsp; &nbsp; &nbsp; if key in self.cache:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.cache.move_to_end(key)</div><div>&nbsp; &nbsp; &nbsp; self.cache[key] = value</div><div>&nbsp; &nbsp; &nbsp; # this preserves the most recent elements being at the end</div><div>&nbsp; &nbsp; &nbsp; if len(self.cache) &gt; self.capacity:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.cache.popitem(last=False)</div><div>&nbsp; &nbsp; &nbsp; return</div>"	O(N) space&nbsp;<br>O(1) time
Find the Length of the Longest Common Prefix	Medium	Arrays/Strings	use a set	Put all the possible prefixes of each element in&nbsp;<code>arr1</code>&nbsp;into a HashSet.<br>For all the possible prefixes of each element in&nbsp;<code>arr2</code>, check if it exists in the HashSet.<br>Find the max of the prefixes that exist in the set and arr2	<div>def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -&gt; int:<br></div><div>&nbsp; &nbsp;prefix_set = set()</div><div> &nbsp; &nbsp;for num in arr1:</div><div> &nbsp; &nbsp; &nbsp; for j in range(len(str(num))):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prefix_set.add(str(num)[:j+1])</div><div><br></div><div>&nbsp; &nbsp;max_prefix_length = 0</div><div> &nbsp; &nbsp;for num in arr2:</div><div>&nbsp; &nbsp; &nbsp; num_str = str(num)</div><div>&nbsp; &nbsp; &nbsp; for i in range(1, len(num_str) + 1):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if num_str[:i] in prefix_set:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_prefix_length = max(max_prefix_length, i)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break</div><br><div>&nbsp; &nbsp;return max_prefix_length<br></div>	O((arr1.length+arr2.length)×log10​(max_value)) time&nbsp;
Decode Ways	Medium	DP	think decision tree	do recursive method (think of a decision tree) and then wrap with dp hashmap. initialize dp hasmap with len(s): 1 and update the map whenver you calculate a result	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">numDecodings</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> s<span style=""font-style: inherit; font-weight: inherit;"">:</span> <span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> <span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        dp <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">{</span><span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">:</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">}</span>

        <span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">dfs</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>i<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> i <span style=""font-style: inherit; font-weight: inherit;"">in</span> dp<span style=""font-style: inherit; font-weight: inherit;"">:</span>
                <span style=""font-style: inherit; font-weight: inherit;"">return</span> dp<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">==</span> <span style=""font-style: inherit; font-weight: inherit;"">""0""</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                <span style=""font-style: inherit; font-weight: inherit;"">return</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span>

            res <span style=""font-style: inherit; font-weight: inherit;"">=</span> dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span>i <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> i <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span> <span style=""font-style: inherit; font-weight: inherit;"">&lt;</span> <span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">and</span> <span style=""font-style: inherit; font-weight: inherit;"">(</span>
                s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">==</span> <span style=""font-style: inherit; font-weight: inherit;"">""1""</span> <span style=""font-style: inherit; font-weight: inherit;"">or</span> s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">==</span> <span style=""font-style: inherit; font-weight: inherit;"">""2""</span> <span style=""font-style: inherit; font-weight: inherit;"">and</span>
                s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">in</span> <span style=""font-style: inherit; font-weight: inherit;"">""0123456""</span>
            <span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                res <span style=""font-style: inherit; font-weight: inherit;"">+=</span> dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span>i <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">2</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            dp<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">=</span> res
            <span style=""font-style: inherit; font-weight: inherit;"">return</span> res

        <span style=""font-style: inherit; font-weight: inherit;"">return</span> dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">0</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></code></pre>"	O(N) space<br>O(N) time
Maximum Subarray	Medium	Sliding Window		<div>The Intuition behind the code is to find the maximum sum of a contiguous subarray within the given array&nbsp;<code>nums</code>. It does this by scanning through the array and keeping track of the current sum of the subarray. Whenever the current sum becomes greater than the maximum sum encountered so far, it updates the maximum sum. If the current sum becomes negative, it resets the sum to 0 and starts a new subarray. By the end of the loop, the code returns the maximum sum found.</div>	"<div><div><span style=""color: #0000ff;"">def</span> <span style=""color: #795e26;"">maxSubArray</span>(<span style=""color: #001080;"">self</span>, <span style=""color: #001080;"">nums</span>: List[<span style=""color: #267f99;"">int</span>]) -&gt; <span style=""color: #267f99;"">int</span>:</div><div>&nbsp; &nbsp;largestSum = nums[<span style=""color: #098658;"">0</span>]</div><div>&nbsp; &nbsp;currentSum = nums[<span style=""color: #098658;"">0</span>]</div><br><div> <span style=""color: #af00db;"">&nbsp; &nbsp;for</span> j <span style=""color: #af00db;"">in</span> <span style=""color: #795e26;"">range</span>(<span style=""color: #098658;"">1</span>, <span style=""color: #795e26;"">len</span>(nums)):</div><div>&nbsp; &nbsp; &nbsp; currentSum = <span style=""color: #795e26;"">max</span>(nums[j], currentSum + nums[j])</div><div>&nbsp; &nbsp; &nbsp; largestSum = <span style=""color: #795e26;"">max</span>(largestSum, currentSum)</div><div> </div><div> <span style=""color: #af00db;"">&nbsp; &nbsp;return</span> largestSum</div></div>"	
Flatten Nested List Iterator	Medium		Stack	<ul><li>In this all-in-one-go approach we use an array to store the results of our flattened array</li><li><div>The <code>NestedIterator</code> class is initialized with a nested list of <code>NestedInteger</code> objects. In the constructor (<code>__init__</code>), an empty stack is created to store the extracted integers. The helper function <code>dfs</code> (Depth-First Search) is called to process the nested list and extract all integers in a flattened order. The DFS function recursively checks each element in the list: if the element is an integer, it is appended to the stack; if the element is a nested list, the function is called recursively to handle deeper levels of nesting.</div><div>Once the nested structure is fully traversed and all integers are stored in the stack, the <code>next()</code> method simply returns the first element of the stack using <code>pop(0)</code>, ensuring elements are processed in order. The <code>hasNext()</code> method checks if there are any elements left in the stack, returning <code>True</code> if integers remain, or <code>False</code> if all elements have been consumed.</div></li></ul>	"<pre><code># """"""<br># This is the interface that allows for creating nested lists.<br># You should not implement it, or speculate about its implementation.<br># """"""<br># class NestedInteger:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def isInteger(self) -&gt; bool:<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @return True if this NestedInteger holds a single integer, rather than a nested list.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>#<br>#&nbsp;&nbsp;&nbsp;&nbsp; def getInteger(self) -&gt; int:<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @return the single integer that this NestedInteger holds, if it holds a single integer.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return None if this NestedInteger holds a nested list.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>#<br>#&nbsp;&nbsp;&nbsp;&nbsp; def getList(self) -&gt; [NestedInteger]:<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @return the nested list that this NestedInteger holds, if it holds a nested list.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return None if this NestedInteger holds a single integer.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br><br>class NestedIterator:<br>&nbsp;&nbsp;&nbsp; def __init__(self, nestedList: [NestedInteger]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initializes the iterator with the given nested list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dfs(nestedList)<br><br>&nbsp;&nbsp;&nbsp; def next(self) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the next integer in the flattened nested list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.stack.pop(0)<br><br>&nbsp;&nbsp;&nbsp; def hasNext(self) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns True if there are still integers to be returned; otherwise, False.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return len(self.stack) &gt; 0<br><br>&nbsp;&nbsp;&nbsp; def dfs(self, nestedList):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Helper function to flatten the nested list using depth-first search (DFS).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for nested in nestedList:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nested.isInteger():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.stack.append(nested.getInteger())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dfs(nested.getList())<br><br><br># Example usage:<br># i, v = NestedIterator(nestedList), []<br># while i.hasNext():<br>#&nbsp;&nbsp;&nbsp;&nbsp; v.append(i.next())<br></code></pre>"	<pre><code>O(1) time for each of the functions</code></pre><pre><code>O(D) space where D is the max depth of the input array</code></pre>
Contains Duplicate	Easy		Hashset	Put numbers in a hashset as you iterate<br>check the set as you iterate. if the num is in the set then there's a duplicate	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">hasDuplicate</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> <span style=""font-style: inherit; font-weight: inherit;"">bool</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        seen <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">set</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> num <span style=""font-style: inherit; font-weight: inherit;"">in</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> num <span style=""font-style: inherit; font-weight: inherit;"">in</span> seen<span style=""font-style: inherit; font-weight: inherit;"">:</span>
                <span style=""font-style: inherit; font-weight: inherit;"">return</span> <span style=""font-style: inherit; font-weight: inherit;"">True</span>
            seen<span style=""font-style: inherit; font-weight: inherit;"">.</span>add<span style=""font-style: inherit; font-weight: inherit;"">(</span>num<span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">return</span> <span style=""font-style: inherit; font-weight: inherit;"">False</span></code></pre>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul>"
Group Anagrams	Medium		Hashtable	use defaultdict for ease.<br>loop through the strings and sort.<br>then hash into the table using the sorted string and append to that list	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">groupAnagrams</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> strs<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span>List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        res <span style=""font-style: inherit; font-weight: inherit;"">=</span> defaultdict<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">list</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> s <span style=""font-style: inherit; font-weight: inherit;"">in</span> strs<span style=""font-style: inherit; font-weight: inherit;"">:</span>
            sortedS <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">''</span><span style=""font-style: inherit; font-weight: inherit;"">.</span>join<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">sorted</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            res<span style=""font-style: inherit; font-weight: inherit;"">[</span>sortedS<span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">.</span>append<span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">return</span> <span style=""font-style: inherit; font-weight: inherit;"">list</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>res<span style=""font-style: inherit; font-weight: inherit;"">.</span>values<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></code></pre>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛log⁡𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛)</span></li></ul>"
Top K Frequent Elements	Medium		hashset	use hashset to count frequency of elements<br>create a frequency array that indexes using count and puts the num at the right count position<br>(this means that the most frequent numbers will end up at the end of this array)<br>start at the end of this array and loop in reverse, returning the k most frequent	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">topKFrequent</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">,</span> k<span style=""font-style: inherit; font-weight: inherit;"">:</span> <span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        count <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">{</span><span style=""font-style: inherit; font-weight: inherit;"">}</span>
        freq <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">for</span> i <span style=""font-style: inherit; font-weight: inherit;"">in</span> <span style=""font-style: inherit; font-weight: inherit;"">range</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">]</span>

        <span style=""font-style: inherit; font-weight: inherit;"">for</span> num <span style=""font-style: inherit; font-weight: inherit;"">in</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span>
            count<span style=""font-style: inherit; font-weight: inherit;"">[</span>num<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span> <span style=""font-style: inherit; font-weight: inherit;"">+</span> count<span style=""font-style: inherit; font-weight: inherit;"">.</span>get<span style=""font-style: inherit; font-weight: inherit;"">(</span>num<span style=""font-style: inherit; font-weight: inherit;"">,</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> num<span style=""font-style: inherit; font-weight: inherit;"">,</span> cnt <span style=""font-style: inherit; font-weight: inherit;"">in</span> count<span style=""font-style: inherit; font-weight: inherit;"">.</span>items<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            freq<span style=""font-style: inherit; font-weight: inherit;"">[</span>cnt<span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">.</span>append<span style=""font-style: inherit; font-weight: inherit;"">(</span>num<span style=""font-style: inherit; font-weight: inherit;"">)</span>
        
        res <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">]</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> i <span style=""font-style: inherit; font-weight: inherit;"">in</span> <span style=""font-style: inherit; font-weight: inherit;"">range</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>freq<span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">,</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span><span style=""font-style: inherit; font-weight: inherit;"">,</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit;"">for</span> num <span style=""font-style: inherit; font-weight: inherit;"">in</span> freq<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                res<span style=""font-style: inherit; font-weight: inherit;"">.</span>append<span style=""font-style: inherit; font-weight: inherit;"">(</span>num<span style=""font-style: inherit; font-weight: inherit;"">)</span>
                <span style=""font-style: inherit; font-weight: inherit;"">if</span> <span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>res<span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">==</span> k<span style=""font-style: inherit; font-weight: inherit;"">:</span>
                    <span style=""font-style: inherit; font-weight: inherit;"">return</span> res</code></pre>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Encode and Decode Strings	Medium			"to encode: join the strings so that they have the length of the next word to decode and then a delimiter<br>e.g.&nbsp;<span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">[</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">""neet""</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">,</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">""code""</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">,</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">""love""</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">,</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">""you""</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">] becomes ""4#</span><span style=""font-style: inherit; font-weight: inherit; white-space: pre-wrap;"">neet4#</span><span style=""font-style: inherit; font-weight: inherit; white-space: pre-wrap;"">code4#</span><span style=""font-style: inherit; font-weight: inherit; white-space: pre-wrap;"">love3#</span><span style=""font-style: inherit; font-weight: inherit; white-space: pre-wrap;"">you</span><span style=""white-space: pre-wrap; font-style: inherit; font-weight: inherit;"">""
</span>to decode: use the numbers to work out how many characters the next word is"	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">class</span> <span style=""font-style: inherit; font-weight: inherit;"">Solution</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
    
    <span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">encode</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> strs<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> <span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        res <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">""""</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> s <span style=""font-style: inherit; font-weight: inherit;"">in</span> strs<span style=""font-style: inherit; font-weight: inherit;"">:</span>
            res <span style=""font-style: inherit; font-weight: inherit;"">+=</span> <span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">""#""</span> <span style=""font-style: inherit; font-weight: inherit;"">+</span> s
        <span style=""font-style: inherit; font-weight: inherit;"">return</span> res

    <span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">decode</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> s<span style=""font-style: inherit; font-weight: inherit;"">:</span> <span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">str</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        res <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">]</span>
        i <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span>
        
        <span style=""font-style: inherit; font-weight: inherit;"">while</span> i <span style=""font-style: inherit; font-weight: inherit;"">&lt;</span> <span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            j <span style=""font-style: inherit; font-weight: inherit;"">=</span> i
            <span style=""font-style: inherit; font-weight: inherit;"">while</span> s<span style=""font-style: inherit; font-weight: inherit;"">[</span>j<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">!=</span> <span style=""font-style: inherit; font-weight: inherit;"">'#'</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                j <span style=""font-style: inherit; font-weight: inherit;"">+=</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span>
            length <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">:</span>j<span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            i <span style=""font-style: inherit; font-weight: inherit;"">=</span> j <span style=""font-style: inherit; font-weight: inherit;"">+</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span>
            j <span style=""font-style: inherit; font-weight: inherit;"">=</span> i <span style=""font-style: inherit; font-weight: inherit;"">+</span> length
            res<span style=""font-style: inherit; font-weight: inherit;"">.</span>append<span style=""font-style: inherit; font-weight: inherit;"">(</span>s<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">:</span>j<span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            i <span style=""font-style: inherit; font-weight: inherit;"">=</span> j
            
        <span style=""font-style: inherit; font-weight: inherit;"">return</span> res</code></pre>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">m</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>&nbsp;for&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: italic; font-weight: inherit;"">co</span><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>&nbsp;and&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">eco</span><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>.</li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>&nbsp;for&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: italic; font-weight: inherit;"">co</span><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>&nbsp;and&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">eco</span><span style=""font-style: italic; font-weight: inherit;"">d</span><span style=""font-style: italic; font-weight: inherit;"">e</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span>.</li></ul>"
Products of Array Except Self	Medium		store the results of repeated work in an array	loop through to calculate total product and count number of 0s. <br>if there is more than one zero then the whole return array must be 0.<br>else loop through the numbers again and divide total product by that number<br>if you come across a single 0 value, put the total product	"<pre><code><span style=""font-style: inherit; font-weight: inherit;"">def</span> <span style=""font-style: inherit; font-weight: inherit;"">productExceptSelf</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit;"">-</span><span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        prod<span style=""font-style: inherit; font-weight: inherit;"">,</span> zero_cnt <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">,</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> num <span style=""font-style: inherit; font-weight: inherit;"">in</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> num<span style=""font-style: inherit; font-weight: inherit;"">:</span>
                prod <span style=""font-style: inherit; font-weight: inherit;"">*=</span> num
            <span style=""font-style: inherit; font-weight: inherit;"">else</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                zero_cnt <span style=""font-style: inherit; font-weight: inherit;"">+=</span>  <span style=""font-style: inherit; font-weight: inherit;"">1</span>
        <span style=""font-style: inherit; font-weight: inherit;"">if</span> zero_cnt <span style=""font-style: inherit; font-weight: inherit;"">&gt;</span> <span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">:</span> <span style=""font-style: inherit; font-weight: inherit;"">return</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">0</span><span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">*</span> <span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span>

        res <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit;"">0</span><span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">*</span> <span style=""font-style: inherit; font-weight: inherit;"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span>
        <span style=""font-style: inherit; font-weight: inherit;"">for</span> i<span style=""font-style: inherit; font-weight: inherit;"">,</span> c <span style=""font-style: inherit; font-weight: inherit;"">in</span> <span style=""font-style: inherit; font-weight: inherit;"">enumerate</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit;"">if</span> zero_cnt<span style=""font-style: inherit; font-weight: inherit;"">:</span> res<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">0</span> <span style=""font-style: inherit; font-weight: inherit;"">if</span> c <span style=""font-style: inherit; font-weight: inherit;"">else</span> prod
            <span style=""font-style: inherit; font-weight: inherit;"">else</span><span style=""font-style: inherit; font-weight: inherit;"">:</span> res<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit;"">=</span> prod <span style=""font-style: inherit; font-weight: inherit;"">//</span> c
        <span style=""font-style: inherit; font-weight: inherit;"">return</span> res</code></pre>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li></ul>"
Valid Sudoku	Medium		use hashset	loop through each row, col and square and make a seen set for each. Check if there are any repeated values	"class Solution:<br>&nbsp;&nbsp;&nbsp; def isValidSudoku(self, board: List[List[str]]) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for row in range(9):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(9):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[row][i] == ""."": <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[row][i] in seen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add(board[row][i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for col in range(9):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(9):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[i][col] == ""."":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[i][col] in seen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add(board[i][col])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for square in range(9):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(3):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(3):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row = (square//3) * 3 + i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col = (square % 3) * 3 + j<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[row][col] == ""."":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[row][col] in seen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add(board[row][col])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛^2)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛^2)</span></li></ul>"
Longest Consecutive Sequence	Medium		hashset	use hashset to track seen numbers<br>loop through nums: if you come across a number for which you haven't seen the previous, check how many subsequent numbers are in the set<br>keep track of the longest number of consecutive numbers you find.	class Solution:<br>&nbsp;&nbsp;&nbsp; def longestConsecutive(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numSet = set(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in numSet:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (num - 1) not in numSet:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (num + length) in numSet:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest = max(length, longest)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return longest	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Two Integer Sum II	Medium		is the input sorted? now what?	iterate through nums and do binary search to find second num. Only need to look forward in binary search	"class Solution:<br>&nbsp;&nbsp;&nbsp; def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(numbers)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = i + 1, len(numbers) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = target - numbers[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = l + (r - l)//2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if numbers[mid] == tmp:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [i + 1, mid + 1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif numbers[mid] &lt; tmp:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = mid + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = mid - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return []<br><br><br><br>better solution:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; low = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; high = len(numbers) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while low &lt; high:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum = numbers[low] + numbers[high]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if sum == target:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [low + 1, high + 1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif sum &lt; target:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; low += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; high -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # In case there is no solution, return [-1, -1].<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [-1, -1]"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛log⁡𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li></ul>"
3Sum	Medium		binary search	loop and do binary search	class Solution:<br>&nbsp;&nbsp;&nbsp; def threeSum(self, nums: List[int]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums.sort()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i, a in enumerate(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if a &gt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt; 0 and a == nums[i - 1]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = i + 1, len(nums) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt; r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threeSum = a + nums[l] + nums[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if threeSum &gt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif threeSum &lt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append([a, nums[l], nums[r]])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while nums[l] == nums[l - 1] and l &lt; r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	
Container With Most Water	Medium		two pointer	first put pointers at start and end index&nbsp;<br>calculate area and keep track of max area<br>continually move smaller bar inwards	class Solution:<br>&nbsp;&nbsp;&nbsp; def maxArea(self, heights: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(heights) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt; r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area = min(heights[l], heights[r]) * (r - l)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, area)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if heights[l] &lt;= heights[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li></ul>"
Valid Parentheses	Easy		stack	create close to open dict<br>loop through the chars, if it's an open bracket, append to stack<br>if it's a close bracket and the stack exists, check it equals the last item on stack. if so, pop it	"class Solution:<br>&nbsp;&nbsp;&nbsp; def isValid(self, s: str) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closeToOpen = { "")"" : ""("", ""]"" : ""["", ""}"" : ""{"" }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in s:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c in closeToOpen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if stack and stack[-1] == closeToOpen[c]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True if not stack else False"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Minimum Stack	Medium		maintain a stack and minstack	maintain a minstack as well as the main stack. this way you can always have the minimum value on hand. keep in mind when you push, this means you have to compare the most recent value of the min stack and whether it's more or less than the number you're adding in.	class MinStack:<br>&nbsp;&nbsp;&nbsp; def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.minStack = []<br><br>&nbsp;&nbsp;&nbsp; def push(self, val: int) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.stack.append(val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = min(val, self.minStack[-1] if self.minStack else val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.minStack.append(val)<br><br>&nbsp;&nbsp;&nbsp; def pop(self) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.minStack.pop()<br><br>&nbsp;&nbsp;&nbsp; def top(self) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.stack[-1]<br><br>&nbsp;&nbsp;&nbsp; def getMin(self) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.minStack[-1]	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Evaluate Reverse Polish Notation	Medium		stack	if it's a number then append to the stack<br>if it's an operator then pop the last two elements off the stack and do the necessary operation and then append that result to the stack.<br>then return the last value on the stack	"class Solution:<br>&nbsp;&nbsp;&nbsp; def evalRPN(self, tokens: List[str]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in tokens:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c == ""+"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(stack.pop() + stack.pop())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif c == ""-"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a, b = stack.pop(), stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(b - a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif c == ""*"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(stack.pop() * stack.pop())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif c == ""/"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a, b = stack.pop(), stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(int(float(b) / a))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(int(c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return stack[0]"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Daily Temperatures	Medium		monotonic decreasing stack	"<ul><li>The stack is used to keep track of temperatures that have not yet found a warmer day.</li><li>For each temperature, the code checks if it is warmer than the temperature on the top of the stack (most recent unprocessed temperature).</li><li>While the stack is not empty and the current temperature (<code>t</code>) is greater than the temperature at the top of the stack (<code>stack[-1][0]</code>):</li><li>It means we have found the next warmer day for the temperature at&nbsp;<code>stackInd</code>.</li></ul><div><div><div><span style=""color: #008000;"">- use the current temp to resolve previous temps saved in the stack. The temperatures in the </span></div><div><span style=""color: #008000;"">- stack have not have been resolved yet and they must necessarily be decreasing, otherwise </span></div><div><span style=""color: #008000;"">- some of them would be resolved. So, use the current temp to resolve as many on the stack as</span></div><div><span style=""color: #008000;"">- possible.</span></div></div></div>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = [0] * len(temperatures)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []&nbsp; # pair: [temp, index]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i, t in enumerate(temperatures):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while stack and t &gt; stack[-1][0]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackT, stackInd = stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res[stackInd] = i - stackInd<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append((t, i))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑛)</span></li></ul>"
Car Fleet	Medium		stack	zip the two arrays together to make pairs<br>reverse the array of pairs<br>iterate through the array and&nbsp;for each pair, append the time until the end for that car to the stack<br>every time you add to the stack, check if there's an existing value on the top of the stack (where existing values are going to represent cars that are closer in terms of distance to the end). if the value you're adding is lower than or equal to the value at the top of the stack, that means you have a car that is further away from the end but will take an equal amount of time or less to get there... so they will form a fleet, so pop that value you just added rather than the one that existing one.<br>return the length of the stack	"class Solution:<br>&nbsp;&nbsp;&nbsp; def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair = [(p, s) for p, s in zip(position, speed)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair.sort(reverse=True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for p, s in pair:&nbsp; # Reverse Sorted Order<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append((target - p) / s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(stack) &gt;= 2 and stack[-1] &lt;= stack[-2]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return len(stack)"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛log⁡𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li></ul>"
Search a 2D Matrix	Medium		Treat the 2D array like it's a 1D array and do a Binary Search (because it's sorted)	"<ul><li><code>l</code>&nbsp;is the leftmost index (0), representing the first element in the matrix.</li><li><code>r</code>&nbsp;is the rightmost index (<code>ROWS * COLS - 1</code>), representing the last element in the matrix.</li><li><strong>Midpoint (<code>m</code>):</strong>&nbsp;The middle index of the current search range.</li><li>Convert the 1D midpoint&nbsp;<code>m</code>&nbsp;into 2D coordinates using:</li><ul><li>row=𝑚//COLSrow=<span style=""font-style: italic;"">m</span>//COLS&nbsp;(integer division).</li><li>col=𝑚%COLScol=<span style=""font-style: italic;"">m</span>%COLS&nbsp;(remainder).</li></ul><li>Compare the target with the matrix element at&nbsp;matrix[row][col]matrix[row][col]:<ul><li>If&nbsp;<code>target</code>&nbsp;is greater, search the right half by moving&nbsp;<code>l</code>&nbsp;to&nbsp;𝑚+1<span style=""font-style: italic;"">m</span>+1.</li><li>If&nbsp;<code>target</code>&nbsp;is smaller, search the left half by moving&nbsp;<code>r</code>&nbsp;to&nbsp;𝑚−1<span style=""font-style: italic;"">m</span>−1.</li><li>If&nbsp;<code>target</code>&nbsp;is equal, return&nbsp;<code>True</code>.</li></ul></li></ul>"	class Solution:<br>&nbsp;&nbsp;&nbsp; def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(matrix), len(matrix[0])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, ROWS * COLS - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = l + (r - l) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col = m // COLS, m % COLS<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if target &gt; matrix[row][col]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = m + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif target &lt; matrix[row][col]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = m - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(log⁡(𝑚∗𝑛))</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span></li></ul>"
Koko Eating Bananas	Medium		Binary Search<br>The maximum eating speed, k, is going to be max(piles)<br>The minimum eating speed is going to be 1.<br>So do a binary search from 1 to max(piles)&nbsp;	"<ul><li>When a valid&nbsp;<span style=""font-style: italic;"">k</span>&nbsp;is found, the algorithm doesn't stop immediately. Instead, it continues to explore smaller values (𝑟=𝑘−1) to see if a smaller&nbsp;<span style=""font-style: italic;"">k</span>&nbsp;also works.</li><li>This ensures that the algorithm finds the smallest valid&nbsp;<span style=""font-style: italic;"">k</span>&nbsp;before exiting.</li></ul>"	class Solution:<br>&nbsp;&nbsp;&nbsp; def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 1, max(piles)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = r<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = (l + r) // 2<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalTime = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for p in piles:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalTime += math.ceil(float(p) / k)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if totalTime &lt;= h:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = k<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = k - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = k + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛∗log⁡𝑚)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span></li></ul>"
Find Minimum in Rotated Sorted Array	Medium		Binary search	use res to keep track of the minimum found so far<br>if the array is rotated, the array will have two sorted portions and the minimum element will be the first element in the right portion.<br>use binary search to find the switching point of the array<br><ul><li><code>res</code>&nbsp;is initialized to the first element of the array (<code>nums[0]</code>). It keeps track of the minimum value found so far.</li><li>If the subarray between&nbsp;<code>l</code>&nbsp;and&nbsp;<code>r</code>&nbsp;is sorted (<code>nums[l] &lt; nums[r]</code>), the smallest element is at&nbsp;<code>nums[l]</code>.</li><li>Update&nbsp;<code>res</code>&nbsp;to the smaller value between&nbsp;<code>res</code>&nbsp;and&nbsp;<code>nums[l]</code>.</li><li>Exit the loop early since there’s no need to search further.</li><li><code>m</code>&nbsp;is the middle index of the current search window.</li><li>Update&nbsp;<code>res</code>&nbsp;to the smaller value between&nbsp;<code>res</code>&nbsp;and&nbsp;<code>nums[m]</code>.</li><li>If the value at&nbsp;<code>nums[m]</code>&nbsp;is&nbsp;<strong>greater than or equal to&nbsp;<code>nums[l]</code></strong>, the left half is sorted, so the minimum must be in the&nbsp;<strong>right half</strong>. Move the left pointer:&nbsp;<code>l = m + 1</code>.</li><li>Otherwise, the right half is unsorted, so the minimum must be in the&nbsp;<strong>left half</strong>. Move the right pointer:&nbsp;<code>r = m - 1</code>.</li><li>return res outside the loop</li></ul>	class Solution:<br>&nbsp;&nbsp;&nbsp; def findMin(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(nums) - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[l] &lt; nums[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = min(res, nums[l])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = (l + r) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = min(res, nums[m])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[m] &gt;= nums[l]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = m + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = m - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(log⁡𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li></ul>"
Search in Rotated Sorted Array	Medium		binary search	the rotated array creates two sorted portions<br><ol><li><div><strong>Identify which portion is sorted</strong>:</div><ul><li>If&nbsp;<code>nums[m] &gt;= nums[l]</code>, the left portion is sorted.</li><li>Otherwise, the right portion is sorted.</li></ul></li><li><div><strong>Check if the target lies within the sorted portion</strong>:</div><ul><li>For the left portion:&nbsp;<code>nums[l] &lt;= target &lt; nums[m]</code>.</li><li>For the right portion:&nbsp;<code>nums[m] &lt; target &lt;= nums[r]</code>.</li></ul></li><li><div><strong>Update pointers accordingly</strong>:</div><ul><li>Narrow down the search space based on whether the target is in the sorted or unsorted portion.</li></ul></li></ol>	class Solution:<br>&nbsp;&nbsp;&nbsp; def search(self, nums: List[int], target: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(nums) - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (l + r) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if target == nums[mid]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return mid<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[l] &lt;= nums[mid]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[l] &lt;= target &lt; nums[mid]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = mid - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = mid + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[m] &lt; target &lt;= nums[r]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = mid + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = mid - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(log⁡𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(1)</span></li></ul>"
Time Based Key Value Store	Medium		Binary Search	"Notice these types of binary search problem where you aren't necessarily looking for an exact value but a value that most satisfies a condition.<br>In these instances, we keep a running result that we update over time. Because our window is moving in the correct direction, so too will our result. And when the window correctly narrows down to a single value, so too will the result.<br><br>In this problem, the values are being set with increasing timestamps, so within each key the tuples are sorted according to timestamp.<br>So we do a binary search to find the timestamp given, or if it does not exist we find the closest previous timestamp. If there's no key exists or there's no previous timestamp, we return """".<br><br>As mentioned above, even if we don't find the exact timestamp, we want to find the largest previous timestamp, so if the current mid value is smaller than the timestamp, then we want to move our window right, because either the exact timestamp is right, or there is no exact timestamp but we want to see if there is a larger timestamp that is still &lt;= timestamp given."	"<div><div>from collections import defaultdict<br><br>class TimeMap:<br><br>&nbsp;&nbsp;&nbsp; def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # value is a tuple of value given and timestamp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dict = defaultdict(list)<br><br>&nbsp;&nbsp;&nbsp; def set(self, key: str, value: str, timestamp: int) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dict[key].append((value, timestamp))<br><br>&nbsp;&nbsp;&nbsp; def get(self, key: str, timestamp: int) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Binary search to find the timestamp or the most recent timestamp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if key not in self.dict:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vals = self.dict[key]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(vals) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = (l + r) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if vals[m][1] == timestamp:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return vals[m][0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif vals[m][1] &lt; timestamp:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = vals[m][0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = m + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = m - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br></div></div>"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span>&nbsp;for&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">se</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">t</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span>&nbsp;and&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">lo<span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">g</span></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span>&nbsp;for&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">g</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">e</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">t</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span>.</li><li>Space complexity:<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">m</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">∗</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Reverse Linked List	Easy		set prev=None and curr=head	set prev = None and curr = head&nbsp;<br>while curr: make a tmp pointer to curr.next and set curr.next equal to prev<br>return prev	"# Definition for singly-linked list.<br># class ListNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, next=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.next = next<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def reverseList(self, head: ListNode) -&gt; ListNode:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev, curr = None, head<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while curr:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = curr.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr.next = prev<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = curr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr = temp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prev"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">1</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Merge Two Sorted LinkedLists	Easy		Use a dummy node at the start	<ol><li><div><strong>Dummy Node</strong>:</div><ul><li>A dummy node is used as a starting point for the merged list. This simplifies the logic since you don't need special handling for the head of the merged list.</li></ul></li><li><div><strong>Current Pointer</strong>:</div><ul><li><code>current</code>&nbsp;keeps track of the last node in the merged list as you iterate through&nbsp;<code>list1</code>&nbsp;and&nbsp;<code>list2</code>.</li></ul></li><li><div><strong>Remaining Nodes</strong>:</div><ul><li>After exiting the&nbsp;<code>while</code>&nbsp;loop, either&nbsp;<code>list1</code>&nbsp;or&nbsp;<code>list2</code>&nbsp;may still have remaining nodes. These nodes are directly attached to the merged list.</li></ul></li><li><div><strong>Returning the Result</strong>:</div><ul><li>The merged list starts at&nbsp;<code>dummy.next</code>&nbsp;since&nbsp;<code>dummy</code>&nbsp;is a placeholder node.</li></ul></li></ol>	"# Definition for singly-linked list.<br># class ListNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, next=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.next = next<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Dummy node to start the merged list<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dummy = ListNode()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current = dummy<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Merge the two lists<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while list1 and list2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if list1.val &lt;= list2.val:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current.next = list1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list1 = list1.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current.next = list2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list2 = list2.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current = current.next<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Attach the remaining nodes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if list1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current.next = list1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if list2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current.next = list2<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Return the merged list starting from the next node of dummy<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dummy.next"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛+𝑚)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span></li></ul>"
Invert Binary Tree	Easy		DFS	flip the two children and then call invert on them	"# Definition for a binary tree node.<br># class TreeNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, left=None, right=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.left = left<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.right = right<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not root: return None<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root.left, root.right = root.right, root.left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.invertTree(root.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.invertTree(root.right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return root"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Maximum Depth of Binary Tree	Easy		recursion	in each call, return 1 + maxDepth of left or right subtree	"# Definition for a binary tree node.<br># class TreeNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, left=None, right=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.left = left<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.right = right<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxDepth(self, root: Optional[TreeNode]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not root:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Diameter of Binary Tree	Easy		dfs function	"<div>The key observation to make is:<em>the longest path has to be between two leaf nodes</em>. We can prove this with contradiction. Imagine that we have found the longest path, and it is<strong>not</strong>between two leaf nodes. We can extend that path by 1, by adding the child node of one of the end nodes (as at least one must have a child, given that they aren't both leaves). This contradicts the fact that our path is the longest path. Therefore, the longest path must be between two leaf nodes.</div><div>Moreover, we know that in a tree, nodes are only connected with their parent node and 2 children. Therefore we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized. This would hint at us to apply Depth-first search (DFS) to count each node's branch lengths, because it would allow us to dive deep into the leaves first, and then start counting the edges upwards.</div><blockquote><div>DFS is a widely-used graph traversal algorithm. If you are not familiar with it, feel free to visit our<a href=""https://leetcode.com/explore/learn/card/data-structure-tree/"">Explore Cards</a>where you will see different ways to traverse a binary tree with DFS including preorder, inorder, postorder :)</div></blockquote><div>Let's try to be more specific about how to apply DFS to this question. To count the lengths of each node's left and right branches, we can implement a recursion function<code>longestPath</code>which takes a<code>TreeNode</code>as input and returns the longest path from it to the leaf node. It will recursively visit children nodes and retrieve the longest paths from them to the leaf first, and then add<code>1</code>to the longer one before returning it as the longest path.</div><div>In the midst of DFS, we also need to take the following two cases into account:</div><ol><li>the current node's both left and right branches might be a part of the longest path;</li><li>one of the current node's left/right branches might be a part of the longest path.</li></ol><div><img alt=""Two cases of the longest path."" src=""543.png""></div><div><em>Figure 1. Two cases of the longest path.</em></div><div>You will see we are going to address them by 1) applying DFS to recursively find the longest branches starting with the node's left and right children; 2) initializing a global variable<code>diameter</code>to keep track of the longest path and updating it at each node with the sum of the node's left and right branches; 3) returning the length of the longest branch between a node's left and right branches.</div><div><strong>Algorithm</strong></div><ul><li>Initalize an integer variable<code>diameter</code>to keep track of the longest path we find from the DFS.</li><li>Implement a recursive function<code>longestPath</code>which takes a<code>TreeNode</code>as input. It should recursively explore the entire tree rooted at the given node. Once it's finished, it should return the longest path out of its left and right branches:<ul><li>if<code>node</code>is<code>None</code>, we have reached the end of the tree, hence we should return<code>0</code>;</li><li>we want to recursively explore<code>node</code>'s children, so we call<code>longestPath</code>again with<code>node</code>'s left and right children. In return, we get the longest path of its left and right children<code>leftPath</code>and<code>rightPath</code>;</li><li>if<code>leftPath</code>plus<code>rightPath</code>is longer than the current longest diameter found, then we need to update<code>diameter</code>;</li><li>finally, we return the longer one of<code>leftPath</code>and<code>rightPath</code>. Remember to add<span style=""color: rgba(38, 38, 38, 0.75);"">1</span>as the edge connecting it with its parent.</li></ul></li><li>Call<code>longestPath</code>with<code>root</code>.</li></ul>"	"# Definition for a binary tree node.<br># class TreeNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, left=None, right=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.left = left<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.right = right<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(root):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonlocal res<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not root:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = dfs(root.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = dfs(root.right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, left + right)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 + max(left, right)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(root)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li></ul>"
Level Order Traversal	Medium		deque	whlie q, iterate the through the queue adding nodes to the current level and adding the neighbours to the queue.	"&nbsp;# Definition for a binary tree node.<br># class TreeNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, left=None, right=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.left = left<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.right = right<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = collections.deque()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.append(root)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while q:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qLen = len(q)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(qLen):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node = q.popleft()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if node:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level.append(node.val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.append(node.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.append(node.right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if level:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(level)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li></ul>"
Matrix Depth First Search	Medium		dfs and visit set	use a helper function and set to track vitisted nodes and from that node try all combinations of movements	class Solution:<br>&nbsp;&nbsp;&nbsp; def countPaths(self, grid: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def helper(grid: List[List[int]], r: int, c: int, visit: set) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (min(r, c) &lt; 0 or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r == ROWS or c == COLS or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (r, c) in visit or grid[r][c] == 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if r == ROWS - 1 and c == COLS - 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit.add((r, c))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += helper(grid, r + 1, c, visit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += helper(grid, r - 1, c, visit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += helper(grid, r, c + 1, visit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += helper(grid, r, c - 1, visit)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit.remove((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return count<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return helper(grid, 0, 0, set())	<ul><li><strong>Time Complexity</strong>:&nbsp;𝑂(4^𝑚⋅𝑛)&nbsp;in the theoretical worst case; pruned significantly by constraints.</li><li><strong>Space Complexity</strong>:&nbsp;𝑂(𝑚⋅𝑛).</li></ul>
Number of Islands	Medium		find number of connected components	find number of connected components.<br>this means you have to loop over all of the 1s and see if they are not in visited. If this is the case, you want to increase count by one and dfs from that 1 to find all the ones connected to it and mark them all as visited.&nbsp;<br>return the count at the end.<br>your helper dfs function should check the indices are in bound and then check if they have been visited before.	"from typing import List<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def numIslands(self, grid: List[List[str]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(r, c):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check bounds first to avoid IndexError<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if r &lt; 0 or c &lt; 0 or r &gt;= ROWS or c &gt;= COLS or grid[r][c] == '0' or (r, c) in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Explore neighbors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r - 1, c)&nbsp; # Up<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r + 1, c)&nbsp; # Down<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r, c - 1)&nbsp; # Left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r, c + 1)&nbsp; # Right<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r, c) not in visited and grid[r][c] == '1':<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += 1&nbsp; # Start of a new island<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r, c)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return count"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛)</span></li></ul>"
Max Area of Island	Medium		similar to number of islands except here when we explore an island, we count up its area&nbsp;	we first loop through all the 1s and see if they are visited. if so, it means we have already explored them as part of a previous island. if not, we perform a dfs on it, counting up the nodes as we go and adding them to visited. Once we have calculated the area of an island, we record whether its bigger than the maximum. return maximum at the end.	"class Solution:<br>&nbsp;&nbsp;&nbsp; def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxArea = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(r, c):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Base case: Out of bounds, water, or already visited<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if r &lt; 0 or c &lt; 0 or r &gt;= ROWS or c &gt;= COLS or grid[r][c] == 0 or (r, c) in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Mark the cell as visited<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Calculate the area recursively<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area += dfs(r + 1, c)&nbsp; # Down<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area += dfs(r - 1, c)&nbsp; # Up<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area += dfs(r, c + 1)&nbsp; # Right<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; area += dfs(r, c - 1)&nbsp; # Left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return area<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Iterate through the grid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r, c) not in visited and grid[r][c] == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Calculate area of the island starting from (r, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = dfs(r, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxArea = max(maxArea, A)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return maxArea"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗𝑛)</span></li></ul>"
Python Asynchronous Scraper	Medium	interview	define fetch function that takes a session and gets the url and returns the response<br>define main function that creates the session and creates a list of tasks where each task is a fetch to a url.<br>gather the tasks and save the htmls. then print		"import aiohttp<br>import asyncio<br>import time<br><br>async def fetch_page(session, url):<br>&nbsp;&nbsp;&nbsp; """"""Fetch the content of a page asynchronously.""""""<br>&nbsp;&nbsp;&nbsp; async with session.get(url) as response:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return await response.text()<br><br>async def main():<br>&nbsp;&nbsp;&nbsp; """"""Main function to fetch multiple pages concurrently.""""""<br>&nbsp;&nbsp;&nbsp; urls = [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""https://www.scrapingcourse.com/ecommerce/"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""https://www.scrapingcourse.com/ecommerce/page/2/"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""https://www.scrapingcourse.com/ecommerce/page/3/"",<br>&nbsp;&nbsp;&nbsp; ]<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; async with aiohttp.ClientSession() as session:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tasks = [fetch_page(session, url) for url in urls]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; htmls = await asyncio.gather(*tasks)<br><br>&nbsp;&nbsp;&nbsp; for url, html in zip(urls, htmls):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f""URL: {url}, Content: {html[:100]}..."")&nbsp; # Print first 100 characters of content<br><br>asyncio.run(main())"	
Matrix Breadth-First Search	Medium		use queue and maintain length at each distance level away from starting node		<div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def shortestPath(self, grid: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue = deque()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((0, 0))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit.add((0, 0))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while queue:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(queue)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r, c = queue.popleft()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if r == ROWS - 1 and c == COLS - 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return length<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dr, dc in neighbors:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (min(r + dr, c + dc) &lt; 0 or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r + dr == ROWS or c + dc == COLS or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (r + dr, c + dc) in visit or grid[r + dr][c + dc] == 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((r + dr, c + dc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit.add((r + dr, c + dc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1<br></div></div>	"<ol><li><div><strong>Time Complexity</strong>:</div><ul><li>Each cell is visited once, and each edge is processed once.</li><li>For an&nbsp;<span style=""font-style: italic;"">m</span>×<span style=""font-style: italic;"">n</span>&nbsp;grid, this gives&nbsp;<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>×<span style=""font-style: italic;"">n</span>).</li></ul></li><li><div><strong>Space Complexity</strong>:</div><ul><li>The queue and&nbsp;<code>visited</code>&nbsp;set store at most&nbsp;𝑂(𝑚×𝑛)<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>×<span style=""font-style: italic;"">n</span>)&nbsp;elements.</li><li>Overall space complexity is&nbsp;<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>×<span style=""font-style: italic;"">n</span>).</li></ul></li></ol>"
Rotten Fruit	Medium		Binary Search with matrix and various extra conditions&nbsp;	we don't need a queue in this one because we can just change the grid cell from a 1 to a 2 when we pop it.<br>the general idea with this one is to loop through the whole grid and add all the rotting fruit to the queue.&nbsp;<br>then do a multisource bfs from the rotten fruits and see how long it takes for the whole grid to be rotten, if possible.<br>when we loop through the first time, we should also count the number of fresh fruit. this way when we find a fresh fruit and turn<br>it to a rotten fruit in the bfs later on, we can decrement the fresh fruit count. this means at the end we will know if all the fresh fruit have&nbsp;<br>been turned.<br><br>in the bfs, we want to remember to:<br><ul><li>avoid empty cells and cells with rotten fruit</li><li>include the clause about freshCount &gt; 0 in the while loop</li><li>decrement freshCount when we come across a fresh fruit and turn it rotten</li></ul>	"from collections import deque<br>from typing import List<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def orangesRotting(self, grid: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue = deque()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freshCount = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minutes = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize queue with all rotten oranges and count fresh oranges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if grid[r][c] == 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif grid[r][c] == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freshCount += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Perform BFS<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while queue and freshCount &gt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for _ in range(len(queue)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r, c = queue.popleft()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dr, dc in directions:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr, nc = r + dr, c + dc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check bounds and if the orange is fresh<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 0 &lt;= nr &lt; ROWS and 0 &lt;= nc &lt; COLS and grid[nr][nc] == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grid[nr][nc] = 2&nbsp; # Rot the orange<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((nr, nc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freshCount -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minutes += 1&nbsp; # Increment minutes after processing a level<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If there are fresh oranges left, return -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return minutes if freshCount == 0 else -1"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">m</span><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-style: inherit; font-weight: inherit;""></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">m</span><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-style: inherit; font-weight: inherit;""></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul>"
Happy Number	Easy		use a set	use a set to track numbers that you've come across before in the loop. if you've come across it before it means you're in an endless loop.	class Solution:<br>&nbsp;&nbsp;&nbsp; def isHappy(self, n: int) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit = set()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while n not in visit:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visit.add(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = self.sumOfSquares(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br><br>&nbsp;&nbsp;&nbsp; def sumOfSquares(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while n:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digit = n % 10<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digit = digit ** 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output += digit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = n // 10<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(log⁡𝑛)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(log⁡𝑛)</span></li></ul>"
Best Time to Buy and Sell Stock	Easy		sliding window or dynamic programming	at each stage, we want to keep track of what the lowest is and then what the maximum increase is. so initialize both of these variables and iterate through prices once and update accordingly	"class Solution:<br>&nbsp;&nbsp;&nbsp; def maxProfit(self, prices: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize the lowest price as the first price in the list<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowest = prices[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize the maximum profit to 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxIncrease = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Iterate through the prices starting from the second element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for price in prices[1:]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Update the lowest price seen so far<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowest = min(lowest, price)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Calculate the potential profit and update the maximum profit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxIncrease = max(maxIncrease, price - lowest)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Return the maximum profit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return maxIncrease"	"<div><div><div><div><div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span></li></ul></div></div></div></div></div><br>"
Longest Substring Without Repeating Characters	Medium		sliding window/two pointer	keep track of chars seen using a set.<br>iterate the right pointer over the chars and add to the set if you havent seen the char. check the max length of the set each you time you add to it<br>if you have seen it, we need to remove the first occurence of that char and everything preceding it from seen so iterate the left pointer towards the right pointer until you find that first occurrence.&nbsp;	"class Solution:<br>&nbsp;&nbsp;&nbsp; def lengthOfLongestSubstring(self, s: str) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Handle edge case for empty string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(s) == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize pointers and variables<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Iterate through the string using the right pointer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(s):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[r] not in seen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Add the character to the set and update the longest length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add(s[r])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest = max(longest, len(seen))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Remove characters from the left until the duplicate is removed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt; r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[l] == s[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.remove(s[l])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return longest"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑚)</span></span></li></ul><div>where n is the length and m is the number of unique characters</div>"
Longest Repeating Character Replacement	Medium		use a sliding window and a hashmap to maintain the most frequent character within the window.<br>	this means as you iterate through the list, increase the count of the current char and save the max frequency, which could either be the previous maxf or the frequency of the char you just incremented.<br>the number of other characters will be (r-l+1)-maxf because r-l+1 represents the length of the string and maxf is the most frequent char in the string.<br>so then we check if the number of other characters in the string exceeds k. if it does, then we want to increment the left pointer by 1 and decrease its frequency in the map.<br>what all this does is constantly maintain a valid window with respect to how many replacements you can make. this means that at the end of the iteration, you can check the maximum of the existing res and the current length of the window r-l+1.	class Solution:<br>&nbsp;&nbsp;&nbsp; def characterReplacement(self, s: str, k: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxf = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count[s[r]] = 1 + count.get(s[r], 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxf = max(maxf, count[s[r]])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (r - l + 1) - maxf &gt; k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count[s[l]] -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, r - l + 1)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑚)</span></span></li></ul>"
Permutation in String	Medium		hashmap to maintain frequency of window	create a freq map for both s1. then create a window the same size as s1 in s2 and the corresponding freq map for it and start shifting through s2, updating the frequencies&nbsp;<br>as you go. check at each iteration if the freq map for s1 is the same as the one for the sliding window for s2.	"<div>from collections import Counter<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def checkInclusion(self, s1: str, s2: str) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If s1 is longer than s2, permutation is not possible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(s1) &gt; len(s2):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize pointers and counters<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(s1) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countOne = Counter(s1)&nbsp; # Frequency map of s1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countTwo = Counter(s2[:len(s1) - 1])&nbsp; # Frequency map of first len(s1) - 1 characters in s2<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Sliding window loop<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(s2):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Include the rightmost character in the window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countTwo[s2[r]] = countTwo.get(s2[r], 0) + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check if the current window matches the frequency map of s1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if countOne == countTwo:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Remove the leftmost character from the window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countTwo[s2[l]] -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if countTwo[s2[l]] == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; del countTwo[s2[l]]&nbsp; # Clean up zero-count entries to maintain consistency<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Move the window forward<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If no permutation is found, return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br></div>"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(𝑛∗𝑚)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">𝑂(1)</span></span></li></ul>"
Clone Graph	Medium		dfs or bfs	we want to create a map that contains original nodes to copy nodes. this map ensures that we do not recurse infinitely as we can check in our base case whether a node&nbsp;<br>we have recursed to is already in the map. if it is, then we return the copy. then in each iteration we create a copy of the current node with the right value and then&nbsp;<br>assign as the value to the original node in the map. then we loop through all the neighbors and dfs those and append them to the neighbors of the copy. then return the copy.	"""""""<br># Definition for a Node.<br>class Node:<br>&nbsp;&nbsp;&nbsp; def __init__(self, val = 0, neighbors = None):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.neighbors = neighbors if neighbors is not None else []<br>""""""<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def cloneGraph(self, node: Optional['Node']) -&gt; Optional['Node']:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldToNew = {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(node):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if node in oldToNew:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oldToNew[node]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy = Node(node.val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldToNew[node] = copy<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for nei in node.neighbors:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy.neighbors.append(dfs(nei))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return copy<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dfs(node) if node else None"	
Islands and Treasure	Medium		multi source bfs	we want to loop through and find the treasure chests. when we come across a treasure chest we perform a bfs from it.<br>any land cell we come across starting from a particular treasure chest, we check if it has already been assigned a nearest distance from another chest.<br>if the distance from the current chest is lower, then we assign the distance from the current chest to the land cell.&nbsp;<br>we also calculate the base cases and add to the visisted set as usual, making sure to avoid -1 cells which we can't cross and 0s.&nbsp;<br>we avoid the 0 cells because if we search through that 0, then any land cell we come across after that will be closer to that 0 cell rather than the 0 cell we started from.<br>so we leave that to a future (or previous) bfs iteration.<br>in this below solution, we set the value of the land cell equal to length + 1 because we are assigning it before we actually get to it. we know this because we&nbsp;<br>assign it in the neighbor for loop where we are looking at possible neighbors to the current cell.	"from collections import deque<br>from typing import List<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def islandsAndTreasure(self, grid: List[List[int]]) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Dimensions of the grid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(grid), len(grid[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def bfs(r, c):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue = deque()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while queue:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(queue)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r, c = queue.popleft()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dr, dc in neighbors:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr, nc = r + dr, c + dc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Boundary and validity checks<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr &lt; 0 or nc &lt; 0 or nr &gt;= ROWS or nc &gt;= COLS or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (nr, nc) in visited or grid[nr][nc] == -1 or grid[nr][nc] == 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Update grid distance if shorter path is found<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if length + 1 &lt; grid[nr][nc] &lt;= 2147483647:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grid[nr][nc] = length + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((nr, nc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add((nr, nc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Increment distance for the next layer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Perform BFS from each treasure chest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if grid[r][c] == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bfs(r, c)"	"<ul><li>Time complexity:&nbsp;<span style=""font-weight: inherit;""><span style=""font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-weight: inherit;""><i>T</i></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-weight: inherit;""><i>V</i></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-weight: inherit;""><span style=""font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-weight: inherit;""><i>T</i></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-weight: inherit;""><i>V</i></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul><div>Where <i>T&nbsp;</i>is the number of chests and <i>V</i>&nbsp;is the number of cells in the&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">g</span><span style=""font-style: italic; font-weight: inherit;"">r</span><span style=""font-style: italic; font-weight: inherit;"">i</span><span style=""font-style: italic; font-weight: inherit;"">d</span></span></span>.&nbsp;<br></div>"
Kth Largest Element in a Stream	Easy		Heap	<li>Initializes <code>nums</code> as a min-heap using <code>heapq.heapify()</code>. A min-heap ensures that the smallest element is always at the root.</li><li>Trims <code>nums</code> down to contain only the top k&nbsp;largest elements by repeatedly removing the smallest element (using <code>heapq.heappop()</code>)</li>with the add function:<ul><li>Adds the new number to the heap (<code>heapq.heappush()</code>).</li><li>Checks if the heap size exceeds kkk. If so, removes the smallest element (ensuring the heap only contains the top kkk largest numbers).</li><li>Returns the kkk-th largest number, which is the smallest element in the heap (<code>self.minHeap[0]</code>).</li></ul><div>Alternative Solution:</div><div>this solution relies on the fact that if you want to return the kth largest number, then you should maintain the largest k numbers and return the smallest of them each time you add. Maintaining the largest k numbers means that whenever you get more than k numbers, you remove the smallest of them.</div><div><br></div>	"class KthLargest:<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; def __init__(self, k: int, nums: List[int]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.minHeap, self.k = nums, k<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heapify(self.minHeap)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while len(self.minHeap) &gt; k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappop(self.minHeap)<br><br>&nbsp;&nbsp;&nbsp; def add(self, val: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappush(self.minHeap, val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(self.minHeap) &gt; self.k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappop(self.minHeap)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.minHeap[0]<br><br><br>Alternative Solution:<br>class KthLargest:<br>&nbsp;&nbsp;&nbsp; def __init__(self, k: int, nums: List[int]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""Initialize the KthLargest object with a min-heap of size k.""""""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.k = k&nbsp; # Fixed the typo: 'ka' -&gt; 'k'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.heap = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.add(num)&nbsp; # Populate the heap using the add method<br><br>&nbsp;&nbsp;&nbsp; def add(self, val: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""Adds a new value and returns the kth largest element.""""""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappush(self.heap, val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(self.heap) &gt; self.k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappop(self.heap)&nbsp; # Maintain only k elements in the heap<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.heap[0]&nbsp; # The kth largest element (smallest in the heap)<br>"	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑚∗log⁡𝑘)</span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑂(𝑘)</span></li></ul><div>Where&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">m</span></span></span>&nbsp;is the number of calls made to&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">𝑎𝑑𝑑()</span><br></div>"
Last Stone Weight	Easy		Heap	"<li><div>Approach 1 found and removed the maximum stones in<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>time, and added the new stone in<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>time. Approach 2 inverted this, as finding and removing the maximum stones took<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>time, but adding the new stone took<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>time. In both cases, we're left with an overall time complexity of<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>per stone-smash turn.</div><div>We want to find a solution that makes both removing the maximums, and adding a new stone,<em>less than</em>&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div><div>For this kind of maximum-maintenance, we use a<strong>Max-Heap</strong>, also known as a<strong>Max-Priority Queue</strong>. A Max-Heap is a data structure that can take items, and can remove and return the maximum, with both operations taking<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">N</span>)</span>time. It does this by maintaining the items in a special order (within the array), or as a balanced binary tree. We don't need to know these details though, almost all programming languages have a Heap data structure!</div><div>Here is the pseudocode using a Heap.</div><div><div><pre><code>define function last_stone_weight(stones):
    heap = a new Max-Heap
    add all stones to heap
    while heap contains more than 1 stone:
        heavy_stone_1 = remove max from heap
        heavy_stone_2 = remove max from heap
        if heavy_stone_1 is heavier than heavy_stone_2:
            new_stone = heavy_stone_1 - heavy_stone_2
            add new_stone to heap
    if heap is empty:
        return 0
    return last stone on heap</code></pre><div></div></div></div>Algorithm<div>While most programming languages have a<strong>Heap/ Priority Queue</strong>data structure, some, such as Python and Java, only have<strong>Min-Heap</strong>. Just as the name suggests, this is a Heap that instead of always returning the maximum item, it returns the minimum. There are two solutions to this problem:</div><ol><li>Multiply all numbers going into the heap by<code>-1</code>, and then multiply them by<code>-1</code>to restore them when they come out.</li><li>Pass a comparator in (language-dependent).</li></ol><br></li>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def lastStoneWeight(self, stones: List[int]) -&gt; int:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Make all the stones negative. We want to do this *in place*, to keep the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # space complexity of this algorithm at O(1). :-)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(stones)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stones[i] *= -1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Heapify all the stones.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heapify(stones)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # While there is more than one stone left, remove the two<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # largest, smash them together, and insert the result<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # back into the heap if it is non-zero.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while len(stones) &gt; 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stone_1 = heapq.heappop(stones)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stone_2 = heapq.heappop(stones)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if stone_1 != stone_2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappush(stones, stone_1 - stone_2)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check if there is a stone left to return. Convert it back<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # to positive.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -heapq.heappop(stones) if stones else 0"	"<ul><li><div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N&nbsp;</span></span>be the<strong>length of stones</strong>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>log<span style=""font-style: italic;"">N</span>)</span>.</div><div>Converting an array into a Heap takes<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>time (it isn't actually sorting; it's putting them into an order that allows us to get the maximums, each in<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">N</span>)</span>time).</div><div>Like before, the main loop iterates up to<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span>−1</span>times. This time however, it's doing up to three<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">N</span>)</span>operations each time; two removes, and an optional add. Like always, the three is an ignored constant. This means that we're doing<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span>⋅<span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">N</span>)=<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>log<span style=""font-style: italic;"">N</span>)</span>operations.</div></li><li><div>Space complexity :<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">N</span>)</span>.</div><div>In Python, converting a list to a heap is done in place, requiring<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>auxiliary space, giving a total space complexity of<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. Modifying the input has its pros and cons; it saves space, but it means that other functions can't use the same array.</div><div><br></div></li></ul></li></ul>"
Pacific Atlantic Water Flow	Medium		dfs from the edges	- we perform a dfs from the edges directly connecting to the atlantic, pacific or both.<br>- we create sets for pacific and atlantic to keep track of cells that can reach them.&nbsp;<br>- from each starting cell, we traverse to cells upstream and cells that aren't in either atlantic or pacific (depending on what the source was), adding to the&nbsp;<br>right pacific or atlantic set.<br>- return the intersection of the pacific and atlantic set.	"class Solution:<br>&nbsp;&nbsp;&nbsp; def pacificAtlantic(self, heights: List[List[int]]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(heights), len(heights[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pacific = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atlantic = set()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(r, c, visited):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add((r, c))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr, nc = r + dr, c + dc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= nr &lt; ROWS and 0 &lt;= nc &lt; COLS and&nbsp; # Valid neighbor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (nr, nc) not in visited and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Not already visited<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heights[nr][nc] &gt;= heights[r][c]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Water can flow<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(nr, nc, visited)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Run DFS for Pacific and Atlantic edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r, 0, pacific)&nbsp; # Left edge (Pacific)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(r, COLS - 1, atlantic)&nbsp; # Right edge (Atlantic)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(0, c, pacific)&nbsp; # Top edge (Pacific)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(ROWS - 1, c, atlantic)&nbsp; # Bottom edge (Atlantic)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Intersection of cells reachable by both oceans<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return list(pacific &amp; atlantic)<br>"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">m</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">∗</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">m</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">∗</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span></span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Surrounded Regions	Medium		dfs&nbsp;	Step 1: Identify <code>'O'</code> Regions Connected to the Boundary<div>The <code>capture</code> function is a Depth-First Search (DFS) that marks all <code>'O'</code> cells connected to the boundary with a temporary marker (<code>'T'</code>).</div><ol><li>The algorithm starts by traversing the edges of the board:<ul><li><strong>Top and bottom rows:</strong> Traverse all cells in the first and last rows.</li><li><strong>Left and right columns:</strong> Traverse all cells in the first and last columns.</li></ul></li><li>If an <code>'O'</code> cell is found, the <code>capture</code> function is called recursively to:<ul><li>Mark the current cell as <code>'T'</code>.</li><li>Explore all 4 adjacent cells (up, down, left, right).</li></ul></li></ol>Step 2: Process the Entire Board<div>After marking all <code>'O'</code> cells connected to the boundary, iterate through the entire board:</div><ol><li>Convert all remaining <code>'O'</code> cells (which are completely surrounded) to <code>'X'</code>.</li><li>Convert all <code>'T'</code> cells (connected to the boundary) back to <code>'O'</code>.</li></ol>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def solve(self, board: List[List[str]]) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(board), len(board[0])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def capture(r, c):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r &lt; 0 or c &lt; 0 or r == ROWS or <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c == COLS or board[r][c] != ""O""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; board[r][c] = ""T""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r + 1, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r - 1, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r, c + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r, c - 1)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[r][0] == ""O"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r, 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[r][COLS - 1] == ""O"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(r, COLS - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[0][c] == ""O"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(0, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[ROWS - 1][c] == ""O"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capture(ROWS - 1, c)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(ROWS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(COLS):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if board[r][c] == ""O"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; board[r][c] = ""X""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif board[r][c] == ""T"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; board[r][c] = ""O"""	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">m</span><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-style: inherit; font-weight: inherit;""></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">m</span><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: inherit; font-weight: inherit;"">∗</span><span style=""font-style: inherit; font-weight: inherit;""></span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul>"
Plus One	Easy		start at the right keep incrementing as you go if needed.	<li>Each digit in the array corresponds to a place value in the number (e.g., <code>[1, 2, 3]</code> represents the number 123).</li><li>To increment the number:<ul><li>Start from the least significant digit (rightmost) and move leftward.</li><li>If adding one causes the digit to become 10 (carry), reset it to 0 and propagate the carry to the next more significant digit.</li><li>If a carry is still present after processing all digits, prepend a <code>1</code> to the array.</li></ul></li>	class Solution:<br>&nbsp;&nbsp;&nbsp; def plusOne(self, digits: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = len(digits)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n - 1, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if digits[i] &lt; 9:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digits[i] += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return digits<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digits[i] = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [1] + digits	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul>"
Jump Game	Medium		greedy approach	"we want to iterate in reverse from the end (second to the end) value to the beginning.<br>we want to keep track of a ""goal"" index that represents the leftmost value that we have found that can reach the end.<br>as we iterate backwards, if the current number has a high enough value that we can reach goal, then we set the new goal&nbsp;<br>equal to the current index and keep iterating in reverse. if we can't reach goal, it's possible that values further to the left can reach it<br>so we just do nothing and keep iterating left.<br>at the end, we check if goal == 0. if it does, this means that the leftmost value that can reach the end is the 0th index (i.e. the start index),<br>which means the end is reachable from the start, so we return True."	class Solution:<br>&nbsp;&nbsp;&nbsp; def canJump(self, nums: List[int]) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goal = len(nums) - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(nums) - 2, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i + nums[i] &gt;= goal:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goal = i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return goal == 0	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">1</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li></ul>"
Jump Game II	Medium		greedy	For the BFS greedy approach:<br><br><ol><li><div><strong>Initialization</strong>:</div><ul><li>Start with <code>res = 0</code> (no jumps made yet).</li><li>Set both <code>l</code> and <code>r</code> to <code>0</code>, meaning our initial position is at index <code>0</code>.</li></ul></li><li><div><strong>Main Loop (<code>while r &lt; len(nums) - 1</code>):</strong></div><ul><li>Continue looping until the right boundary <code>r</code> reaches or surpasses the last index. This means we've found a path to the end.</li></ul></li><li><div><strong>Find Farthest Reachable Index in Current Level</strong>:</div><ul><li>Initialize <code>farthest = 0</code> for each level.</li><li><strong>Iterate over the current level</strong> (<code>for i in range(l, r + 1)</code>):<ul><li>For each index <code>i</code> in the current level, calculate how far we can reach from there using <code>i + nums[i]</code>.</li><li>Update <code>farthest</code> with the maximum value of <code>i + nums[i]</code>.</li><li>This represents the farthest index we can reach in the next jump from the current level.</li></ul></li></ul></li><li><div><strong>Prepare for Next Level</strong>:</div><ul><li>After processing the current level, update the boundaries for the next level:<ul><li><code>l = r + 1</code>: The next level starts right after the current right boundary.</li><li><code>r = farthest</code>: The right boundary of the next level is the farthest index we found.</li></ul></li><li>Increment <code>res</code> because we have made another jump.</li></ul></li><li><div><strong>Return Result</strong>:</div><ul><li>Once the loop ends (when <code>r</code> reaches or exceeds <code>len(nums) - 1</code>), return <code>res</code>, the total number of jumps made.</li></ul></li></ol><h3></h3>	My first approach was:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def jump(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[-1] = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goal = len(nums) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(nums) == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(nums) - 2, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i + nums[i] &gt;= goal:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortestPathIndex = goal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(goal - i, nums[i] + 1, 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i + j &lt; len(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[i + j] &lt; nums[shortestPathIndex]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortestPathIndex = i + j<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i] = nums[shortestPathIndex] + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goal = i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i] = 101<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums[0]<br><br><br>BFS Greedy (most efficient):<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def jump(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = r = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(nums) - 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; farthest = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(l, r + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; farthest = max(farthest, i + nums[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = r + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = farthest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"my approach has:<br><ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">n^</span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">2</span></span></span></span></span></span></span></span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul><div>BFS Greedy has:<br><ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul></div>"
Gas Station	Medium		Greedy	<li><div><strong>First Check for Feasibility:</strong></div><ul><li><code>sum(gas) &lt; sum(cost)</code> ensures that there’s no point wasting time on impossible cases.</li></ul></li><li><div><strong>Simulate the Circuit:</strong></div><ul><li>The loop iterates through each station, calculating the remaining gas (<code>gas[i] - cost[i]</code>).</li><li>The variable <code>total</code> tracks the gas available as you move through the circuit starting from the current <code>res</code>.</li></ul></li><li><div><strong>Reset When Total is Negative:</strong></div><ul><li>If <code>total</code> becomes negative, it means the current starting point cannot work, so you reset the start to the next station (<code>res = i + 1</code>).</li></ul></li><li><div><strong>Return the Result:</strong></div><ul><li>At the end of the loop, if a solution exists, <code>res</code> will point to the correct starting station.</li></ul></li>	class Solution:<br>&nbsp;&nbsp;&nbsp; def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if sum(gas) &lt; sum(cost):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(gas)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total += (gas[i] - cost[i])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if total &lt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = i + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: italic; font-weight: inherit;"">n</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li><li>Space complexity:&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: italic; font-weight: inherit;"">O</span><span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit;"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></span></span></li></ul>"
Maximum Sum Circular Subarray	Medium		Kadane's Algo	"This algorithm solves the problem by looking at two possible cases for the global sum. Case 1 is where the global max is circular (crosses back to the start of the array) and case 2 is when it is non-circular.<br>- Case 1 is just the same as the maximum sum problem i.e. keep track of current sum and max sum and update as you go.<br>- Case 2 implies that there is some ""split"" in the array, meaning there is some middle segment that is not included in the two halves of the subarray correponding to global max. In order to find this split array, we do total - globalMin. By subtracting the minimum subarray sum (globalMin), we effectively exclude the ""worst"" segment (i.e., the segment that minimizes the total sum) from the array.<br>Why is globMax&nbsp;&gt; 0 Checked?<div>If globMax (the maximum non-circular subarray sum) is less than or equal to 0, all elements in the array are non-positive. In this case:</div><ul><li>The maximum circular sum would also be negative.</li><li>We should directly return globMax, as it represents the maximum subarray sum in both circular and non-circular scenarios.</li></ul>"	class Solution:<br>&nbsp;&nbsp;&nbsp; def maxSubarraySumCircular(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; globMax, globMin = nums[0], nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMax, curMin = 0, 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMax = max(curMax + num, num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMin = min(curMin + num, num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total += num<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; globMax = max(globMax, curMax)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; globMin = min(globMin, curMin)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return max(globMax, total - globMin) if globMax &gt; 0 else globMax	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span>&nbsp;extra space.</li></ul>"
Longest Turbulent Subarray	Medium		Kadane's Algorithm	Here, res variable corresponds to the globalMax variable in other similar Kadane problems. We want to use res to keep track of the longest subarrays that have this turbulent property of alternating comparison operators. The currMax variable in other problems is equivalent to the r-l+1 in this problem and is the length of the current subarray that we check against res every iteration that it gets longer.<br>The general idea in this problem is that we loop through the array elements and check that the comparison operator of the previous element and current element is the opposite of the previous operator. If it is, we increase the right side of the current window by 1. If not then we start a new window by moving the left pointer up. We also check res as we go and return that at the end.	"<div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxTurbulenceSize(self, arr: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r, res, prev = 0, 1, 1, """"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(arr):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if arr[r - 1] &gt; arr[r] and prev != ""&gt;"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, r - l + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = ""&gt;""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif arr[r - 1] &lt; arr[r] and prev != ""&lt;"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, r - l + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = ""&lt;""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = r + 1 if arr[r] == arr[r - 1] else r<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = r - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = """"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br></div></div>"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span>&nbsp;extra space.</li></ul>"
Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold	Medium		Sliding Window	We want to use the runningTotal as the property that we are maintaining in our window. We do this by adding and subtracting the elements that will be/were in our window. Each iteration we check if the runningTotal is larger than threshold and increase the count variable by 1.<br>There are various ways to construct the loop but one way is to initialize a left pointer and then use a for loop for the right pointer which starts at k-1th index. This means you have to initialize runningTotal with the sum of the first few elements.	class Solution:<br>&nbsp;&nbsp;&nbsp; def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runningTotal = sum(arr[:k-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(k - 1, len(arr)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runningTotal += arr[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if runningTotal / k &gt;= threshold:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runningTotal -= arr[l]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return count<br><br><br><br>// Alternate (probably simpler) way of looping&nbsp;<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curSum = sum(arr[:k - 1])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for L in range(len(arr) - k + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curSum += arr[L + k - 1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curSum / k) &gt;= threshold:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curSum -= arr[L]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span><span style=""font-weight: inherit; color: inherit !important;""><i>&nbsp;</i></span></span>extra space.</li></ul>"
Minimum Size Subarray Sum	Medium		Sliding window (variable)	use left and right pointers and a currentSum to maintain the sum property of the window. This means decreasing and increasing the currentSum when the window moves along the array.&nbsp;<br>We also want to make sure we are always trying to find the minimum subarray that satisfies the condition. This means if we find an array that does satisfy the condition of being larger than the target, we attempt to make the array smaller by increasing the left pointer. There would be no point in making it bigger as that would not be finding the minimum size subarray.&nbsp;<br>Else we increase the right pointer so we can satisfy the condition.	class Solution:<br>&nbsp;&nbsp;&nbsp; def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentSum = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minimumSize = float('inf')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentSum += nums[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while currentSum &gt;= target:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minimumSize = min(minimumSize, r - l + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentSum -= nums[l]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return minimumSize if minimumSize != float('inf') else 0	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span>&nbsp;extra space.</li></ul>"
Range Sum Query - Immutable	Easy		Prefix Sum	create a prefix sum data structure for nums when you initialize the object.<br>return the prefix sum for the right minus the prefix sum for the left.	class NumArray:<br>&nbsp;&nbsp;&nbsp; def __init__(self, nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.prefix = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur += num<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.prefix.append(cur)<br><br>&nbsp;&nbsp;&nbsp; def sumRange(self, left, right):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightSum = self.prefix[right]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftSum = self.prefix[left - 1] if left &gt; 0 else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return rightSum - leftSum	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span><span style=""font-weight: inherit; color: inherit !important;""><i>&nbsp;</i></span></span>for each&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">sumRange()</span><span style=""font-weight: inherit; color: inherit !important;""><i>&nbsp;</i></span></span>query,&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span>&nbsp;for building the prefix sum array.</li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul>"
Find Pivot Index	Easy		Prefix Sum	calculate total sum<br>iterate from left<br>calculate prefix sum as you go and compare to prefix sum to see when you're halfway	class Solution:<br>&nbsp;&nbsp;&nbsp; def pivotIndex(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total = sum(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftSum = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rightSum = total - nums[i] - leftSum<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if leftSum == rightSum:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftSum += nums[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul>"
Subarray Sum Equals K	Medium		Prefix Sum/Hashmap	"<div><div><div><div><div>This solution to the ""Subarray Sum Equals K"" problem uses a combination of the prefix sum technique and a hashmap for efficient computation. The idea is to keep track of the cumulative sum (<code>curSum</code>) of the array as we iterate through it. The prefix sum allows us to calculate the sum of any subarray in constant time by subtracting a previously seen cumulative sum (<code>diff</code>) from the current cumulative sum. If a subarray ending at the current index has a sum equal to <code>k</code>, the difference between <code>curSum</code> and <code>k</code> must have been encountered before in the prefix sums.</div><div>To implement this, we use a hashmap (<code>prefixSums</code>) where keys represent cumulative sums and values represent the number of times each cumulative sum has been encountered. Initially, the hashmap is set to <code>{0: 1}</code> to handle cases where a subarray starting from the beginning of the array equals <code>k</code>. As we iterate through the array, we update <code>curSum</code> by adding the current element. We then compute <code>diff = curSum - k</code>, which represents the prefix sum that would result in a subarray sum of <code>k</code>. If this <code>diff</code> exists in the hashmap, it means there are one or more subarrays ending at the current index that sum to <code>k</code>, and we increment the result counter by the count stored in the hashmap for that <code>diff</code>.</div><div>Finally, we update the hashmap with the current cumulative sum, either by incrementing its count if it already exists or initializing it to 1 if it doesn’t. This ensures that the hashmap always reflects the counts of prefix sums encountered up to the current index. By the end of the iteration, the result counter will hold the total number of subarrays whose sum equals <code>k</code>. This approach is efficient, with a time complexity of O(n)O(n)O(n) since it processes the array in a single pass, and a space complexity of O(n)O(n)O(n) for storing prefix sums in the hashmap.</div></div></div></div></div><div><div><div><div></div><div>4o</div></div></div></div>"	<div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def subarraySum(self, nums: List[int], k: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = curSum = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefixSums = { 0 : 1 }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curSum += num<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diff = curSum - k<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += prefixSums.get(diff, 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefixSums[curSum] = 1 + prefixSums.get(curSum, 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br></div></div>	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul>"
Middle of the Linked List	Easy		fast and slow pointers	Use fast and slow pointers. If the list has an odd number of nodes, the fast pointer should end up on the last node. If it has an even number of nodes, it should end up on the null terminator at the end of the list.	<div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow, fast = head, head<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while fast and fast.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = slow.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fast = fast.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return slow<br></div></div>	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span><span style=""font-weight: inherit; color: inherit !important;""><i>&nbsp;</i></span></span>extra space.</li></ul>"
Linked List Cycle II	Medium		fast and slow	Use fast and slow pointers to determine whether there is a cycle. If there is then fast and slow will equal each other at some point. If there is not, then the fast pointer will be null or fast.next will be none.<br>Then initialize a new variable slow2. Keep increasing slow and slow2 by one node until they land on the same node. The node they land on will be the cycle head.	"class Solution:<br>&nbsp;&nbsp;&nbsp; def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize slow and fast pointers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = fast = head<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # First, determine if a cycle exists using two pointers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while fast and fast.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fast = fast.next.next&nbsp; # Move fast pointer by two steps<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = slow.next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Move slow pointer by one step<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If the pointers meet, a cycle exists<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if slow == fast:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If no cycle is detected (fast pointer reaches the end), return None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not fast or not fast.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # A cycle is detected; find the start of the cycle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow2 = head<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while slow != slow2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = slow.next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Move slow pointer one step<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow2 = slow2.next&nbsp;&nbsp;&nbsp;&nbsp; # Move slow2 pointer one step<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The meeting point is the start of the cycle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return slow"	"<ul><li>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></li></ul><ul><li>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></li></ul>"
Maximum Twin Sum of a Linked List	Medium		Fast and Slow pointers&nbsp;	First, traverse the linked list using fast and slow pointers so that the slow pointer is halfway and the fast pointer is at the end.<br>Then reverse the second half of the list so that the second member of the first pair is immediately after the middle, the second member of the second pair is two after the middle and so....<br>Then traverse the linked list from the start.<br>Use a new variable that holds the max pair sum and record the max pair sum each iteration.<br>return the max pair sum.	"class Solution(object):<br>&nbsp;&nbsp;&nbsp; def pairSum(self, head):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow, fast = head, head<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maximumSum = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Get middle of the linked list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while fast and fast.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fast = fast.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = slow.next<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Reverse second half of the linked list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr, prev = slow, None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while curr:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr.next, prev, curr = prev, curr, curr.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = head<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while prev:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maximumSum = max(maximumSum, start.val + prev.val)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = prev.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = start.next<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return maximumSum"	Time Complexity: O(n)<br>Space Complexity: O(1)
Implement Trie (Prefix Tree)	Medium		Trie/Prefix Tree	Implement a TrieNode class that has two properties, children (hashmap) and endOfWord (boolean).<br>Implement the PrefixTree:<br>- initialize the root<br>- <b>insert</b>: initialize a curr pointer to the root. Iterate through the chars in the word. If the character does not exist in the children hashmap of the current node, add it to the hashmap and assign an empty node. Move the pointer to the child. At the end of the loop, set endOfWord for the node pointed at by curr equal to True.<br>- <b>search</b>: similar to insert. Initialize curr pointer. Loop through chars in the word and check if the char is in the children of the current node. If not return False. Move the pointer. At the end, return whether the final node is the end of the word.<br>- <b>startsWith</b>: Initialize curr and loop through chars in prefix word. If c is not in the children of curr return false. Move the pointer to the child. If you finish the loop, return true.	class TrieNode:<br>&nbsp;&nbsp;&nbsp; def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.children = {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.endOfWord = False<br><br>class PrefixTree:<br>&nbsp;&nbsp;&nbsp; def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.root = TrieNode()<br><br>&nbsp;&nbsp;&nbsp; def insert(self, word: str) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = self.root<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in word:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c not in cur.children:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur.children[c] = TrieNode()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = cur.children[c]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur.endOfWord = True<br><br>&nbsp;&nbsp;&nbsp; def search(self, word: str) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = self.root<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in word:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c not in cur.children:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = cur.children[c]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cur.endOfWord<br><br>&nbsp;&nbsp;&nbsp; def startsWith(self, prefix: str) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = self.root<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in prefix:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c not in cur.children:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = cur.children[c]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span><span style=""font-weight: inherit; color: inherit !important;""><i>&nbsp;</i></span></span>for each function call.</li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(t)</span></span></li></ul><div>Where n is the length of the string and t is the total number of TrieNodes created in the Trie.</div>"
Subsets I (Without Duplicates)	Medium		Backtracking	"<div><span style=""color: #608b4e;"">every item can either be included or not included</span></div><div><span style=""color: #608b4e;"">every time we make a decision to include or not include&nbsp;</span><span style=""color: rgb(96, 139, 78);"">a value, this should spawn future processes given this decision</span></div><div><span style=""color: #608b4e;"">each process needs to make its own subset array<br></span></div>"	class Solution:<br>&nbsp;&nbsp;&nbsp; def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subset = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(i):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt;= len(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(subset.copy())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subset.append(nums[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(i + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subset.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(i + 1)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n∗2n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul>"
Subsets (with Duplicates)	Medium		Backtracking	This is a very similar solution to subsets 1.<br><br><li><div><strong>Sorting the List</strong>:</div><ul><li>The input list is sorted to group duplicate numbers together. This makes it easier to identify and skip over duplicates when generating subsets.</li></ul></li><li><div><strong>Recursive Backtracking</strong>:</div><ul><li>The main logic is implemented using a helper function that explores all possible combinations of elements in the list (using a depth-first search approach).</li><li>At each step, the algorithm decides whether to include the current element in the subset or skip it.</li></ul></li><li><div><strong>Handling Duplicates</strong>:</div><ul><li>To ensure uniqueness, the algorithm skips over consecutive duplicate elements (after including or excluding the first occurrence of a duplicate group).</li><li>This prevents generating subsets that are identical.</li></ul></li><li><div><strong>Building Subsets</strong>:</div><ul><li>If the end of the list is reached, the current subset (a temporary list of chosen elements) is added to the final list of subsets.</li><li>This process ensures that all valid subsets are collected.</li></ul></li><li><div><strong>Final Output</strong>:</div><ul><li>Once all possibilities are explored, the function returns the list of unique subsets.</li></ul></li>	class Solution:<br>&nbsp;&nbsp;&nbsp; def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums.sort()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def backtrack(i, subset):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == len(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(subset[::])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subset.append(nums[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(i + 1, subset)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subset.pop()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i + 1 &lt; len(nums) and nums[i] == nums[i + 1]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(i + 1, subset)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(0, [])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n∗2n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul>"
Combinations	Medium		Backtracking	<li><div><strong>Recursive Backtracking</strong>:</div><ul><li>Use recursion to explore all possible subsets of size <code>k</code>.</li><li>At each step, decide whether to include the current number (<code>i</code>) in the combination or skip it.</li><li>Continue until you either:<ul><li>Reach a combination of size <code>k</code> (valid subset), or</li><li>Exhaust all numbers in the range.</li></ul></li></ul></li><li><div><strong>Base Cases</strong>:</div><ul><li>If the current subset has <code>k</code> elements, add it to the result.</li><li>If the current number exceeds <code>n</code>, stop exploring further.</li></ul></li><li><div><strong>Pruning</strong>:</div><ul><li>By iterating sequentially from <code>1</code> to <code>n</code>, avoid generating duplicate combinations (e.g., <code>[1, 2]</code> is the same as <code>[2, 1]</code>).</li></ul></li>	class Solution:<br>&nbsp;&nbsp;&nbsp; def combine(self, n: int, k: int) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def backtrack(i, comb):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt; n:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(comb) == k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(comb.copy())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comb.append(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(i + 1, comb)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comb.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(i + 1, comb)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(1, [])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(k∗n!/((n−k)!∗k!))</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(k∗n!/((n−k)!∗k!))</span></span>&nbsp;for the output array.</li></ul>"
Combination Sum	Medium		Backtracking	<li><div><strong>Base Cases</strong>:</div><ul><li>If <code>total == target</code>: A valid combination is found. Add it to <code>res</code> and stop exploring further along this path.</li><li>If <code>i</code> is out of bounds (<code>i &gt;= len(nums)</code>) or <code>total &gt; target</code>: Terminate this path because it's either invalid or exceeds the target.</li></ul></li><li><div><strong>Recursive Steps</strong>:</div><ul><li><strong>Include the current number</strong>:<ul><li>Add <code>nums[i]</code> to the current combination (<code>cur</code>) and update the <code>total</code>.</li><li>Recursively call <code>dfs</code> with the same index (<code>i</code>) to allow reusing the number.</li></ul></li><li><strong>Exclude the current number</strong>:<ul><li>Remove the last added number (<code>cur.pop()</code>) to backtrack.</li><li>Move to the next number (<code>i + 1</code>) and explore further.</li></ul></li></ul></li>	class Solution:<br>&nbsp;&nbsp;&nbsp; def combinationSum(self, nums: List[int], target: int) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(i, cur, total):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if total == target:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(cur.copy())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt;= len(nums) or total &gt; target:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur.append(nums[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(i, cur, total + nums[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(i + 1, cur, total)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(0, [], 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(2^t/m)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(t/m)</span></span></li></ul><div>Where t is the given target and m is the minimum value in nums</div>"
Letter Combinations of a Phone Number	Medium		Backtracking/recursion	create a hashmap that maps the digits to the letters they represent.&nbsp;<br>create the backtracking helper function.&nbsp;<br>The base case of this function is when the string is completed. One digit can represent one letter so when the length of the current string is equal to the length of the digits, then we know we have created a full combination.<br>Then, in the main body of the helper function, we loop through all the letters we could add that correspond to this digit add them to the current string.&nbsp;<br>For each of these new current string possibilities, we then recursively call the helper function with i+1 (signifying we are looking at the next digit) with this new string.<br>Finally, we check if digits is empty. If not, make the initial call to the helper function with index 0 and an empty string.	"class Solution:<br>&nbsp;&nbsp;&nbsp; def letterCombinations(self, digits: str) -&gt; List[str]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitToChar = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""2"": ""abc"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""3"": ""def"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""4"": ""ghi"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""5"": ""jkl"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""6"": ""mno"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""7"": ""qprs"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""8"": ""tuv"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""9"": ""wxyz"",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def backtrack(i, curStr):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(curStr) == len(digits):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(curStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in digitToChar[digits[i]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(i + 1, curStr + c)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if digits:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backtrack(0, """")<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n∗4^n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul>"
Flatten Array	Easy		Iterate&nbsp;		"<pre><code><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit; color: rgb(0, 168, 200);"">def</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(117, 175, 0);"">flatten_array</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">array</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">):</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">    <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">result</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(249, 38, 114);"">=</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">[]</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">    <span style=""font-style: inherit; font-weight: inherit; color: rgb(0, 168, 200);"">for</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">i</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(249, 38, 114);"">in</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">array</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">:</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">        <span style=""font-style: inherit; font-weight: inherit; color: rgb(0, 168, 200);"">if</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">isinstance</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">i</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">,</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">list</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">):</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">            <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">result</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(249, 38, 114);"">.</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">extend</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">flatten_array</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">i</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">))</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">        <span style=""font-style: inherit; font-weight: inherit; color: rgb(0, 168, 200);"">else</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">:</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">            <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">result</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(249, 38, 114);"">.</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">append</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">i</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">)</span>
</span></span><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;"">    <span style=""font-style: inherit; font-weight: inherit; color: rgb(0, 168, 200);"">return</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(17, 17, 17);"">result</span></span></span></code></pre>"	Time: O(n)<br>Space: O(n)
Merge Intervals	Medium		Intervals	<li><div><strong>Sort the Intervals</strong></div><ul><li>Sorts <code>intervals</code> by the <strong>start time</strong> to process them in increasing order.</li></ul></li><li><div><strong>Initialize <code>output</code> List</strong></div><ul><li>Start with the <strong>first interval</strong> as the initial merged result.</li></ul></li><li><div><strong>Iterate Over Each Interval</strong></div><ul><li><strong>Check for Overlapping (<code>if start &lt;= lastEnd</code>)</strong><ul><li>Merge the intervals by updating the <strong>end time</strong> of the last interval in <code>output</code>.</li></ul></li><li><strong>If No Overlap (<code>else</code>)</strong><ul><li>Append the new interval to <code>output</code>.</li></ul></li></ul></li><li><div><strong>Return the Merged List</strong></div></li>	"my solution:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not intervals:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Sort intervals based on start times<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intervals.sort()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i &lt; len(intervals):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start, end = intervals[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Merge overlapping intervals<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i + 1 &lt; len(intervals) and intervals[i + 1][0] &lt;= end:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end = max(end, intervals[i + 1][1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret.append([start, end])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret<br><br><br>a bit cleaner but same runtime:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intervals.sort(key=lambda pair: pair[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = [intervals[0]]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for start, end in intervals:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastEnd = output[-1][1]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if start &lt;= lastEnd:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output[-1][1] = max(lastEnd, end)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output.append([start, end])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(nlog⁡n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span>&nbsp;or&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span>&nbsp;depending on the sorting algorithm.</li></ul>"
Reorganize String	Medium		Max heap	"<strong>Step 1: Count Character Frequencies</strong><ul><li>Create a frequency map <code>freq</code> to count occurrences of each character.</li><li>Find the most frequent character's count (<code>maxF</code>).</li></ul><strong>Step 2: Check if Rearrangement is Possible</strong><ul><li>If any character appears more than <code>(N + 1) // 2</code> times, return <code>""""</code> (impossible to rearrange).</li></ul><strong>Step 3: Build a Max-Heap</strong><ul><li>Insert all characters into a <strong>max-heap</strong> with their frequencies (negated for Python’s min-heap behavior).</li></ul><strong>Step 4: Construct the Result String</strong><ul><li>Initialize <code>res = []</code> to store the output string.</li><li>Keep track of the <strong>previous character</strong> (<code>prev_char</code>) and its remaining count (<code>prev_count</code>).</li></ul><strong>Step 5: Process Characters from Heap</strong><ul><li><strong>While the heap is not empty:</strong><ul><li>Pop the most frequent character from the heap.</li><li>Append the character to <code>res</code>.</li><li>If the previous character (<code>prev_char</code>) still has occurrences left, push it back into the heap.</li><li>Update <code>prev_count</code> and <code>prev_char</code> with the new character.</li></ul></li></ul><strong>Step 6: Return the Final Result</strong><ul><li>Convert <code>res</code> list into a string and return it.</li></ul>"	"import heapq<br>from collections import Counter<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def reorganizeString(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Count character frequencies<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq = Counter(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxF = max(freq.values())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalF = sum(freq.values())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; others = totalF - maxF<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If it's impossible to reorganize, return an empty string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if others &lt; maxF - <span style=""color: rgb(9, 134, 88);"">1</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Create a max-heap (invert counts for min-heap behavior)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxHeap = [(-count, char) for char, count in freq.items()]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heapify(maxHeap)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Reconstruct the string by placing characters in alternating positions<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_count, prev_char = 0, ''<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while maxHeap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count, char = heapq.heappop(maxHeap)&nbsp; # Get the most frequent character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.append(char)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If there was a previously used character, push it back into the heap<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if prev_count &lt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappush(maxHeap, (prev_count, prev_char))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Decrease count (since we used this character)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_count, prev_char = count + 1, char&nbsp; # Add 1 because count is negative<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """".join(res)"	Time Complexity:<br><li>Heap Operations: O(Nlog⁡N)</li><li>String Construction: O(N)</li><li>Total: O(Nlog⁡N)<br><br><br>Final Space Complexity: O(N)<br></li>
Climbing Stairs	Easy		DP	<strong>For space optimized solution<br><br>Step 1: Initialize Base Cases</strong><ul><li>Set <code>one = 1</code> (represents the number of ways to reach the last step).</li><li>Set <code>two = 1</code> (represents the number of ways to reach the second last step).</li></ul><strong>Step 2: Iterate from <code>0</code> to <code>n-2</code></strong><ul><li>Repeat the following steps for <code>n-1</code> iterations:<ul><li>Store the value of <code>one</code> in <code>temp</code> (to keep track of previous value).</li><li>Update <code>one = one + two</code> (new number of ways is sum of previous two steps).</li><li>Update <code>two = temp</code> (shift values forward).</li></ul></li></ul><strong>Step 3: Return the Final Result</strong><ul><li>Return <code>one</code> (which now holds the total ways to reach <code>n</code> steps).</li></ul>	class Solution:<br>&nbsp;&nbsp;&nbsp; def climbStairs(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache = [-1] * n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(i):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt;= n:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i == n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cache[i] != -1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cache[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache[i] = dfs(i + 1) + dfs(i + 2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cache[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dfs(0)<br><br>-----<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def climbStairs(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n &lt;= 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [0] * (n + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[1], dp[2] = 1, 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(3, n + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i] = dp[i - 1] + dp[i - 2]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[n]<br><br>-----<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def climbStairs(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one, two = 1, 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n - 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one = one + two<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two = temp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return one	"For the first two:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><br></span></span></span></span></li></ul><div>For the last one:</div><div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
Min Cost Climbing Stairs	Easy		DP	<strong>Step 1: Start from the End and Work Backwards</strong><ul><li>Instead of solving the problem from the first step, we work <strong>backwards</strong> from the third-to-last step.</li><li>This ensures that when we compute the cost for a step, the <strong>future steps' minimum costs are already known</strong>.</li></ul><strong>Step 2: Update Each Step with the Minimum Cost to Reach the Top</strong><ul><li>For each step, we calculate the <strong>minimum cost</strong> to climb from that position by adding the <strong>cheaper</strong> of the two next possible steps.</li><li>This helps in building up the solution dynamically, avoiding redundant calculations.</li></ul><strong>Step 3: Choose the Best Starting Position</strong><ul><li>Since the climb can start from either the first or second step, the final answer is the <strong>minimum</strong> cost between the first two steps.</li></ul>	class Solution:<br>&nbsp;&nbsp;&nbsp; def minCostClimbingStairs(self, cost: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memo = [-1] * len(cost)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(i):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt;= len(cost):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if memo[i] != -1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return memo[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memo[i] = cost[i] + min(dfs(i + 1), dfs(i + 2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return memo[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return min(dfs(0), dfs(1))<br><br>------<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def minCostClimbingStairs(self, cost: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = len(cost)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [0] * (n + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(2, n + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i] = min(dp[i - 1] + cost[i - 1],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i - 2] + cost[i - 2])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[n]<br><br>-----<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def minCostClimbingStairs(self, cost: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(cost) - 3, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cost[i] += min(cost[i + 1], cost[i + 2])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return min(cost[0], cost[1])	"For the first two:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><br></span></span></span></span></li></ul><div>For the last one:</div><div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
House Robber	Medium		DP	<strong>For space optimized solution:&nbsp;<br><br>1. Define Two Variables to Track Maximum Profit</strong><ul><li><code>rob1</code>: Stores the <strong>maximum profit from two houses ago</strong> (previous to the previous house).</li><li><code>rob2</code>: Stores the <strong>maximum profit from the last house considered</strong>.</li></ul><strong>2. Iterate Through Each House</strong><div>For each house (money amount <code>num</code> in <code>nums</code>), determine whether to <strong>rob it or skip it</strong>:</div><ul><li><strong>Option 1: Rob the current house</strong><ul><li>Add <code>num</code> to <code>rob1</code> (since the previous house cannot be robbed).</li></ul></li><li><strong>Option 2: Skip the current house</strong><ul><li>Keep <code>rob2</code> as is (since we already stored the best profit from the previous house).</li></ul></li><li><strong>Take the maximum of these two options</strong> and store it in <code>temp</code>.</li><li>Update <code>rob1</code> and <code>rob2</code> for the next iteration.</li></ul><strong>3. Return the Maximum Profit</strong><div>At the end, <code>rob2</code> holds the maximum profit possible.</div>	"<pre><code><h2>Dynamic Programming (Top-Down)</h2></code></pre><pre><code><span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">class</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">Solution</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
    <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">def</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 220, 170);"">rob</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>self<span style=""font-style: inherit; font-weight: inherit;"">,</span> nums<span style=""font-style: inherit; font-weight: inherit;"">:</span> List<span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">int</span><span style=""font-style: inherit; font-weight: inherit;"">]</span><span style=""font-style: inherit; font-weight: inherit;"">)</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">-</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">&gt;</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">int</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
        memo <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">=</span> <span style=""font-style: inherit; font-weight: inherit;"">[</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">-</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">1</span><span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">*</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span>

        <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">def</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 220, 170);"">dfs</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>i<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
            <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">if</span> i <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">&gt;=</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">len</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>nums<span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">return</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">0</span>
            <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">if</span> memo<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">!=</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">-</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">1</span><span style=""font-style: inherit; font-weight: inherit;"">:</span>
                <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">return</span> memo<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span>
            memo<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">=</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(78, 201, 176);"">max</span><span style=""font-style: inherit; font-weight: inherit;"">(</span>dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span>i <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">+</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">1</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">,</span> nums<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">+</span> dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span>i <span style=""font-style: inherit; font-weight: inherit; color: rgb(220, 218, 218);"">+</span> <span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">2</span><span style=""font-style: inherit; font-weight: inherit;"">)</span><span style=""font-style: inherit; font-weight: inherit;"">)</span>
            <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">return</span> memo<span style=""font-style: inherit; font-weight: inherit;"">[</span>i<span style=""font-style: inherit; font-weight: inherit;"">]</span>
        
        <span style=""font-style: inherit; font-weight: inherit; color: rgb(86, 156, 214);"">return</span> dfs<span style=""font-style: inherit; font-weight: inherit;"">(</span><span style=""font-style: inherit; font-weight: inherit; color: rgb(181, 206, 168);"">0</span><span style=""font-style: inherit; font-weight: inherit;"">)</span></code></pre><pre><code><h2>Dynamic Programming (Bottom-Up)</h2><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def rob(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(nums) == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [0] * len(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[0] = nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[1] = max(nums[0], nums[1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(2, len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[-1]<br></div><div><br></div><div><h2>Dynamic Programming (Space Optimized)</h2></div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def rob(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob1, rob2 = 0, 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = max(num + rob1, rob2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob1 = rob2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob2 = temp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return rob2<br></div></code></pre>"	"First two:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)</span></span></span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""></span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">O</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">(</span><span style=""font-style: italic; font-weight: inherit; color: inherit !important;"">n</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">)<br></span></span></span></span></li></ul><div>Space Optimized:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
House Robber II	Medium		DP	<li><div><strong>Divide the problem into two subproblems</strong>:</div><ul><li>Find the maximum money robbed <strong>excluding the first house</strong>.</li><li>Find the maximum money robbed <strong>excluding the last house</strong>.</li><li>Since we must exclude one of them, we take the <strong>maximum of both cases</strong>.</li></ul></li><li><div><strong>Use the standard House Robber solution for each case</strong>:</div><ul><li>The standard House Robber problem can be solved using <strong>dynamic programming</strong> with two variables to track the maximum profit at each step.</li><li>At every house, decide:<ul><li><strong>Rob this house</strong> → Add the money and skip the previous house.</li><li><strong>Skip this house</strong> → Take the previously computed maximum.</li></ul></li></ul></li><li><div><strong>Compute the final result</strong>:</div><ul><li>Compare the results from the two cases and return the <strong>maximum possible amount</strong> that can be robbed.</li></ul></li>	<h2>Dynamic Programming (Bottom-Up)</h2>class Solution:<br>&nbsp;&nbsp;&nbsp; def rob(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(nums) == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return max(self.helper(nums[1:]), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.helper(nums[:-1]))<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; def helper(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(nums) == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [0] * len(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[0] = nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[1] = max(nums[0], nums[1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(2, len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[-1]<br><br><br>------<br><h2>Dynamic Programming (Space Optimized)</h2>class Solution:<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; def rob(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return max(nums[0], self.helper(nums[1:]), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.helper(nums[:-1]))<br><br>&nbsp;&nbsp;&nbsp; def helper(self, nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob1, rob2 = 0, 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newRob = max(rob1 + num, rob2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob1 = rob2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rob2 = newRob<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return rob2<br>	"<div>For bottom up:</div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul><div>For space optimized:</div><div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
Longest Palindromic Substring	Medium		DP	"Dynamic Programming:<br><li><div><strong>Divide the problem into two subproblems</strong>:</div><ul><li>Find the maximum money robbed <strong>excluding the first house</strong>.</li><li>Find the maximum money robbed <strong>excluding the last house</strong>.</li><li>Since we must exclude one of them, we take the <strong>maximum of both cases</strong>.</li></ul></li><li><div><strong>Use the standard House Robber solution for each case</strong>:</div><ul><li>The standard House Robber problem can be solved using <strong>dynamic programming</strong> with two variables to track the maximum profit at each step.</li><li>At every house, decide:<ul><li><strong>Rob this house</strong> → Add the money and skip the previous house.</li><li><strong>Skip this house</strong> → Take the previously computed maximum.</li></ul></li></ul></li><li><div><strong>Compute the final result</strong>:</div></li><ul><li>Compare the results from the two cases and return the <strong>maximum possible amount</strong> that can be robbed.</li></ul><div><br></div><div><br></div><div>Two Pointer:<br><h3><strong>1. Initialize Variables</strong></h3><ul><li><code>resIdx</code>: Stores the <strong>starting index</strong> of the longest palindrome found so far.</li><li><code>resLen</code>: Stores the <strong>length</strong> of the longest palindrome found so far.</li></ul><h3><strong>2. Expand Around Each Character as a Center</strong></h3><ul><li>We iterate through each index <code>i</code> in the string, treating <code>s[i]</code> as a possible <strong>center of a palindrome</strong>.</li><li><strong>Expand outward</strong> while the substring remains a palindrome.</li></ul><strong>Handling Two Cases for Expansion</strong><ol><li><div><strong>Odd-length palindromes</strong> (<code>""racecar""</code>)</div><ul><li>The center is a <strong>single character</strong> (<code>l = i, r = i</code>).</li><li>Expand outward (<code>l--, r++</code>) while <code>s[l] == s[r]</code>.</li></ul></li><li><div><strong>Even-length palindromes</strong> (<code>""abba""</code>)</div><ul><li>The center is <strong>between two characters</strong> (<code>l = i, r = i + 1</code>).</li><li>Expand outward (<code>l--, r++</code>) while <code>s[l] == s[r]</code>.</li></ul></li></ol><h3><strong>3.&nbsp; Update the Longest Palindrome Found</strong></h3><ul><li>If the <strong>expanded palindrome is longer</strong> than the previous one (<code>r - l + 1 &gt; resLen</code>):<ul><li>Update <code>resIdx</code> (starting position).</li><li>Update <code>resLen</code> (length of the palindrome).</li></ul></li></ul><h3><strong>4.&nbsp; Return the Longest Palindromic Substring</strong></h3><ul><li>Extract <code>s[resIdx : resIdx + resLen]</code> as the result.</li></ul><h2></h2></div>"	"<h2>Dynamic Programming</h2><div><br></div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def longestPalindrome(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resIdx, resLen = 0, 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = len(s)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [[False] * n for _ in range(n)]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n - 1, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(i, n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[i] == s[j] and (j - i &lt;= 2 or dp[i + 1][j - 1]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i][j] = True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if resLen &lt; (j - i + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resIdx = i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resLen = j - i + 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s[resIdx : resIdx + resLen]<br></div><div><br></div><div><br></div><div><h2>Two Pointers</h2></div><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def longestPalindrome(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resIdx = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resLen = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # odd length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = i, i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r - l + 1) &gt; resLen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resIdx = l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resLen = r - l + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # even length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = i, i + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r - l + 1) &gt; resLen:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resIdx = l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resLen = r - l + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s[resIdx : resIdx + resLen]<br></div>"	"<div>For DP:</div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li></ul><div>For Two Pointer:</div><ul><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;""><br><br><br></span></span></span></span></li></ul>"
Palindromic Substrings	Medium		DP	"<h3><span style=""color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;""></span></h3><h2 style=""color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"">Dynamic Programming</h2><h3><strong>1. Initialize the DP Table</strong></h3><ul><li>Create a <strong>2D boolean table <code>dp[i][j]</code></strong>, where:<ul><li><code>dp[i][j] = True</code> if the substring <code>s[i:j+1]</code> is a palindrome.</li><li><code>dp[i][j] = False</code> otherwise.</li></ul></li><li>Initialize <code>res = 0</code> to store the count of palindromic substrings.</li></ul><h3><strong>2. Iterate Over the String in Reverse Order</strong></h3><ul><li><strong>Outer loop (<code>i</code>):</strong> Traverse <strong>from right to left</strong> (<code>n-1 to 0</code>).</li><li><strong>Inner loop (<code>j</code>):</strong> Traverse <strong>from left to right</strong>, starting from <code>i</code>.</li></ul><h3><strong>3. Check If a Substring is a Palindrome</strong></h3><div>For each substring <code>s[i:j]</code>, check:</div><ol><li><strong>If the two end characters match</strong> (<code>s[i] == s[j]</code>).</li><li><strong>If the substring between them is a palindrome</strong>:<ul><li>If <code>j - i &lt;= 2</code> (substring length <strong>1, 2, or 3</strong>), it's <strong>automatically a palindrome</strong>.</li><li>Otherwise, check if <code>dp[i+1][j-1]</code> is <code>True</code> (previously computed).</li></ul></li></ol><h3><strong>4. Update DP Table and Count</strong></h3><ul><li>If <code>s[i:j]</code> is a palindrome, set <code>dp[i][j] = True</code> and increment <code>res</code>.</li></ul><h3><strong>5. Return Total Count of Palindromic Substrings</strong></h3><ul><li><code>res</code> contains the total count of palindromic substrings.</li></ul><div><h2>Two Pointers&nbsp;(Optimal)</h2></div><div><h3><strong>1. Iterate Through Each Character as a Center</strong></h3><ul><li>We loop through each character in <code>s</code> (<code>i</code> from <code>0</code> to <code>len(s) - 1</code>).</li><li>Each character can be the <strong>center of a palindrome</strong>.</li></ul><h3><strong>2. Expand Around Each Center</strong></h3><div>For each character at index <code>i</code>, we call <code>countPali(s, l, r)</code> twice:</div><ol><li><div><strong>Odd-length palindromes</strong> (<code>""racecar""</code>)</div><ul><li>The center is a <strong>single character</strong> (<code>l = i, r = i</code>).</li><li>Expand outward while <code>s[l] == s[r]</code>.</li></ul></li><li><div><strong>Even-length palindromes</strong> (<code>""abba""</code>)</div><ul><li>The center is <strong>between two characters</strong> (<code>l = i, r = i + 1</code>).</li><li>Expand outward while <code>s[l] == s[r]</code>.</li></ul></li></ol><h3><strong>3. Count Valid Palindromic Substrings</strong></h3><ul><li>Every time a palindrome is found, increment the count (<code>res</code>).</li><li>The function <code>countPali()</code> returns the <strong>number of palindromic substrings found from the given center</strong>.</li></ul><h3><strong>4️⃣ Return Total Count</strong></h3><ul><li>The total number of palindromic substrings is stored in <code>res</code> and returned.</li></ul></div><div><br></div>"	"<h2>Dynamic Programming</h2>class Solution:<br>&nbsp;&nbsp;&nbsp; def countSubstrings(self, s: str) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, res = len(s), 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = [[False] * n for _ in range(n)]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n - 1, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(i, n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[i] == s[j] and (j - i &lt;= 2 or dp[i + 1][j - 1]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i][j] = True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br><br><h2>Two Pointers&nbsp;<span style=""font-size: 20px;"">(Optimal)</span></h2><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def countSubstrings(self, s: str) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += self.countPali(s, i, i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += self.countPali(s, i, i + 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br><br>&nbsp;&nbsp;&nbsp; def countPali(self, s, l, r):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br></div>"	"Dynamic Programming:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li></ul><div>For Two Pointers Optimal:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n^2)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
Maximum Product Subarray	Medium		DP/Kadane's	"Kadane's:<br><div>Since multiplication behaves <strong>differently</strong> from addition (due to <strong>negative numbers and zeros</strong>), the approach needs to handle:</div><ol><li><strong>Positive numbers</strong> (which increase the product)</li><li><strong>Negative numbers</strong> (which can flip the sign)</li><li><strong>Zeros</strong> (which reset the product)</li></ol><h3><strong>1️⃣ Initialize Variables</strong></h3><ul><li><code>res = nums[0]</code> → Stores the <strong>maximum product found so far</strong>.</li><li><code>curMin, curMax = 1, 1</code> → Keep track of:<ul><li><code>curMax</code> → The <strong>maximum product subarray ending at the current index</strong>.</li><li><code>curMin</code> → The <strong>minimum product subarray ending at the current index</strong> (important for handling negatives).</li></ul></li></ul><h3><strong>2️⃣ Iterate Through Each Number in <code>nums</code></strong></h3><div>For each <code>num</code> in <code>nums</code>:</div><ol><li><div><strong>Store the previous <code>curMax</code></strong> (<code>tmp = curMax * num</code>).</div></li><li><div><strong>Update <code>curMax</code></strong> → The <strong>maximum possible product at this step</strong>:</div><pre><div><div>ini</div><div><div><div>CopyEdit</div></div></div><div><code>curMax = max(num * curMax, num * curMin, num)
</code></div></div></pre><ul><li>This considers:<ul><li><code>num * curMax</code>: Extending the positive subarray.</li><li><code>num * curMin</code>: Handling negative numbers that flip signs.</li><li><code>num</code>: Starting fresh if needed.</li></ul></li></ul></li><li><div><strong>Update <code>curMin</code></strong> → The <strong>minimum possible product at this step</strong>:</div><pre><div><div>ini</div><div><div><div>CopyEdit</div></div></div><div><code>curMin = min(tmp, num * curMin, num)
</code></div></div></pre><ul><li>This helps track negative products that may become positive in future steps.</li></ul></li><li><div><strong>Update <code>res</code></strong> to store the <strong>maximum product found so far</strong>:</div><pre><div><div>ini</div><div><div><div>CopyEdit</div></div></div><div><code>res = max(res, curMax)
</code></div></div></pre></li></ol><h3><strong>3️⃣ Return <code>res</code></strong></h3><ul><li>The variable <code>res</code> will contain the <strong>maximum product of any subarray</strong>.</li></ul><div><h2>Prefix &amp; Suffix</h2></div><div><div>Unlike the <strong>Kadane’s approach</strong> (which tracks <code>curMax</code> and <code>curMin</code>), this method leverages <strong>prefix and suffix products</strong> to avoid issues with negative numbers.</div><h3><strong>1️⃣ Initialize Variables</strong></h3><ul><li><code>res = nums[0]</code> → Stores the <strong>maximum product found so far</strong>.</li><li><code>prefix = 0</code> → Stores the product of numbers <strong>from the start to the current index</strong>.</li><li><code>suffix = 0</code> → Stores the product of numbers <strong>from the end to the current index</strong>.</li></ul><h3><strong>2️⃣ Iterate Over the Array Twice in One Pass</strong></h3><strong>Pass 1: Compute Prefix Products</strong><ul><li>Iterate from <strong>left to right</strong> (<code>0 → n-1</code>).</li><li>Multiply <code>prefix</code> by the current number.</li><li>If <code>prefix == 0</code>, reset to <code>1</code> (since multiplying by <code>0</code> ruins a product).</li><li>Track the <strong>maximum product seen so far</strong> (<code>res = max(res, prefix)</code>).</li></ul><strong>Pass 2: Compute Suffix Products Simultaneously</strong><ul><li>Iterate <strong>backward</strong> (<code>n-1 → 0</code>).</li><li>Multiply <code>suffix</code> by the current number.</li><li>If <code>suffix == 0</code>, reset to <code>1</code>.</li><li>Again, track the <strong>maximum product seen so far</strong> (<code>res = max(res, suffix)</code>).</li></ul></div>"	<h2>Kadane's Algorithm</h2>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxProduct(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMin, curMax = 1, 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = curMax * num<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMax = max(num * curMax, num * curMin, num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curMin = min(tmp, num * curMin, num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, curMax)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br><br><h2>Prefix &amp; Suffix</h2><div>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxProduct(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, res = len(nums), nums[0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefix = suffix = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefix = nums[i] * (prefix or 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suffix = nums[n - 1 - i] * (suffix or 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = max(res, max(prefix, suffix))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res<br></div>	"<div>For Kadane's:</div><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul><div>For Prefix and Suffix:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(1)</span></span></li></ul></div>"
Merge Sorted Array	Easy		3 pointer	"<div>Approach 2 already demonstrates the best possible time complexity,<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>+<span style=""font-style: italic;"">m</span>)</span>, but still uses additional space. This is because the elements of array<code>nums1</code>have to be stored somewhere so that they aren't overwritten.</div><div>So, what if instead we start to overwrite<code>nums1</code>from the end, where there is no information yet?</div><div>The algorithm is similar to before, except this time we set<code>p1</code>to point at index<code>m - 1</code>of<code>nums1</code>,<code>p2</code>to point at index<code>n - 1</code>of<code>nums2</code>, and<code>p</code>to point at index<code>m + n - 1</code>of<code>nums1</code>. This way, it is guaranteed that once we start overwriting the first<code>m</code>values in<code>nums1</code>, we will have already written each into its new position. In this way, we can eliminate the additional space.</div><blockquote><div><strong>Interview Tip</strong>: Whenever you're trying to solve an array problem in place, always consider the possibility of iterating backwards instead of forwards through the array. It can completely change the problem, and make it a lot easier.</div></blockquote><div><img alt=""compute"" src=""88_end.png""></div><br>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do not return anything, modify nums1 in-place instead.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """"""<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set p1 and p2 to point to the end of their respective arrays.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1 = m - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p2 = n - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # And move p backward through the array, each time writing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the largest value pointed at by p1 or p2.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for p in range(n + m - 1, -1, -1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if p2 &lt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if p1 &gt;= 0 and nums1[p1] &gt; nums2[p2]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums1[p] = nums1[p1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1 -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums1[p] = nums2[p2]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p2 -= 1"	"<div><strong>Complexity Analysis</strong></div><ul><li><div>Time complexity:<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>+<span style=""font-style: italic;"">m</span>)</span>.</div><div>Same as Approach 2.</div></li><li><div>Space complexity:<span style=""color: rgba(38, 38, 38, 0.75);"">O(1)</span>.</div><div>Unlike Approach 2, we're not using an extra array.</div></li></ul>"
Minimum Window Substring	Hard		Sliding Window	"<h3><strong>Step 1: Setup</strong></h3><ul><li><strong>Count the frequency</strong> of characters in <code>t</code> using a hash table (<code>freq</code>).</li><li><strong>Use a sliding window</strong> (<code>l</code> and <code>r</code> pointers) to track a valid substring in <code>s</code>.</li><li><strong>Track how many characters in <code>t</code> are fully matched</strong> in the window (<code>have == required</code>).</li></ul><h3><strong>Step 2: Expand the Window (<code>r</code> pointer moves right)</strong></h3><ul><li>Add characters to the window.</li><li>If a character helps complete a match (i.e., its count in the window reaches the required count in <code>t</code>), update <code>have</code>.</li></ul><h3><strong>Step 3: Shrink the Window (<code>l</code> pointer moves right)</strong></h3><ul><li>If all characters from <code>t</code> are in the current window (<code>have == required</code>), try <strong>shrinking</strong> the window to get the <strong>smallest</strong> valid substring.</li><li>Move <code>l</code> forward and update the frequency counts.</li></ul><h3><strong>Step 4: Track the Minimum Window</strong></h3><ul><li>Every time a valid window is found (<code>have == required</code>), compare it with the smallest one found so far.</li><li>Store the new smallest substring if it's shorter than the previous one.</li></ul><h3><strong>Step 5: Return the Smallest Valid Substring</strong></h3><ul><li>If a valid window was found, return it.</li><li>Otherwise, return <code>""""</code> if no valid substring exists.</li></ul>"	"from collections import Counter<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def minWindow(self, s: str, t: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not t or not s:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Frequency dictionary of t<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq = Counter(t)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required = len(freq)&nbsp; # Unique characters to match<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have = 0&nbsp; # Number of chars matched correctly<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window_counts = {}&nbsp; # Track window character counts<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res, res_len = """", float(""inf"")<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 0&nbsp; # Left pointer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(len(s)):&nbsp; # Right pointer expanding window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char = s[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if char in freq:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window_counts[char] = window_counts.get(char, 0) + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if window_counts[char] == freq[char]:&nbsp; # Exact match of char in window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Try to shrink window when we have all characters<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while have == required:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Update result if smaller window is found<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r - l + 1) &lt; res_len:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = s[l:r + 1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res_len = r - l + 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Shrink from left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[l] in freq:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window_counts[s[l]] -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if window_counts[s[l]] &lt; freq[s[l]]:&nbsp; # Lost a required character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1&nbsp; # Move left pointer forward<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res"	"<ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(m)</span></span></li></ul><div>Where&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">n</span>&nbsp;is the length of the string&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">s</span>&nbsp;and&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">m</span>&nbsp;is the total number of unique characters in the strings&nbsp;<span style=""font-style: inherit; font-weight: inherit;"">t</span>&nbsp;and&nbsp;<span style=""font-style: inherit; font-weight: inherit;""><span style=""font-style: inherit; font-weight: inherit;""><span style=""font-weight: inherit;"">s</span></span></span>.<br></div>"
Sliding Window Maximum	Hard		Sliding Window	can use heap or deque.<br>Queue solution is optimal.<br>It relies on the fact that for every number that appears in the window, all smaller numbers before it are essentially irrelevant because as the window moves forward, these smaller numbers will never be as big as the bigger number, and so they will never be added to the output array in the future. And the same is true for that big number as we continue to move the window right. This means that we need a deque (which will be monotonically decreasing for the reason described). Each time we move the window forward, we pop all numbers from the queue that are smaller than the new number. We also have to remember to pop the number that is no longer in the window because we moved it forward. Since the queue is monotonically decreasing, the number on the left end of the queue will be the number we append to the result array.<br>	"Max Heap:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heap = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappush(heap, (-nums[i], i))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i &gt;= k - 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while heap[0][1] &lt;= i - k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heapq.heappop(heap)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output.append(-heap[0][0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output<br><br>Deque:<br><br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = deque()&nbsp; # index<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = r = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while r &lt; len(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while q and nums[q[-1]] &lt; nums[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.append(r)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if l &gt; q[0]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.popleft()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r + 1) &gt;= k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output.append(nums[q[0]])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output"	"Heap:<br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(nlog⁡n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul><div><i>Deque:<br></i><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n)</span></span></li></ul></div>"
Largest Number	Medium		Use custom sorting	Convert each integer to a string<br>Sort strings based on concatenated values<br>Handle the case where the largest number is zero<br>Concatenate sorted strings to form the largest number	"class Solution:<br>&nbsp;&nbsp;&nbsp; def largestNumber(self, nums: List[int]) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Convert each integer to a string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_strings = [str(num) for num in nums]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Sort strings based on concatenated values<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_strings.sort(key=lambda a: a * 10, reverse=True)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Handle the case where the largest number is zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if num_strings[0] == ""0"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ""0""<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Concatenate sorted strings to form the largest number<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """".join(num_strings)"	Time Complexity:O(nlogn)<br>Space Complexity:O(n+S)<br>Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array.
Sort an Array (Selection Sort)	Medium	Sort		"# Outer loop iterates over each element in the array<br># Start by assuming the current index is the minimum<br># Find the smallest element in the unsorted portion<br># If the current index of the array has a smaller value than the current minimum, update index of the smallest element<br># Swap the smallest element found with the first unsorted element"	class Solution:<br>&nbsp;&nbsp;&nbsp; def sortArray(self, nums: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = len(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = i&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(i + 1, n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[j] &lt; nums[m]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = j&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i], nums[m] = nums[m], nums[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums	Best Case Runtime: O(N^2)<br>Average Case Runtime: O(N^2)<br>Worst Case Runtime: O(N^2)<br>Space Complexity: O(1)<br>Stable? No
Sort an Array (Quick Sort)	Medium	Sort		"<ol style=""box-sizing: border-box; margin: 0px 0px 24px; padding: 0px; border: 0px; vertical-align: baseline; list-style-position: outside; list-style-image: initial; letter-spacing: 0.162px;""><li style=""box-sizing: border-box; margin: 0px 0px 0px 24px; padding: 0px; border: 0px; vertical-align: baseline; text-align: left; line-height: 1.58;"" value=""1"">Choose a Pivot:&nbsp;<span style=""box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;"">Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).</span></li><li style=""box-sizing: border-box; margin: 0px 0px 0px 24px; padding: 0px; border: 0px; vertical-align: baseline; text-align: left; line-height: 1.58;"" value=""2"">Partition the Array:<span style=""box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;"">&nbsp;Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.</span></li><li style=""box-sizing: border-box; margin: 0px 0px 0px 24px; padding: 0px; border: 0px; vertical-align: baseline; text-align: left; line-height: 1.58;"" value=""3"">Recursively Call:<span style=""box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;"">&nbsp;Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).</span></li><li style=""box-sizing: border-box; margin: 0px 0px 0px 24px; padding: 0px; border: 0px; vertical-align: baseline; text-align: left; line-height: 1.58;"" value=""4"">Base Case:<span style=""box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;"">&nbsp;The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.</span></li></ol>"	from typing import List<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def sortArray(self, nums: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def partition(nums, low, high):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pivot = nums[high]&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = low - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j in range(low, high):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[j] &lt; pivot:&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i], nums[j] = nums[j], nums[i]&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i + 1], nums[high] = nums[high], nums[i + 1]&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i + 1&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def quicksort(nums, low, high):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if low &lt; high:&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pi = partition(nums, low, high)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quicksort(nums, low, pi - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quicksort(nums, pi + 1, high)&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quicksort(nums, 0, len(nums) - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums	Best Case Runtime: O(nlog(n))<br>Average Case Runtime: O(nlog(n))<br>Worst Case Runtime:O(n^2)<br>Space Complexity: O(log(n))
Sort an Array (Merge Sort)	Medium		sort	"<ol><li><div>Create a helper function called&nbsp;<code>merge</code>&nbsp;which takes in the original array&nbsp;<code>arr</code>, indices&nbsp;<code>left</code>,&nbsp;<code>mid</code>,&nbsp;<code>right</code>, and a temporary array&nbsp;<code>tempArr</code>&nbsp;as parameters.</div><ul><li>Calculate the start indices and sizes of the two halves of the array. The first half starts from the&nbsp;<code>left</code>&nbsp;index and the second half starts from&nbsp;<code>mid+1</code>.</li><li>Copy elements of both halves into the temporary array.</li><li>Merge the sub-arrays from the temporary array&nbsp;<code>tempArr</code>&nbsp;back into the original array&nbsp;<code>arr</code>&nbsp;in a sorted order using a while loop. The loop runs until either the first half or second half is completely merged. In each iteration, the smaller of the two elements from the first and second half is copied into the original array ""arr"".</li><li>Copy any remaining elements from the first half or second half into the original array.</li></ul></li><li><div>Create a recursive function called&nbsp;<code>mergeSort</code>&nbsp;which takes in the original array&nbsp;<code>arr</code>, indices&nbsp;<code>left</code>,&nbsp;<code>right</code>, and a temporary array&nbsp;<code>tempArr</code>&nbsp;as parameters.</div><ul><li>Check if the&nbsp;<code>left</code>&nbsp;index is greater than or equal to the&nbsp;<code>right</code>&nbsp;index. If it is, we return from the function.</li><li>Calculate the&nbsp;<code>mid</code>&nbsp;index.</li><li>Sort the first and second halves of the array recursively by calling the&nbsp;<code>mergeSort</code>&nbsp;function.</li><li>Merge the sorted halves by calling the&nbsp;<code>merge</code>&nbsp;function.</li></ul></li><li><div>Create a temporary array&nbsp;<code>temporaryArray</code>&nbsp;with the same size as the&nbsp;<code>nums</code>&nbsp;array.</div></li><li><div>Call the&nbsp;<code>mergeSort</code>&nbsp;function on the&nbsp;<code>nums</code>&nbsp;array with boundary,&nbsp;<code>0</code>, and&nbsp;<code>nums.size()-1</code>.</div></li><li><div>Return the sorted array&nbsp;<code>nums</code>.</div></li></ol>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def sortArray(self, nums: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_arr = [0] * len(nums)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Function to merge two sub-arrays in sorted order.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def merge(left: int, mid: int, right: int):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Calculate the start and sizes of two halves.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start1 = left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start2 = mid + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n1 = mid - left + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n2 = right - mid<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Copy elements of both halves into a temporary array.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_arr[start1 + i] = nums[start1 + i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(n2):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_arr[start2 + i] = nums[start2 + i]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Merge the sub-arrays 'in tempArray' back into the original array 'arr' in sorted order.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k = 0, 0, left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i &lt; n1 and j &lt; n2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if temp_arr[start1 + i] &lt;= temp_arr[start2 + j]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[k] = temp_arr[start1 + i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[k] = temp_arr[start2 + j]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Copy remaining elements<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i &lt; n1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[k] = temp_arr[start1 + i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while j &lt; n2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[k] = temp_arr[start2 + j]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Recursive function to sort an array using merge sort<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def merge_sort(left: int, right: int):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if left &gt;= right:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (left + right) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Sort first and second halves recursively.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; merge_sort(left, mid)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; merge_sort(mid + 1, right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Merge the sorted halves.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; merge(left, mid, right)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; merge_sort(0, len(nums) - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nums"	"<div>Here,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the number of elements in the&nbsp;<code>nums</code>&nbsp;array.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>log<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We divide the&nbsp;<code>nums</code>&nbsp;array into two halves till there is only one element in the array, which will lead to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">n</span>)</span>&nbsp;steps.<br><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span>→<span style=""font-style: italic;"">n</span>/2→<span style=""font-style: italic;"">n</span>/4→...→1&nbsp;(k&nbsp;steps)</span><br><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span>/2(<span style=""font-style: italic;"">k</span>−1)=1⟹</span>&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>≈log<span style=""font-style: italic;"">n</span></span></li><li>And after each division, we merge those respective halves which will take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time each.</li><li>Thus, overall it takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>log<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>The recursive stack will take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">n</span>)</span>&nbsp;space and we used an additional array&nbsp;<code>temporaryArray</code>&nbsp;of size&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>.</li><li>Thus, overall we use&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">n</span>+<span style=""font-style: italic;"">n</span>)=<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;space.</li></ul></li></ul>"
Minimum Swaps to Group All 1's Together	Medium		Sliding Window	<ul><li>Count the total number of ones in&nbsp;<code>data</code>&nbsp;which determines the required window size for grouping ones together.</li><li>Initialize&nbsp;<code>cnt_one</code>&nbsp;to track the count of ones in the current window and&nbsp;<code>max_one</code>&nbsp;to store the maximum number of ones found in any valid window.</li><li>Use two pointers,&nbsp;<code>left</code>&nbsp;and&nbsp;<code>right</code>, to define a sliding window.</li><li>Iterate over&nbsp;<code>data</code>&nbsp;with&nbsp;<code>right</code>, adding each element to&nbsp;<code>cnt_one</code>&nbsp;to keep track of the number of ones in the current window.</li><li>If the window size exceeds&nbsp;<code>ones</code>, shrink the window by removing the leftmost element and updating&nbsp;<code>cnt_one</code>&nbsp;accordingly.</li><li>Update&nbsp;<code>max_one</code>&nbsp;with the maximum number of ones found in any valid window.</li><li>Compute the minimum swaps needed as&nbsp;<code>ones - max_one</code>, representing the number of zeros that need to be swapped to group all ones together.</li><li>Return the computed minimum swaps.</li></ul>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def minSwaps(self, data: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ones = sum(data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt_one = max_one = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = right = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while right &lt; len(data):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # updating the number of 1's by adding the new element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt_one += data[right]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # maintain the length of the window to ones<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if right - left &gt; ones:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # updating the number of 1's by removing the oldest element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt_one -= data[left]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # record the maximum number of 1's in the window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_one = max(max_one, cnt_one)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ones - max_one"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;be the size of the input array&nbsp;<code>data</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><div>The algorithm iterates through the array once using a sliding window approach. The&nbsp;<code>while</code>&nbsp;loop runs until the&nbsp;<code>right</code>&nbsp;pointer reaches the end of the array, which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time. Inside the loop, the operations (updating&nbsp;<code>cnt_one</code>, checking the window size, and updating&nbsp;<code>max_one</code>) are all constant time operations,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. The initial sum calculation also takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time. Therefore, the overall time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></div><div>The algorithm uses a constant amount of extra space. The variables&nbsp;<code>ones</code>,&nbsp;<code>cnt_one</code>,&nbsp;<code>max_one</code>,&nbsp;<code>left</code>, and&nbsp;<code>right</code>&nbsp;are all integers and do not depend on the input size. No additional data structures are used that scale with the input size. Therefore, the space complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>.</div></li></ul>"
Merge Operations to Turn Array Into a Palindrome	Medium		Greedy/Two Pointer	<ol><li>Use two pointers:<br>l starts from the left (0),<br>r starts from the right (len(nums) - 1).</li><li>Compare nums[l] and nums[r]:</li></ol><ul><li>If nums[l] &lt; nums[r]: Merge nums[l] with nums[l+1], move l right.</li><li>If nums[l] &gt; nums[r]: Merge nums[r] with nums[r-1], move r left.</li><li>If they are equal, just move both pointers inward (l += 1, r -= 1).</li></ul><ol><li>Keep track of the number of merge operations in res.</li><li>Stop when l crosses r.</li></ol>	class Solution:<br>&nbsp;&nbsp;&nbsp; def minimumOperations(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(nums) - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt;= r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[l] &lt; nums[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[l + 1] += nums[l]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif nums[l] &gt; nums[r]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[r - 1] += nums[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res	<ul><li><div>Time complexity: O(n)<br>Each element is processed at most once.</div></li><li><div>Space complexity: O(1)<br>Only a few variables used, and no additional data structures required.</div></li></ul>
Maximum Number of Vowels in a Substring of Given Length	Medium		Sliding Window	"Algorithm<ol><li><div>Build a hash set&nbsp;<code>vowels</code>&nbsp;that contains all 5 vowel letters, initialize&nbsp;<code>answer</code>&nbsp;as 0.</div></li><li><div>Record the number of vowel letters in the first&nbsp;<code>k</code>&nbsp;letters as&nbsp;<code>count</code>.</div></li><li><div>Now we move the ""window"" to the right, let&nbsp;<code>i</code>&nbsp;be the index of its right boundary:</div><ul><li>If&nbsp;<code>s[i]</code>&nbsp;is in&nbsp;<code>vowels</code>, increment&nbsp;<code>count</code>&nbsp;by&nbsp;<code>1.</code></li><li>If&nbsp;<code>s[i - k]</code>&nbsp;is in&nbsp;<code>vowels</code>, reduce&nbsp;<code>count</code>&nbsp;by&nbsp;<code>1.</code></li><li>Update&nbsp;<code>answer</code>&nbsp;as the maximum&nbsp;<code>count</code>&nbsp;we have encountered.</li></ul></li><li><div>Return&nbsp;<code>answer</code>&nbsp;after the iteration ends.</div></li></ol>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def maxVowels(self, s: str, k: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vowels = {'a', 'e', 'i', 'o', 'u'}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Build the window of size k, count the number of vowels it contains.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(k):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += int(s[i] in vowels)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer = count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Slide the window to the right, focus on the added character and the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # removed character and update ""count"". Record the largest ""count"".<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(k, len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += int(s[i] in vowels)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count -= int(s[i - k] in vowels)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer = max(answer, count)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return answer"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;be the length of the input string&nbsp;<code>s</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We apply 1 iteration over&nbsp;<code>s</code>.</li><li>At each step in the iteration, we check if the newly added character and the removed character are in&nbsp;<code>vowels</code>, which takes constant time.</li><li>To sum up, the time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></div><ul><li>We need to record several parameters,&nbsp;<code>count</code>&nbsp;and&nbsp;<code>answer</code>, which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;space.</li><li>The set&nbsp;<code>vowels</code>&nbsp;contains 5 vowel letters which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;space.</li></ul></li></ul>"
Max Number of K-Sum Pairs	Medium		Two Pointer / HashMap	"<div><strong>Two Pointer Algorithm</strong></div><ul><li><div>Sort the&nbsp;<code>nums</code>&nbsp;array in increasing i.e ascending order. We can use the built-in sort function.</div></li><li><div>Initialize the&nbsp;<code>left</code>&nbsp;pointer to point at the&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">0<span style=""font-style: italic;"">t</span><span style=""font-style: italic;"">h</span></span>&nbsp;index and the&nbsp;<code>right</code>&nbsp;pointer to point to the last index of the&nbsp;<code>nums</code>&nbsp;array. We could say that the&nbsp;<code>left</code>&nbsp;pointer points to the smallest element in the array, and the&nbsp;<code>right</code>&nbsp;points to the largest element.</div></li><li><div>Add the values of array elements pointed by&nbsp;<code>left</code>&nbsp;and&nbsp;<code>right</code>&nbsp;pointer given by&nbsp;<code>sum</code>.</div><ul><li>If the value of&nbsp;<code>sum</code>&nbsp;is less than&nbsp;<code>k</code>, increment&nbsp;<code>left</code>&nbsp;pointer.</li><li>If the value of&nbsp;<code>sum</code>&nbsp;is greater than&nbsp;<code>k</code>, increment the&nbsp;<code>right</code>&nbsp;pointer.</li><li>Otherwise, we have found one pair with a sum equal to&nbsp;<code>k</code>. Increment&nbsp;<code>left</code>&nbsp;pointer and decrement&nbsp;<code>right</code>&nbsp;pointer so that we can go ahead and find another pair.</li></ul></li><li><div>The process would continue until the&nbsp;<code>left</code>&nbsp;pointer is less than the&nbsp;<code>right</code>&nbsp;pointer. Once the&nbsp;<code>left</code>&nbsp;and&nbsp;<code>right</code>&nbsp;pointer cross each other, we know that we have traversed all the elements and cannot find any other pair. Hence, we stop at that point.<br></div></li></ul><div>HashMap&nbsp;<strong>Algorithm</strong></div><ul><li><div>Build a hashmap&nbsp;<code>map</code>&nbsp;where the key is the value of elements in the array and value is the count of the number of times that value is present in the array.</div></li><li><div>Iterate over every element in the array&nbsp;<code>nums</code>. Let&nbsp;<code>current</code>&nbsp;be the element currently being traversed. Find the complement of the current element with respect to&nbsp;<code>k</code>,&nbsp;<code>complement</code>&nbsp;=&nbsp;<code>current - k</code>. The&nbsp;<code>complement</code>&nbsp;is a pair of&nbsp;<code>current</code>&nbsp;element that we are trying to find.</div></li><li><div>However, it is possible that the&nbsp;<code>current</code>&nbsp;element is also taken before and paired with some other element. Hence, we check if both elements of the pair,&nbsp;<code>current</code>&nbsp;and&nbsp;<code>complement</code>&nbsp;are present in the map. If yes, we form the pair and remove those elements from the map.</div></li></ul><blockquote><div>Instead of removing the elements from the map, we could simply decrement its count by&nbsp;<span style=""color: rgba(60, 60, 67, 0.6) !important;""><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""color: rgba(60, 60, 67, 0.6) !important;"">1</span></span></span>. An element with a count of&nbsp;<span style=""color: rgba(60, 60, 67, 0.6) !important;""><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""color: rgba(60, 60, 67, 0.6) !important;"">0</span></span></span>&nbsp;is as good as being non-existent in the map.</div></blockquote><blockquote><div>Is there any other case where our algorithm may fail?</div></blockquote><ul><li><div>If the value of the&nbsp;<code>current</code>&nbsp;element and&nbsp;<code>complement</code>&nbsp;element is the same, we need at least&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">2</span>&nbsp;occurrences of that element to be present in the array, otherwise, we cannot form a pair.</div><div>For example, if&nbsp;<code>k = 6</code>&nbsp;and the value of the&nbsp;<code>current</code>&nbsp;element is&nbsp;<code>3</code>, the complement must be&nbsp;<code>3</code>&nbsp;as well. In this case, there must be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">2</span>&nbsp;elements in the array with the value&nbsp;<code>3</code>&nbsp;to form a pair.</div></li><li><div>Every time we find a suitable pair of 2 elements with sum equal to&nbsp;<code>k</code>, increment the variable&nbsp;<code>count</code>. At the end, return the total number of pairs,&nbsp;<code>count</code>&nbsp;found in the array.</div></li></ul>"	"Two Pointer:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def maxOperations(self, nums: List[int], k: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums.sort()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l, r = 0, len(nums) - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while l &lt; r:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair_sum = nums[l] + nums[r]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if pair_sum == k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif pair_sum &lt; k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret<br><br><br>HashMap:<br><br>count_map = defaultdict(int)<br>&nbsp;&nbsp;&nbsp; count = 0<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; # Build the hashmap with count of occurrences of every element in array<br>&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count_map[num] += 1<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for num in nums:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complement = k - num<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if count_map[num] &gt; 0 and count_map[complement] &gt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if num == complement and count_map[num] &lt; 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count_map[num] -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count_map[complement] -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return count"	"Two Pointer:<br><br><strong>Time Complexity: O(nlog⁡n)</strong><ul>
<li>The <strong>sorting operation</strong> (<code>nums.sort()</code>) takes <strong>O(nlog⁡n)</strong>&nbsp;time.</li>
<li>The <strong>two-pointer traversal</strong> processes each element <strong>at most once</strong>, leading to an <strong>O(n)</strong>&nbsp;complexity.</li>
<li>Combining both, the total time complexity is:
O(nlog⁡n)+O(n)=O(nlog⁡n)</li>
</ul>
<strong>Space Complexity: O(1)O(1)O(1) or O(n)O(n)O(n)</strong>
<ul>
<li><strong>Best Case:</strong> Python’s <code>sort()</code> function is implemented using <strong>Timsort</strong>, which has an <strong>average space complexity of O(1)</strong>&nbsp;for in-place sorting.</li>
<li><strong>Worst Case:</strong> Timsort <strong>allocates O(n) additional space</strong> in cases where a merge is required.</li>
<li>Thus, the space complexity varies between <strong>O(1) and O(n)</strong>&nbsp;depending on the input.</li></ul><br>HashMap:<br><br><ul><li><div>Time Complexity :&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>)</span>, where&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the length of array&nbsp;<code>nums</code>. We iterate over an element in the array twice which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time. First, to build a map from the array. Second, to find a pair for every element in the array. Also, to add or update an element in a hashmap takes constant time. This gives us total time complexity as&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>)</span>.</div></li><li><div>Space Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(<span style=""font-style: italic;"">n</span>)</span>, where&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the length of array&nbsp;<code>nums</code>. We use an unordered map to store the values of the array with their count of occurrence. In the worst case, if every element in the array is unique, the maximum size of the map would grow up to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>.</div></li></ul>"
Max Consecutive Ones III	Medium		Sliding Window	"<div><div><span style=""color: #008000;""># start a sliding window from the left. move the right pointer right so long as you</span></div><div> <span style=""color: #008000;""># have less than or equal k 0s in the window and the rest are 1s. if you exceed </span></div><div> <span style=""color: #008000;""># k 0s in the window, move the left pointer to the right until you eliminate a zero</span></div><div> <span style=""color: #008000;""># from the window.</span></div><div> <span style=""color: #008000;""># we can keep a variable called kRemaining to keep track of how many zeroes we have</span></div><div> <span style=""color: #008000;""># in the window.</span></div></div>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def longestOnes(self, nums: List[int], k: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxLength = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r in range(len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[r] == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while zeroCount &gt; k:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[l] == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += 1&nbsp; # Move left pointer to reduce zeroes in the window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxLength = max(maxLength, r - l + 1)&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return maxLength"	"<h3><strong>Time Complexity: O(n)</strong></h3>
<ul>
<li>The <strong>right pointer (<code>r</code>)</strong> moves from <code>0</code> to <code>n - 1</code>, iterating <strong>once</strong> through <code>nums</code>, taking O(n).</li>
<li>The <strong>left pointer (<code>l</code>)</strong> also moves forward when necessary, but each element is visited at most <strong>once</strong>.</li>
<li>Since each element is processed <strong>at most twice</strong> (once by <code>r</code> and once by <code>l</code>), the worst-case runtime remains <strong>O(n)</strong>.</li>
</ul>

<h3><strong>Space Complexity: O(1)</strong></h3>
<ul>
<li>The algorithm uses only a few integer variables (<code>maxLength</code>, <code>l</code>, <code>r</code>, <code>kRemaining</code>).</li>
<li>There are <strong>no extra data structures</strong> used, so space usage is <strong>constant</strong>.</li></ul>"
Maximum Average Subarray I	Easy		Sliding Window	"<div><div><span style=""color: #008000;""># use a sliding window of fixed size k.</span></div><div> <span style=""color: #008000;""># as you slide the window, keep track of the sum of the numbers in the window.</span></div><div> <span style=""color: #008000;""># divide by k to find the average and store the highest average.</span></div></div>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def findMaxAverage(self, nums: List[int], k: int) -&gt; float:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Compute the sum of the first window<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; windowSum = sum(nums[:k])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxAv = windowSum / k&nbsp; # Set max average initially<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Slide the window across the array<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(k, len(nums)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; windowSum += nums[i] - nums[i - k]&nbsp; # Add new element, remove old element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxAv = max(maxAv, windowSum / k)&nbsp;&nbsp; # Update max average<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return maxAv"	Time Complexity: O(N)<br>Space Complexity: O(1)
Determine if Two Strings Are Close	Medium		Hashmap	"<div><div><span style=""color: #008000;""># using operation 1, if i can swap all characters with each other, then if word1 is </span></div><div> <span style=""color: #008000;""># an anagram of word2, then they are close.</span></div><div> <span style=""color: #008000;""># if a character exists in either word1 or word2 that does not exist in the other, they</span></div><div> <span style=""color: #008000;""># cannot be close</span></div><div> <span style=""color: #008000;""># while operation 1 is used to swap positions of characters, operation 2 is fundamentally</span></div><div> <span style=""color: #008000;""># about quantities of characters. if one character has the right quantity for another, </span></div><div> <span style=""color: #008000;""># and that character has the right quantity for this character then they should be </span></div><div> <span style=""color: #008000;""># swapped.</span></div><div> <span style=""color: #008000;""># in order to see if two words are close, we will first align quantity and then align </span></div><div> <span style=""color: #008000;""># position.</span></div></div>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def closeStrings(self, word1: str, word2: str) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Count character frequencies<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; word1Freq = Counter(word1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; word2Freq = Counter(word2)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Words must have the same unique characters<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if set(word1Freq.keys()) != set(word2Freq.keys()):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Words must have the same character frequency distribution<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sorted(word1Freq.values()) == sorted(word2Freq.values())"	"<h3><strong>Time Complexity Analysis</strong></h3><div>O(nlogn+mlogm)<strong><br></strong></div><h3><strong>Space Complexity Analysis</strong></h3>
<ul>
<li><strong>Counters:</strong> O(1) (since we store at most 26 character frequencies).</li>
<li><strong>Lists for sorting:</strong> O(1) if sorting is done in-place.</li>
</ul>
<div>Thus, the space complexity is <strong>O(1)</strong>&nbsp;since we don't use additional space proportional to input size (aside from the counters and lists storing character counts).</div>"
Find the Difference of Two Arrays	Easy		HashSets	use sets and set comparisons	class Solution:<br>&nbsp;&nbsp;&nbsp; def findDifference(self, nums1: List[int], nums2: List[int]) -&gt; List[List[int]]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set1, set2 = set(nums1), set(nums2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [list(set1 - set2), list(set2 - set1)]	Time Complexity:&nbsp;O(N+M) as creating the set is O(N) and doing the set difference e.g. set1 - set2 is O(set1)<br>Space Complexity: O(N+M)
Removing Stars From a String	Medium		Stack	use a stack<br>iterate through the characters, if it's a star, pop from stack, if it's a letter, add to stack.	class Solution:<br>&nbsp;&nbsp;&nbsp; def removeStars(self, s):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(0, len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[i] == '*':<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.append(s[i])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ''.join(st)	"<div>Here,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the length of&nbsp;<code>s</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We iterate over&nbsp;<code>s</code>&nbsp;and for every character we either push it in the stack or pop the top character from the stack which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;time per character. It takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time for&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;characters.</li><li>To form the&nbsp;<code>answer</code>&nbsp;string, we remove all the characters from the stack. Because a stack can have maximum of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;characters, it would also take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time in that case.</li><li>We also require&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time to reverse&nbsp;<code>answer</code>&nbsp;which can have&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;characters.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>The stack used in the solution can grow to a maximum size of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>. We would need&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;space in that case.</li></ul></li></ul>"
Delete The Middle Node of a Linked List	Medium		Fast/Slow Pointers	<ol><li>If there is only one node, return&nbsp;<code>null</code>.</li><li>Otherwise, initialize two pointers&nbsp;<code>slow</code>&nbsp;and&nbsp;<code>fast</code>, with&nbsp;<code>slow</code>&nbsp;pointing to&nbsp;<code>head</code>&nbsp;and&nbsp;<code>fast</code>&nbsp;pointing to the second successor node of&nbsp;<code>head</code>.</li><li>While neither&nbsp;<code>fast</code>&nbsp;and&nbsp;<code>fast.next</code>&nbsp;is&nbsp;<code>null</code>:<ul><li>we move&nbsp;<code>fast</code>&nbsp;forward by 2 nodes.</li><li>we move&nbsp;<code>slow</code>&nbsp;forward by 1 node.</li></ul></li><li>Now&nbsp;<code>slow</code>&nbsp;is the predecessor of the middle node, delete the middle node.</li><li>Return&nbsp;<code>head</code>.</li></ol>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Edge case: return None if there is only one node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if head.next == None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initialize two pointers, 'slow' and 'fast'.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow, fast = head, head.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Let 'fast' move forward by 2 nodes, 'slow' move forward by 1 node each step.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while fast and fast.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow = slow.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fast = fast.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # When 'fast' reaches the end, remove the next node of 'slow' and return 'head'.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slow.next = slow.next.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The job is done, return 'head'.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return head"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;be the length of the input linked list.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We stop the iteration when the pointer&nbsp;<code>fast</code>&nbsp;reaches the end,&nbsp;<code>fast</code>&nbsp;moves forward 2 nodes per step, so there are at most&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span>/2</span>&nbsp;steps.</li><li>In each step, we move both&nbsp;<code>fast</code>&nbsp;and&nbsp;<code>slow</code>, which takes a constant amount of time.</li><li>Removing the middle node also takes constant time.</li><li>In summary, the overall time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></div><ul><li>We only need two pointers, so the space complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>.</li></ul></li></ul><br>"
Asteroid Collision	Medium		Stack	We don't really need to add negative asteroids into stack.<br>Consider stack as a barrier of positive asteroids that negative should pass.<br><div><div>Direction, position, and magnitude matter. speed does not.</div><div> We can use a stack to keep track of the most recent asteroids that are travelling</div><div> In the right direction.</div></div>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for x in asteroids:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x &gt; 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # positive asteroid, moving right<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # negative asteroid, moving left — may collide<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while stack and stack[-1] &lt; abs(x):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # destroy smaller right-moving asteroids<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.pop()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not stack:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # no more right-moving asteroids — x survives<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans.append(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if stack[-1] == abs(x):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # both asteroids destroy each other<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # else: right-moving asteroid is larger — x is destroyed<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ans + stack"	"<ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div><div>We iterate over each asteroid in the list, and for each asteroid, we might iterate over the asteroids we have in the stack and keep popping until they explode. The important point is that each asteroid can be added and removed from the stack only once. Therefore, each asteroid can be processed only twice, first when we iterate over it and then again while popping it from the stack. Therefore, the total time complexity is equal to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div><div>The only space required is for the stack; the maximum number of asteroids that could be there in the stack is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;when there is no asteroid collision. The final list that we return,&nbsp;<code>remainingAsteroids</code>, is used to store the output, which is generally not considered part of space complexity. Hence, the total space complexity equals&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div></li></ul>"
Decode String	Medium		Stack	<b>One Stack:</b><br><div><b>Intuition</b></div><div>We have to decode the result in a particular pattern. We know that the input is always valid. The pattern begins with a number&nbsp;<code>k</code>, followed by opening braces&nbsp;<code>[</code>, followed by&nbsp;<code>string</code>. Post that, there could be one of the following cases :</div><ol><li>There is another nested pattern&nbsp;<code>k[string k[string]]</code></li><li>There is a closing bracket&nbsp;<code>k[string]</code></li></ol><div>Since we have to start decoding the innermost pattern first, continue iterating over the string&nbsp;<code>s</code>, pushing each character to the stack until it is not a closing bracket&nbsp;<code>]</code>. Once we encounter the closing bracket&nbsp;<code>]</code>, we must start decoding the pattern.</div><div>As we know that stack follows the Last In First Out (LIFO) Principle, the top of the stack would have the data we must decode.</div><div><strong>Algorithm</strong></div><div>The input can contain an alphabet&nbsp;<code>(a-z)</code>, digit&nbsp;<code>(0-9)</code>, opening braces&nbsp;<code>[</code>&nbsp;or closing braces&nbsp;<code>]</code>. Start traversing string&nbsp;<code>s</code>&nbsp;and process each character based on the following rules:</div><div>Case 1) Current character is not a closing bracket&nbsp;<code>]</code>.</div><div>Push the current character to stack.</div><div>Case 2) Current character is a closing bracket&nbsp;<code>]</code>.</div><div>Start decoding the last traversed string by popping the string&nbsp;<code>decodedString</code>&nbsp;and number&nbsp;<code>k</code>&nbsp;from the top of the stack.</div><ul><li>Pop from the stack while the next character is not an opening bracket&nbsp;<code>[</code>&nbsp;and append each character (<code>a-z</code>) to the&nbsp;<code>decodedString</code>.</li><li>Pop opening bracket&nbsp;<code>[</code>&nbsp;from the stack.</li><li>Pop from the stack while the next character is a digit&nbsp;<code>(0-9)</code>&nbsp;and build the number&nbsp;<code>k</code>.</li></ul><div>Now that we have&nbsp;<code>k</code>&nbsp;and&nbsp;<code>decodedString</code>&nbsp;, decode the pattern&nbsp;<code>k[decodedString]</code>&nbsp;by pushing the&nbsp;<code>decodedString</code>&nbsp;to stack&nbsp;<code>k</code>&nbsp;times.</div><div>Once the entire string is traversed, pop the&nbsp;<code>result</code>&nbsp;from stack and return.</div><br><b>Two Stack:</b><br><br><div><strong>Intuition</strong></div><div>In the previous approach, we used a single character stack to store the digits<code>(0-9)</code>&nbsp;as well as letters&nbsp;<code>(a-z)</code>.<br>We could instead maintain 2 separate stacks.</div><ul><li><code>countStack</code>: The stack would store all the integer&nbsp;<code>k</code>.</li><li><code>stringStack</code>: The stack would store all the decoded strings.</li></ul><div>Also, instead of pushing the decoded string to the stack character by character, we could improve our algorithm by appending all the characters into the string first and then push the entire string into the&nbsp;<code>stringStack</code>. Let's look at the algorithm in detail.</div><div><strong>Algorithm</strong></div><div>Iterate over the string&nbsp;<code>s</code>&nbsp;and process each character as follows:</div><div>Case 1) If the current character is a digit&nbsp;<code>(0-9)</code>, append it to the number&nbsp;<code>k</code>.</div><div>Case 2) If the current character is a letter&nbsp;<code>(a-z)</code>, append it to the&nbsp;<code>currentString</code>.</div><div>Case 3) If current character is a opening bracket&nbsp;<code>[</code>, push&nbsp;<code>k</code>&nbsp;and&nbsp;<code>currentString</code>&nbsp;into<code>&nbsp;countStack</code>&nbsp;and&nbsp;<code>stringStack</code>&nbsp;respectively.</div><div>Case 4) Closing bracket&nbsp;<code>]</code>: We must begin the decoding process,</div><ul><li><div>We must decode the&nbsp;<code>currentString</code>. Pop&nbsp;<code>currentK</code>&nbsp;from the&nbsp;<code>countStack</code>&nbsp;and decode the pattern&nbsp;<code>currentK[currentString]</code></div></li><li><div>As the&nbsp;<code>stringStack</code>&nbsp;contains the previously decoded string, pop the&nbsp;<code>decodedString</code>&nbsp;from the&nbsp;<code>stringStack</code>.<br>Update the&nbsp;<code>decodedString</code>&nbsp;=&nbsp;<code>decodedString</code>&nbsp;+&nbsp;<code>currentK[currentString]</code></div></li></ul><br><br>	"<b>One Stack:</b><br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def decodeString(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(s)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[i] != ""]"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(s[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; substr = """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while stack[-1] != ""["":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; substr = stack.pop() + substr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.pop()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while stack and stack[-1].isdigit():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = stack.pop() + k<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.append(int(k) * substr)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """".join(stack)<br><br><b>Two Stack:</b><br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def decodeString(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string_stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count_stack = []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in s:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c.isdigit():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = k * 10 + int(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif c == ""["":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string_stack.append(cur)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count_stack.append(k)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = """"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif c == ""]"":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = cur<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur = string_stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = count_stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur += temp * count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur += c<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cur"	"One Stack:<br><br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n+N^2)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n+N)</span></span></li></ul>Where&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">n</span></span>&nbsp;is the length of the input string and&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">N</span></span>&nbsp;is the length of the output string.<br><br>Two Stack:<br><br><ul><li>Time complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n+N)</span></span></li><li>Space complexity:&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">O(n+N)</span></span></li></ul><blockquote><div>Where&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">n</span></span>&nbsp;is the length of the input string and&nbsp;<span style=""color: inherit !important;""><span style=""font-style: inherit; font-weight: inherit; color: inherit !important;"">N</span></span>&nbsp;is the length of the output string.</div></blockquote>"
Greatest Common Divisor of Strings	Easy		use gcd function	"<div><div>My Solution:</div><div><br></div><div># have to find string that can be multiplied some number of times to equal str1 and</div><div> # str2. This must mean the gcd is a prefix of str1 and str2. We will test prefixes of</div><div> # the shorter of the two strings.</div><div> # to test whether a potential gcd is in fact the gcd, we take the length of str1 and</div><div> # str2 and divide tha its length,<br><br>Better Solution:<br><br>Algorithm<ol><li><div>Check if the concatenations of&nbsp;<code>str1</code>&nbsp;and&nbsp;<code>str2</code>&nbsp;in different orders are the same.</div><ul><li>If not, return&nbsp;<code>""""</code>.</li></ul></li><li><div>Get the GCD&nbsp;<code>gcdLength</code>&nbsp;of the two lengths of&nbsp;<code>str1</code>&nbsp;and&nbsp;<code>str2</code>.</div></li><li><div>Return the prefix string with a length of&nbsp;<code>gcdLength</code>&nbsp;of either&nbsp;<code>str1</code>&nbsp;or&nbsp;<code>str2</code>&nbsp;as the answer.</div></li></ol></div></div>"	"<b>My Solution:</b><br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def gcdOfStrings(self, str1: str, str2: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The GCD string must be a prefix of both strings<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shorter_string = str1 if len(str1) &lt;= len(str2) else str2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest_gcd = ''<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(1, len(shorter_string) + 1):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; potential_gcd = shorter_string[:i]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(str1) % len(potential_gcd) != 0 or len(str2) % len(potential_gcd) != 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if potential_gcd * (len(str1) // len(potential_gcd)) == str1 and \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; potential_gcd * (len(str2) // len(potential_gcd)) == str2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longest_gcd = potential_gcd<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return longest_gcd<br><br><b>Better Solution:<br></b><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def gcdOfStrings(self, str1: str, str2: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check if they have non-zero GCD string.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if str1 + str2 != str2 + str1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return """"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Get the GCD of the two lengths.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_length = gcd(len(str1), len(str2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return str1[:max_length]"	"My Solution:<br>Time Complexity: Worst Case O(min(n, m) * (n + m))<br>Space Complexity:&nbsp;O(n + m)<br><br>Better Solution:<br><br><div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">m</span>,<span style=""font-style: italic;"">n</span></span>&nbsp;be the lengthes of the two input strings&nbsp;<code>str1</code>&nbsp;and&nbsp;<code>str2</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We need to compare the two concatenations of length&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span>, it takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li><li>We calculate the GCD using binary Euclidean algorithm, it takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">log(<span style=""font-style: italic;"">m</span>⋅<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li><li>To sum up, the overall time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span>.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span><br>We need to compare the two concatenations of length&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span>.</div></li></ul>"
Can Place Flowers	Easy		While Loop	Loop through flowerbed one time using a while loop. Note: For this approach, you have to keep in mind that at any current position, we will always be backwards validated but not forwards validated. What this means is that we know we are able to place a flower in the current position from the perspective of the flowerbed to the left of the current position but not necessarily from the right. This is because at each iteration, we are moving forward responsibly, and skipping positions that we know to be impossible to place at.&nbsp;<br>If the current number is a 1, there is already a flower there and so we must skip forward 2 spaces as we could not place a flower in the next space.<br>If the current number is a 0, there are multiple situations:<br>- if we are on the last position in the flowerbed, this must be a position where we can place a flower. We know this because of the Note written above.&nbsp;<br>- if we are not on the last position, but we know that there are no flowers to the left of the current flower that are stopping us from placing, we must only check one to the right of the flower to see if we can place. if we can place, then we decremenet n and skip i forward by 2, because it is impossible to place on the immediate next place.<br>-&nbsp; if the next position is a 1, we must have to skip forward three positions.	class Solution:<br>&nbsp;&nbsp;&nbsp; def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while i &lt; len(flowerbed):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if flowerbed[i] == 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == len(flowerbed)-1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif flowerbed[i+1] != 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n == 0: return True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n &lt;= 0	"<ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>. A single scan of the&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span><span style=""font-style: italic;"">l</span><span style=""font-style: italic;"">o</span><span style=""font-style: italic;"">w</span><span style=""font-style: italic;"">er</span><span style=""font-style: italic;"">b</span><span style=""font-style: italic;"">e</span><span style=""font-style: italic;"">d</span></span>&nbsp;array of size&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is done.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. Constant extra space is used.</div></li></ul>"
Reverse Vowels of a String	Easy		Two Pointer	<ol><li>Initialize the left pointer&nbsp;<code>start</code>&nbsp;to&nbsp;<code>0</code>, and the right pointer&nbsp;<code>end</code>&nbsp;to&nbsp;<code>s.size() - 1</code>.</li><li>Keep iterating until the left pointer catches up with the right pointer:<ol><li>Keep incrementing the left pointer&nbsp;<code>start</code>&nbsp;until it's pointing to a vowel character.</li><li>Keep decrementing the right pointer&nbsp;<code>end</code>&nbsp;until it's pointing to a vowel character.</li><li>Swap the characters at the&nbsp;<code>start</code>&nbsp;and&nbsp;<code>end</code>.</li><li>Increment the&nbsp;<code>start</code>&nbsp;pointer and decrement the&nbsp;<code>end</code>&nbsp;pointer.</li></ol></li><li>Return the string&nbsp;<code>s</code>.</li></ol>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def reverseVowels(self, s: str) -&gt; str:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Define a set of vowels for quick lookup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vowels = set(""aeiouAEIOU"")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Convert string to list of characters since strings are immutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_chars = list(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start, end = 0, len(s_chars) - 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Two-pointer approach to find and swap vowels<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while start &lt; end:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while start &lt; end and s_chars[start] not in vowels:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while start &lt; end and s_chars[end] not in vowels:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if start &lt; end:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_chars[start], s_chars[end] = s_chars[end], s_chars[start]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end -= 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ''.join(s_chars)"	"<ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span></div><div>It might be tempting to say that there are two nested loops and hence the complexity would be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>2)</span>. However, if we observe closely the pointers&nbsp;<code>start</code>&nbsp;and&nbsp;<code>end</code>&nbsp;will only traverse the index once. Each element of the string&nbsp;<code>s</code>&nbsp;will be iterated only once either by the left or right pointer and not both. We swap characters when both pointers point to vowels which are&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;operation. Hence the total time complexity will be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div><div>Note that in Java we need to convert the string to a char array as strings are immutable and hence it would take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;time.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span></div><div>In C++ we only need an extra temporary variable to perform the swap and hence the space complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. However, in Java, we need to convert the string to a char array that would take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;space, and therefore the space complexity for Java would be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div></li></ul><div><div>Now, here’s where the language difference matters:</div>
<ul>
<li>In Python, <strong>strings are immutable</strong>, just like Java.</li>
<li>To perform in-place swaps, you <strong>must convert the string to a list of characters</strong>: <code>list(s)</code>
<ul>
<li>This costs <strong>O(N)</strong> space.</li>
</ul>
</li>
<li>The final result uses <code>''.join(...)</code> to create a new string, which also takes <strong>O(N)</strong> space.</li></ul></div>"
Odd Even Linked List	Medium		LinkedList	We want to iterate through the list, putting the odd nodes in one list and the even nodes in another list.&nbsp;<br>We should initialize two pointers, odd and even on the first node and second node respectively, representing the start of the two lists.&nbsp;<br>We also need to save a pointer to the start of the even list so we can attach it to the end of the odd list later.<br>We then create a while loop with the condition of there being an even.next. In other words, we only need one node beyond where the even node is to continue the loop.<br>After the loop, attach the end of the odd list to the start of the even list and return the head.	"# Definition for singly-linked list.<br># class ListNode:<br>#&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, val=0, next=None):<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.val = val<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.next = next<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not head or not head.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return head<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; odd = head<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; even = head.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head_odd = odd<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head_even = even<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while even and even.next:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; odd.next = even.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; odd = odd.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; even.next = odd.next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; even = even.next<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; odd.next = head_even<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return head_odd"	"<ul><li><div>Time complexity :&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>. There are total&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;nodes and we visit each node once.</div></li><li><div>Space complexity :&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. All we need is the four pointers.</div></li></ul>"
Keys and Rooms	Medium		DFS	Do a DFS and maintain a set of rooms visited. As a base case, check if the room has been visited before. If not, call the dfs on all the keys in the room.<br>At the end, check if the length of the visited set is equal to the number of rooms.	class Solution:<br>&nbsp;&nbsp;&nbsp; def canVisitAllRooms(self, rooms: List[List[int]]) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited = set()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(room):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if room in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add(room)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for key in rooms[room]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(key)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dfs(0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return len(visited) == len(rooms)	"<ul><li><div>Time Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">E</span>)</span>, where&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;is the number of rooms, and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">E</span></span>&nbsp;is the total number of keys.</div></li><li><div>Space Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;in additional space complexity, to store&nbsp;<code>stack</code>&nbsp;and&nbsp;<code>seen</code>.</div></li></ul>"
Number of Provinces	Medium		Graph DFS	<div><div>we have an nxn adjacency matrix. it is a symmetric matrix because this is an</div><div>undirected graph. it has 1s on the diagonal.</div><div>we want to find the number of connected components in the graph.</div><div>make a recursive function, find_connections that iterates through the connections</div><div>of the given node and marks that node as visited.</div></div>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connected_components = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def find_connections(node, visited):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Recursive DFS to visit all nodes in the current component<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if node in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visited.add(node)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connections = isConnected[node]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(len(connections)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if connections[i] == 1 and i != node and i not in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find_connections(i, visited)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Iterate through each node and start a DFS if it's unvisited<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for node in range(len(isConnected)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if node not in visited:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connected_components += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find_connections(node, visited)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return connected_components"	"<div>Here&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the number of cities.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n^</span>2)</span>.</div><ul><li>Initializing the&nbsp;<code>visit</code>&nbsp;array takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li><li>The&nbsp;<code>dfs</code>&nbsp;function visits each node once, which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time because there are&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;nodes in total. From each&nbsp;<code>node</code>, we iterate over all possible edges using&nbsp;<code>isConnected[node]</code>&nbsp;which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time for each visited node. As a result, it takes a total of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n^</span>2)</span>&nbsp;time to visit all the nodes and iterate over its edges.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>.</div><ul><li>The&nbsp;<code>visit</code>&nbsp;array takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;space.</li><li>The recursion call stack used by&nbsp;<code>dfs</code>&nbsp;can have no more than&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;elements in the worst-case scenario. It would take up&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;space in that case.</li></ul></li></ul>"
Leaf-Similar Trees	Easy		Tree DFS	<div>Let's find the leaf value sequence for both given trees. Afterwards, we can compare them to see if they are equal or not.</div><div>To find the leaf value sequence of a tree, we use a depth first search. Our&nbsp;<code>dfs</code>&nbsp;function writes the node's value if it is a leaf, and then recursively explores each child. This is guaranteed to visit each leaf in left-to-right order, as left-children are fully explored before right-children.</div>	class Solution:<br>&nbsp;&nbsp;&nbsp; def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def find_leaf_sequence(root):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not root:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return []<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not root.left and not root.right:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [root.val]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return find_leaf_sequence(root.left) + find_leaf_sequence(root.right)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return find_leaf_sequence(root1) == find_leaf_sequence(root2)<br><br><br><br>Can also use iterator comparison:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def leafSimilar(self, root1, root2):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(node):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if node:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not node.left and not node.right:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield node.val<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield from dfs(node.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield from dfs(node.right)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return list(dfs(root1)) == list(dfs(root2))	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;be the number of nodes in&nbsp;<code>root1</code>&nbsp;and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">M</span></span>&nbsp;the number of nodes in&nbsp;<code>root2</code>.</div><ul><li><div>Time Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">M</span>)</span></div><div>The&nbsp;<code>dfs</code>&nbsp;function visits each node exactly once in both trees, resulting in a time complexity of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;for the first call and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">M</span>)</span>&nbsp;for the second call.</div><div>After collecting all leaves in the&nbsp;<code>leaves1</code>&nbsp;and&nbsp;<code>leaves2</code>&nbsp;arrays, we compare them using the&nbsp;<code>==</code>&nbsp;operator. Comparing two arrays of size&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">L</span></span>&nbsp;has a worst-case time complexity of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">L</span>)</span>, where&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">L</span></span>&nbsp;is the number of leaf nodes in the larger array.</div><div>Since&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">L</span>≤min(<span style=""font-style: italic;"">N</span>,<span style=""font-style: italic;"">M</span>)</span>, the comparison time is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(min(<span style=""font-style: italic;"">N</span>,<span style=""font-style: italic;"">M</span>))</span>, but this is dominated by the time spent traversing both trees.</div><div>Overall, the time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">M</span>)</span>.</div></li><li><div>Space Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">M</span>)</span></div><div>The recursive&nbsp;<code>dfs</code>&nbsp;calls will require stack space for each node. In the worst case, if the trees are completely unbalanced (like a linked list), the recursion depth could be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">M</span>)</span>&nbsp;respectively, leading to a total stack space complexity of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">M</span>)</span>.</div><div>Additionally, each&nbsp;<code>dfs</code>&nbsp;call collects leaf nodes into&nbsp;<code>leaves1</code>&nbsp;and&nbsp;<code>leaves2</code>. The maximum number of leaves in a binary tree is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">2<span style=""font-style: italic;"">N</span>​</span>&nbsp;(for a full binary tree), resulting in&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">M</span>)</span>&nbsp;space for each array.</div><div>Therefore, the total space complexity, combining both the recursion stack and the storage for the leaves, is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>+<span style=""font-style: italic;"">M</span>)</span>.</div></li></ul>"
Nearest Exit from Entrance in Maze	Medium		BFS from entrance	"<ol><li>Initialize an empty queue&nbsp;<code>queue</code>&nbsp;to store all the nodes to be visited.</li><li>Add&nbsp;<code>entrance</code>&nbsp;and its distance&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">0</span>&nbsp;to&nbsp;<code>queue</code>&nbsp;and mark&nbsp;<code>entrance</code>&nbsp;as visited.</li><li>While we don't reach an exit and&nbsp;<code>queue</code>&nbsp;still has cells, pop the first cell from&nbsp;<code>queue</code>. Suppose its distance from&nbsp;<code>entrance</code>&nbsp;is&nbsp;<code>curr_distance</code>. We check its neighboring cells in all four directions, if it has an unvisited neighbor cell:<ul><li>If this neighbor cell is an exit, return its distance from the starting position,&nbsp;<code>curr_distance + 1</code>, as the nearest distance.</li><li>Otherwise, we mark it as visited, and add it to&nbsp;<code>queue</code>&nbsp;along with its distance&nbsp;<code>curr_distance + 1</code>.</li></ul></li><li>If we finish the iteration and no exit is found, return -1.</li></ol>"	"from collections import deque<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS, COLS = len(maze), len(maze[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen = set()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue = deque()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((entrance[0], entrance[1]))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add((entrance[0], entrance[1]))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; steps = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while queue:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for _ in range(len(queue)):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r, c = queue.popleft()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r, c) != (entrance[0], entrance[1]) and (r in [0, ROWS - 1] or c in [0, COLS - 1]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return steps<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dr, dc in directions:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr, nc = r + dr, c + dc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 0 &lt;= nr &lt; ROWS and 0 &lt;= nc &lt; COLS and (nr, nc) not in seen and maze[nr][nc] == ""."":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue.append((nr, nc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seen.add((nr, nc))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; steps += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">m</span>,<span style=""font-style: italic;"">n</span></span>&nbsp;be the size of the input matrix&nbsp;<code>maze</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>⋅<span style=""font-style: italic;"">n</span>)</span></div><ul><li>For each visited cell, we add it to&nbsp;<code>queue</code>&nbsp;and pop it from&nbsp;<code>queue</code>&nbsp;once, which takes constant time as the operation on queue requires&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;time.</li><li>For each cell in&nbsp;<code>queue</code>, we mark it as visited in&nbsp;<code>maze</code>, and check if it has any unvisited neighbors in all four directions. This also takes constant time.</li><li>In the worst-case scenario, we may have to visit&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>⋅<span style=""font-style: italic;"">n</span>)</span>&nbsp;cells before the iteration stops.</li><li>To sum up, the overall time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>⋅<span style=""font-style: italic;"">n</span>)</span>.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">ma</span><span style=""font-style: italic;"">x</span>(<span style=""font-style: italic;"">m</span>,<span style=""font-style: italic;"">n</span>))</span></div><ul><li>We modify the input matrix&nbsp;<code>maze</code>&nbsp;in-place to mark each visited cell, it requires constant space.</li><li>We use a queue&nbsp;<code>queue</code>&nbsp;to store the cells to be visited. In the worst-case scenario, there may be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)</span>&nbsp;cells stored in&nbsp;<code>queue</code>.</li><li>The space complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)+<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">ma</span><span style=""font-style: italic;"">x</span>(<span style=""font-style: italic;"">m</span>,<span style=""font-style: italic;"">n</span>))</span>.</li></ul></li></ul>"
Guess Number Higher or Lower	Easy		Binary Search	We can apply Binary Search to find the given number. We start with the mid<br>number. We pass that number to the&nbsp;guess&nbsp;function. If it returns a -1, it implies that the guessed number is larger than the required one. Thus, we use Binary Search for numbers lower than itself. Similarly, if it returns a 1, we use Binary Search<br>for numbers higher than itself	"# The guess API is already defined for you.<br># @param num, your guess<br># @return -1 if num is higher than the picked number<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 if num is lower than the picked number<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 if num is equal to the picked number<br># def guess(num: int) -&gt; int:<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def guessNumber(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left, right = 1, n<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while left &lt;= right:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (left + right) // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = guess(mid)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return mid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif res == -1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = mid - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:&nbsp; # res == 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = mid + 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1&nbsp; # This line is technically unreachable if the input is valid"	"<ul><li>Time complexity :&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log_2​<span style=""font-style: italic;"">n</span>)</span>. Binary Search is used.</li><li>Space complexity :&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>. No extra space is used.</li></ul>"
Successful Pairs of Spells and Potions	Medium		Sorting and Binary Search	<ol><li>Sort the&nbsp;<code>potions</code>&nbsp;array in ascending order.</li><li>Initialize variables:<ul><li><code>answer</code>, an array to store the result.</li><li><code>m</code>, length of the&nbsp;<code>potions</code>&nbsp;array.</li><li><code>maxPotion</code>, the maximum value in the&nbsp;<code>potions</code>&nbsp;array.</li></ul></li><li>For each&nbsp;<code>spell</code>&nbsp;in the&nbsp;<code>spells</code>&nbsp;array:<ul><li>Calculate the minimum potion strength required to make the spell successful as&nbsp;<code>minPotion</code>&nbsp;using the formula&nbsp;<code>minPotion = ceil(success / spell)</code>.</li><li>If&nbsp;<code>minPotion</code>&nbsp;is greater than&nbsp;<code>maxPotion</code>, store&nbsp;<code>0</code>&nbsp;in the&nbsp;<code>answer</code>&nbsp;array and continue to the next spell.</li><li>Otherwise, find the index of the first element in the&nbsp;<code>potions</code>&nbsp;array that is greater than or equal to&nbsp;<code>minPotion</code>&nbsp;using the inbuilt lower bound methods like&nbsp;<code>lower_bound()</code>,&nbsp;<code>bisect.bisect_left()</code>,&nbsp;<code>sort.SearchInts()</code>, etc. or by implementing it on your own.</li><li>Calculate the number of successful pairs possible for the current&nbsp;<code>spell</code>&nbsp;as&nbsp;<code>(m - index)</code>.</li><li>Store the result in the&nbsp;<code>answer</code>&nbsp;vector.</li></ul></li><li>Return the&nbsp;<code>answer</code>&nbsp;array which contains the number of successful pairs for each&nbsp;<code>spell</code>.</li></ol>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def successfulPairs(self, spells: List[int], potions: List[int], success: int) -&gt; List[int]:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Sort the potions array in increasing order.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; potions.sort()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer = []<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = len(potions)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxPotion = potions[m - 1]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for spell in spells:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Minimum value of potion whose product with current spell<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # will be at least success or more.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minPotion = (success + spell - 1) // spell<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check if we don't have any potion which can be used.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if minPotion &gt; maxPotion:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer.append(0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # We can use the found potion, and all potion in its right<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (as the right potions are greater than the found potion).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = bisect.bisect_left(potions, minPotion)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer.append(m - index)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return answer"	"<div>Here,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;is the number of elements in the&nbsp;<code>spells</code>&nbsp;array, and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">m</span></span>&nbsp;is the number of elements in the&nbsp;<code>potions</code>&nbsp;array.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>((<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>)⋅log<span style=""font-style: italic;"">m</span>)</span></div><ul><li>We sort the&nbsp;<code>potions</code>&nbsp;array which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>log<span style=""font-style: italic;"">m</span>)</span>&nbsp;time.</li><li>Then, for each element of the&nbsp;<code>spells</code>&nbsp;array using binary search we find the respective&nbsp;<code>minPotion</code>&nbsp;which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">m</span>)</span>&nbsp;time. So, for&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;elements it takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>log<span style=""font-style: italic;"">m</span>)</span>&nbsp;time.</li><li>Thus, overall we take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>log<span style=""font-style: italic;"">m</span>+<span style=""font-style: italic;"">n</span>log<span style=""font-style: italic;"">m</span>)</span>&nbsp;time.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(log<span style=""font-style: italic;"">m</span>)</span>&nbsp;or&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>)</span></div><ul><li>The output array&nbsp;<code>answer</code>&nbsp;is not considered as additional space usage.</li><li>But some extra space is used when we sort the&nbsp;<code>potions</code>&nbsp;array in place. The space complexity of the sorting algorithm depends on the programming language.<ul><li>In Python, the sort() method sorts a list using the Timsort algorithm which has&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">m</span>)</span>&nbsp;additional space where&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">m</span></span>&nbsp;is the number of the elements.</li></ul></li></ul></li></ul>"
N-th Tribonacci Number	Easy		DP	"<ol><li><div>Create a hash map&nbsp;<code>dp</code>&nbsp;to store the value of computed tribonacci numbers, initialized with the base cases&nbsp;<code>dp[0] = 0, dp[1] = 1, dp[2] = 1</code>.</div></li><li><div>Let&nbsp;<code>dfs(i)</code>&nbsp;be the value of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">i</span><span style=""font-style: italic;"">t</span><span style=""font-style: italic;"">h</span></span>&nbsp;tribonacci numbers:</div><ul><li><div>If&nbsp;<code>i</code>&nbsp;is in&nbsp;<code>dp</code>, return&nbsp;<code>dp[i]</code>.</div></li><li><div>Otherwise, recursively solve&nbsp;<code>answer = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)</code>&nbsp;and set&nbsp;<code>dp[i] = answer</code>. Then return&nbsp;<code>answer</code>.</div></li></ul></li><li>Return&nbsp;<code>dfs(n)</code>.<br><br></li></ol><div>OR&nbsp;</div><div><br></div><div><ol><li><div>If&nbsp;<code>n &lt; 3</code>, return the value of the&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span><span style=""font-style: italic;"">t</span><span style=""font-style: italic;"">h</span></span>&nbsp;term as indicated by the problem description.</div></li><li><div>Initialize&nbsp;<code>a</code>,&nbsp;<code>b</code>, and&nbsp;<code>c</code>&nbsp;as the base cases. Set&nbsp;<code>a = 0, b = 1, c = 1</code>.</div></li><li><div>For the next&nbsp;<code>n - 2</code>&nbsp;steps, update&nbsp;<code>a, b, c</code>&nbsp;as&nbsp;<code>a = b, b = c, c = a + b + c</code>.</div></li><li><div>Return&nbsp;<code>c</code>.</div></li></ol></div>"	class Solution:<br>&nbsp;&nbsp;&nbsp; def tribonacci(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp = {0: 0, 1: 1, 2: 1}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def dfs(i):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i in dp:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dp[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dfs(n)<br><br><br><br>OR&nbsp;<br><br><br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def tribonacci(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n &lt; 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 if n else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a, b, c = 0, 1, 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for _ in range(n - 2):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a, b, c = b, c, a + b + c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c	"<div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We recursively call&nbsp;<code>dfs</code>&nbsp;on subproblems and each subproblem&nbsp;<code>dfs(i)</code>&nbsp;is computed once.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>The hash map&nbsp;<code>dp</code>&nbsp;contains at most&nbsp;<code>n + 1</code>&nbsp;key-value pairs.</li></ul></li></ul></div><div><br></div><div>OR</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span></div><ul><li>We have to update the value of&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>&nbsp;by&nbsp;<code>n - 2</code>&nbsp;times, each update takes constant time. Thus it takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></div><ul><li>We only need to update several parameters&nbsp;<code>a, b, c</code>&nbsp;and&nbsp;<code>tmp</code>, which takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;space.</li></ul></li></ul>"
Domino and Tromino Tiling	Medium		DP	"<ul><li><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)</span>: The number of ways to&nbsp;<strong><em>fully cover a board</em></strong>&nbsp;of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span></span>.</li><li><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>: The number of ways to&nbsp;<strong><em>partially cover a board</em></strong>&nbsp;of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span></span>.</li></ul><div>We can determine the number of ways to fully or partially tile a board of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span></span>&nbsp;by considering every possible way to arrive at&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;or&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;by placing a domino or a tromino. Let's find&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;together and then you can pause to practice by finding&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;on your own. All of the ways to arrive at a fully tiled board of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span></span>&nbsp;are as follows:</div><ul><li>From&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;we can add 1 vertical domino for each tiling in a fully covered board with a width of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>−1</span>, as shown in the second animation.</li><li>From&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−2)</span>&nbsp;we can add 2 horizontal dominos for each tiling in a fully covered board with a width of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>−2</span>, as shown in the third animation.<ul><li>Note that we don't need to add 2&nbsp;<strong>vertical</strong>&nbsp;dominos to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−2)</span>, since&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;will cover that case and it will cause duplicates if we count it again.</li></ul></li><li>From&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;we can add an L-shaped tromino for each tiling in a partially covered board with a width of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>−1</span>, as shown above (in the fourth animation).<ul><li>We will&nbsp;<strong>multiply by&nbsp;<span style=""font-weight: normal; color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;by 2</strong>&nbsp;because for any partially covered tiling, there will be a horizontally symmetrical tiling of it. For example, the animation below shows two&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;board states that are identical when reflected over the horizontal edge of the board. Logically, there must be an equal number of ways to fully tile the board from both&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;states. So rather than count the number of ways twice, we simply multiply the number of ways from one&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>&nbsp;state by 2.</li></ul></li></ul><div>Summing the ways to reach&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;gives us the following equation:</div><div><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)=<span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−1)+<span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−2)+2∗<span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span></div><div><span style=""color: rgba(38, 38, 38, 0.75);""><br></span></div><div><div>Now that we know where tilings on&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;are coming from, how about&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>? Can we apply the same logic and find that out? Absolutely yes!</div><div>Take a pen and start drawing scenarios that contribute to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(4)</span>&nbsp;(this is a good technique to aid critical thinking during an interview). Start by drawing&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(4)</span>, remember&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(4)</span>&nbsp;is a board of width 4 with the first 3 columns fully covered and the last column half covered. Now, try removing a domino or a tromino to find which scenarios contribute to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(4)</span>. Notice that&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>&nbsp;can come from the below scenarios:</div><ul><li>Adding a tromino to a fully covered board of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>−2</span>&nbsp;(i.e.&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−2)</span>)</li><li>Adding a horizontal domino to a partially covered board of width&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span>−1</span>&nbsp;(i.e.&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)</span>)</li></ul><div>Thus, we arrive at the following conclusion for&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)</span>:</div><div><span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>)=<span style=""font-style: italic;"">p</span>(<span style=""font-style: italic;"">k</span>−1)+<span style=""font-style: italic;"">f</span>(<span style=""font-style: italic;"">k</span>−2)</span></div><div><br></div><div>If&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">k</span></span>&nbsp;is greater than&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">2</span>, then we will make recursive calls to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span></span>&nbsp;and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span></span>&nbsp;according to the transition function:</div><div><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">f</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span><span style=""color: rgba(38, 38, 38, 0.75);"">=</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">f</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">−</span><span style=""color: rgba(38, 38, 38, 0.75);"">1</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span><span style=""color: rgba(38, 38, 38, 0.75);"">+</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">f</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">−</span><span style=""color: rgba(38, 38, 38, 0.75);"">2</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span><span style=""color: rgba(38, 38, 38, 0.75);"">+</span><span style=""color: rgba(38, 38, 38, 0.75);"">2</span><span style=""color: rgba(38, 38, 38, 0.75);"">∗</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">p</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">−</span><span style=""color: rgba(38, 38, 38, 0.75);"">1</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span></div><div><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">p</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span><span style=""color: rgba(38, 38, 38, 0.75);"">=</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">p</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">−</span><span style=""color: rgba(38, 38, 38, 0.75);"">1</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span><span style=""color: rgba(38, 38, 38, 0.75);"">+</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">f</span><span style=""color: rgba(38, 38, 38, 0.75);"">(</span><span style=""color: rgba(38, 38, 38, 0.75); font-style: italic;"">k</span><span style=""color: rgba(38, 38, 38, 0.75);"">−</span><span style=""color: rgba(38, 38, 38, 0.75);"">2</span><span style=""color: rgba(38, 38, 38, 0.75);"">)</span></div></div>"	"class Solution:<br>&nbsp;&nbsp;&nbsp; def numTilings(self, n: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOD = 1_000_000_007<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @cache&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def p(n):&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n == 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (p(n - 1) + f(n - 2)) % MOD<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @cache&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def f(n):&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n &lt;= 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (f(n - 1) + f(n - 2) + 2 * p(n - 1)) % MOD<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f(n)<br><br><br>many more solutions in editorial:&nbsp;<a href=""https://leetcode.com/problems/domino-and-tromino-tiling/editorial/?envType=study-plan-v2&amp;envId=leetcode-75"">https://leetcode.com/problems/domino-and-tromino-tiling/editorial/?envType=study-plan-v2&amp;envId=leetcode-75</a>"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;be the width of the board.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span></div><div>From top (<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>) to bottom (<span style=""color: rgba(38, 38, 38, 0.75);"">1</span>), there will be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;non-memoized recursive calls to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span></span>&nbsp;and to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span></span>, where each non-memoized call requires constant time. Thus,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(2⋅<span style=""font-style: italic;"">N</span>)</span>&nbsp;time is required for the non-memoized calls.</div><div>Furthermore, there will be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">2⋅<span style=""font-style: italic;"">N</span></span>&nbsp;memoized calls to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">f</span></span>&nbsp;and&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;memoized calls to&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">p</span></span>, where each memoized call also requires constant time. Thus&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(3⋅<span style=""font-style: italic;"">N</span>)</span>&nbsp;time is required for the memoized calls.</div><div>This leads to a time complexity of&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(2⋅<span style=""font-style: italic;"">N</span>+3⋅<span style=""font-style: italic;"">N</span>)=<span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span></div><div>Each recursion call stack will contain at most&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;layers. Also, each hashmap will use&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;space. Together this results in&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>&nbsp;space complexity.</div></li></ul>"
Number of Recent Calls	Easy		Queue/Sliding Window	<div>To implement the sliding window, we could use the&nbsp;<code>LinkedList</code>&nbsp;in Java or&nbsp;<code>deque</code>&nbsp;in Python.</div><div>Then the&nbsp;<code>ping(t)</code>&nbsp;function can be implemented in two steps:</div><ul><li><div>Step 1): we append the current ping call to the tail of the sliding window.</div></li><li><div>Step 2): starting from the head of the sliding window, we remove the&nbsp;<em>outdated</em>&nbsp;calls, until we come across a still valid ping call.</div></li></ul><div>As a result, the remaining calls in the sliding window are the ones that fall into the range of&nbsp;<code>[t - 3000, t]</code>.</div>	"class RecentCounter:<br><br>&nbsp;&nbsp;&nbsp; def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.slide_window = deque()<br><br>&nbsp;&nbsp;&nbsp; def ping(self, t: int) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # step 1). append the current call<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.slide_window.append(t)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # step 2). invalidate the outdated pings<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while self.slide_window[0] &lt; t - 3000:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.slide_window.popleft()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return len(self.slide_window)"	"<ul><li><div>Time Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(1)</span></div><ul><li><div>The main time complexity of our&nbsp;<code>ping()</code>&nbsp;function lies in the loop, which in the worst case would run 3000 iterations to pop out all outdated elements, and in the best case a single iteration.</div></li><li><div>Therefore, for a single invocation of&nbsp;<code>ping()</code>&nbsp;function, its time complexity is&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(3000)=O(1)</span>.</div></li><li><div>If we assume that there is a ping call at each timestamp, then the cost of&nbsp;<code>ping()</code>&nbsp;is further amortized, where at each invocation, we would only need to pop out a single element, once the sliding window reaches its upper bound.</div></li></ul></li><li><div>Space Complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);"">O(1)</span></div><ul><li>As we estimated before, the maximal size of our sliding window is 3000, which is a constant.</li></ul></li></ul>"
Longest Subarray of 1's After Deleting One Element	Medium		Sliding Window	<ol><li><div>Initialize three variables:</div><div>a.&nbsp;<code>zeroCount</code>&nbsp;to&nbsp;<code>0</code>; this is the number of zeroes in the current window.</div><div>b.&nbsp;<code>longestWindow</code>&nbsp;to&nbsp;<code>0</code>; this is the longest window having at most one&nbsp;<code>0</code>&nbsp;we have seen so far.</div><div>c.&nbsp;<code>start</code>&nbsp;to&nbsp;<code>0</code>; this is the left end of the window from where it starts.</div></li><li><div>Iterate over the array from index&nbsp;<code>i</code>&nbsp;to&nbsp;<code>array.length - 1</code>&nbsp;(inclusive), and keep counting the zeroes in the variable&nbsp;<code>zeroCount</code>.</div></li><li><div>After every element, check if the&nbsp;<code>zeroCount</code>&nbsp;exceeds&nbsp;<code>1</code>; if yes, keep removing elements from the left until the value of&nbsp;<code>zeroCount</code>&nbsp;becomes&nbsp;<code>&lt;= 1</code>.</div></li><li><div>Update the variable&nbsp;<code>longestWindow</code>&nbsp;with the current window length, i.e.&nbsp;<code>i - start</code>. Note that this subtraction will give the number of elements in the window minus&nbsp;<code>1</code>, as we need to delete one element too.</div></li><li><div>Return&nbsp;<code>longestWindow</code>.</div></li></ol>	"from typing import List<br><br>class Solution:<br>&nbsp;&nbsp;&nbsp; def longestSubarray(self, nums: List[int]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; best = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for right, v in enumerate(nums):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if v == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # shrink window until it contains ≤ 1 zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while zeroCount &gt; 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nums[left] == 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroCount -= 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left += 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # delete exactly one element (the single 0 if present,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # otherwise any element) → length is right‑left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; best = max(best, right - left)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return best&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # O(n) time, O(1) extra space"	"<div>Here,&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">N</span></span>&nbsp;is the size of the array&nbsp;<code>nums</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span></div><div>Each element in the array will be iterated over twice at most. Each element will be iterated over for the first time in the for loop; then, it might be possible to re-iterate while shrinking the window in the while loop. No element can be iterated more than twice. Therefore, the total time complexity would be&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">N</span>)</span>.</div></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span></div><div>Apart from the three variables, we don't need any extra space; hence the total space complexity is constant.</div></li></ul>"
Equal Row and Column Pairs	Medium		HashTable	<ol><li><div>Create an empty hash map&nbsp;<code>row_counter</code>&nbsp;and set&nbsp;<code>count</code>&nbsp;to 0.</div></li><li><div>For each row&nbsp;<code>row</code>&nbsp;in the grid, convert it into an equivalent hashable object and use it as a key to the&nbsp;<code>row_counter</code>. Increment the value of the corresponding key by 1.</div></li><li><div>For each column in the grid, convert it into the same type of hashable object and check if it appears in the&nbsp;<code>row_counter</code>. If it does, increment&nbsp;<code>count</code>&nbsp;by the frequency.</div></li><li><div>Return the answer&nbsp;<code>count</code>.</div></li></ol>	"class Solution:<br>&nbsp;&nbsp;&nbsp; def equalPairs(self, grid: List[List[int]]) -&gt; int:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = len(grid)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Keep track of the frequency of each row.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row_counter = collections.Counter(tuple(row) for row in grid)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Add up the frequency of each column in map.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for c in range(n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col = [grid[i][c] for i in range(n)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += row_counter[tuple(col)]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return count"	"<div>Let&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span>×<span style=""font-style: italic;"">n</span></span>&nbsp;be the size of&nbsp;<code>grid</code>.</div><ul><li><div>Time complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n^</span>2)</span></div><ul><li>We iterate over each row and column only once, converting one array of length&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;into a hashable object takes&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n</span>)</span>&nbsp;time.</li><li>Operations like adding or checking on hash map take&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(1)</span>&nbsp;time.</li></ul></li><li><div>Space complexity:&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">O</span>(<span style=""font-style: italic;"">n^</span>2)</span></div><ul><li>We store each row of the grid in the hash map, in the worst-case scenario,&nbsp;<code>row_counter</code>&nbsp;might contains&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>&nbsp;distinct rows of length&nbsp;<span style=""color: rgba(38, 38, 38, 0.75);""><span style=""font-style: italic;"">n</span></span>.</li></ul></li></ul>"
