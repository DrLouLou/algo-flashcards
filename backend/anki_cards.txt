#separator:tab
#html:false
Basic Calculator II	Medium	Stack		Iterate through the string:Read one character at a time.Build numbers from digits (e.g., 2, 34, etc.).When encountering an operator or the end of the string, process the number and the last operator. Use a Stack:The stack stores intermediate results so we can handle operator precedence properly.For + and -, push the number directly onto the stack (positive or negative).For * and /, pop the last number from the stack, perform the operation, and push the result back. At the End:Add all numbers in the stack to get the final result.	"def calculate(s: str) -> int:     stack = []    current_number = 0    operation = '+'     for i, c in enumerate(s):        if c.isdigit():           current_number = current_number * 10 + int(c)        if c in ""+-*/"" or i == len(s) - 1:           if operation == '+':              stack.append(current_number)           elif operation == '-':              stack.append(-current_number)           elif operation == '*':              stack.append(stack.pop() * current_number)           elif operation == '/':              stack.append(int(stack.pop() / current_number))           operation = c           current_number = 0     return sum(stack)"	O(N) time O(1) space
LRU Cache	Medium		use OrderedDict()	use OrderedDict() to keep the most recently used values at the end of the dict. use the move_to_end(last=____) function to do this. When you add an element to the dict, if it's already in there move it to the end and then check whether capacity is maintained. to pop the first item use: dict.popitem(last = False)	"class LRUCache:     def __init__(self, capacity: int):       self.cache = OrderedDict()       self.capacity = capacity     def get(self, key: int) -> int:       if key not in self.cache: return -1       self.cache.move_to_end(key)       return self.cache.get(key)     def put(self, key: int, value: int) -> None:       if key in self.cache:          self.cache.move_to_end(key)       self.cache[key] = value       # this preserves the most recent elements being at the end       if len(self.cache) > self.capacity:          self.cache.popitem(last=False)       return"	O(N) space  O(1) time
Find the Length of the Longest Common Prefix	Medium	Arrays/Strings	use a set	Put all the possible prefixes of each element in arr1 into a HashSet. For all the possible prefixes of each element in arr2, check if it exists in the HashSet. Find the max of the prefixes that exist in the set and arr2	def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:     prefix_set = set()     for num in arr1:        for j in range(len(str(num))):          prefix_set.add(str(num)[:j+1])      max_prefix_length = 0     for num in arr2:       num_str = str(num)       for i in range(1, len(num_str) + 1):          if num_str[:i] in prefix_set:             max_prefix_length = max(max_prefix_length, i)          else:             break     return max_prefix_length	O((arr1.length+arr2.length)×log10​(max_value)) time
Decode Ways	Medium	DP	think decision tree	do recursive method (think of a decision tree) and then wrap with dp hashmap. initialize dp hasmap with len(s): 1 and update the map whenver you calculate a result	"def numDecodings(self, s: str) -> int:         dp = {len(s) : 1}          def dfs(i):             if i in dp:                 return dp[i]             if s[i] == ""0"":                 return 0              res = dfs(i + 1)             if i + 1 < len(s) and (                 s[i] == ""1"" or s[i] == ""2"" and                 s[i + 1] in ""0123456""             ):                 res += dfs(i + 2)             dp[i] = res             return res          return dfs(0)"	O(N) space O(N) time
Maximum Subarray	Medium	Sliding Window		The Intuition behind the code is to find the maximum sum of a contiguous subarray within the given array nums. It does this by scanning through the array and keeping track of the current sum of the subarray. Whenever the current sum becomes greater than the maximum sum encountered so far, it updates the maximum sum. If the current sum becomes negative, it resets the sum to 0 and starts a new subarray. By the end of the loop, the code returns the maximum sum found.	def maxSubArray(self, nums: List[int]) -> int:    largestSum = nums[0]    currentSum = nums[0]      for j in range(1, len(nums)):       currentSum = max(nums[j], currentSum + nums[j])       largestSum = max(largestSum, currentSum)       return largestSum	
Flatten Nested List Iterator	Medium		Stack	In this all-in-one-go approach we use an array to store the results of our flattened array The NestedIterator class is initialized with a nested list of NestedInteger objects. In the constructor (__init__), an empty stack is created to store the extracted integers. The helper function dfs (Depth-First Search) is called to process the nested list and extract all integers in a flattened order. The DFS function recursively checks each element in the list: if the element is an integer, it is appended to the stack; if the element is a nested list, the function is called recursively to handle deeper levels of nesting. Once the nested structure is fully traversed and all integers are stored in the stack, the next() method simply returns the first element of the stack using pop(0), ensuring elements are processed in order. The hasNext() method checks if there are any elements left in the stack, returning True if integers remain, or False if all elements have been consumed.	"# """""" # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation. # """""" # class NestedInteger: #     def isInteger(self) -> bool: #         """""" #         @return True if this NestedInteger holds a single integer, rather than a nested list. #         """""" # #     def getInteger(self) -> int: #         """""" #         @return the single integer that this NestedInteger holds, if it holds a single integer. #         Return None if this NestedInteger holds a nested list. #         """""" # #     def getList(self) -> [NestedInteger]: #         """""" #         @return the nested list that this NestedInteger holds, if it holds a nested list. #         Return None if this NestedInteger holds a single integer. #         """"""  class NestedIterator:     def __init__(self, nestedList: [NestedInteger]):         """"""         Initializes the iterator with the given nested list.         """"""         self.stack = []         self.dfs(nestedList)      def next(self) -> int:         """"""         Returns the next integer in the flattened nested list.         """"""         return self.stack.pop(0)      def hasNext(self) -> bool:         """"""         Returns True if there are still integers to be returned; otherwise, False.         """"""         return len(self.stack) > 0      def dfs(self, nestedList):         """"""         Helper function to flatten the nested list using depth-first search (DFS).         """"""         for nested in nestedList:             if nested.isInteger():                 self.stack.append(nested.getInteger())             else:                 self.dfs(nested.getList())   # Example usage: # i, v = NestedIterator(nestedList), [] # while i.hasNext(): #     v.append(i.next())"	O(1) time for each of the functionsO(D) space where D is the max depth of the input array
Contains Duplicate	Easy		Hashset	Put numbers in a hashset as you iterate check the set as you iterate. if the num is in the set then there's a duplicate	def hasDuplicate(self, nums: List[int]) -> bool:         seen = set()         for num in nums:             if num in seen:                 return True             seen.add(num)         return False	Time complexity: O(n)Space complexity: O(n)
Group Anagrams	Medium		Hashtable	use defaultdict for ease. loop through the strings and sort. then hash into the table using the sorted string and append to that list	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:         res = defaultdict(list)         for s in strs:             sortedS = ''.join(sorted(s))             res[sortedS].append(s)         return list(res.values())	Time complexity: 𝑂(𝑚∗𝑛log⁡𝑛)Space complexity: 𝑂(𝑚∗𝑛)
Top K Frequent Elements	Medium		hashset	use hashset to count frequency of elements create a frequency array that indexes using count and puts the num at the right count position (this means that the most frequent numbers will end up at the end of this array) start at the end of this array and loop in reverse, returning the k most frequent	def topKFrequent(self, nums: List[int], k: int) -> List[int]:         count = {}         freq = [[] for i in range(len(nums) + 1)]          for num in nums:             count[num] = 1 + count.get(num, 0)         for num, cnt in count.items():             freq[cnt].append(num)                  res = []         for i in range(len(freq) - 1, 0, -1):             for num in freq[i]:                 res.append(num)                 if len(res) == k:                     return res	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Encode and Decode Strings	Medium			"to encode: join the strings so that they have the length of the next word to decode and then a delimiter e.g. [""neet"",""code"",""love"",""you""] becomes ""4#neet4#code4#love3#you"" to decode: use the numbers to work out how many characters the next word is"	"class Solution:          def encode(self, strs: List[str]) -> str:         res = """"         for s in strs:             res += str(len(s)) + ""#"" + s         return res      def decode(self, s: str) -> List[str]:         res = []         i = 0                  while i < len(s):             j = i             while s[j] != '#':                 j += 1             length = int(s[i:j])             i = j + 1             j = i + length             res.append(s[i:j])             i = j                      return res"	Time complexity: O(m) for encode() and decode().Space complexity: O(1) for encode() and decode().
Products of Array Except Self	Medium		store the results of repeated work in an array	loop through to calculate total product and count number of 0s.  if there is more than one zero then the whole return array must be 0. else loop through the numbers again and divide total product by that number if you come across a single 0 value, put the total product	def productExceptSelf(self, nums: List[int]) -> List[int]:         prod, zero_cnt = 1, 0         for num in nums:             if num:                 prod *= num             else:                 zero_cnt +=  1         if zero_cnt > 1: return [0] * len(nums)          res = [0] * len(nums)         for i, c in enumerate(nums):             if zero_cnt: res[i] = 0 if c else prod             else: res[i] = prod // c         return res	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(1)
Valid Sudoku	Medium		use hashset	loop through each row, col and square and make a seen set for each. Check if there are any repeated values	"class Solution:     def isValidSudoku(self, board: List[List[str]]) -> bool:         for row in range(9):             seen = set()             for i in range(9):                 if board[row][i] == ""."":                      continue                 if board[row][i] in seen:                     return False                 seen.add(board[row][i])                  for col in range(9):             seen = set()             for i in range(9):                 if board[i][col] == ""."":                     continue                 if board[i][col] in seen:                     return False                 seen.add(board[i][col])                      for square in range(9):             seen = set()             for i in range(3):                 for j in range(3):                     row = (square//3) * 3 + i                     col = (square % 3) * 3 + j                     if board[row][col] == ""."":                         continue                     if board[row][col] in seen:                         return False                     seen.add(board[row][col])         return True"	Time complexity: 𝑂(𝑛^2)Space complexity: 𝑂(𝑛^2)
Longest Consecutive Sequence	Medium		hashset	use hashset to track seen numbers loop through nums: if you come across a number for which you haven't seen the previous, check how many subsequent numbers are in the set keep track of the longest number of consecutive numbers you find.	class Solution:     def longestConsecutive(self, nums: List[int]) -> int:         numSet = set(nums)         longest = 0          for num in numSet:             if (num - 1) not in numSet:                 length = 1                 while (num + length) in numSet:                     length += 1                 longest = max(length, longest)         return longest	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Two Integer Sum II	Medium		is the input sorted? now what?	iterate through nums and do binary search to find second num. Only need to look forward in binary search	"class Solution:     def twoSum(self, numbers: List[int], target: int) -> List[int]:         for i in range(len(numbers)):             l, r = i + 1, len(numbers) - 1             tmp = target - numbers[i]             while l <= r:                 mid = l + (r - l)//2                 if numbers[mid] == tmp:                     return [i + 1, mid + 1]                 elif numbers[mid] < tmp:                     l = mid + 1                 else:                     r = mid - 1         return []    better solution:  class Solution:     def twoSum(self, numbers: List[int], target: int) -> List[int]:         low = 0         high = len(numbers) - 1         while low < high:             sum = numbers[low] + numbers[high]              if sum == target:                 return [low + 1, high + 1]             elif sum < target:                 low += 1             else:                 high -= 1         # In case there is no solution, return [-1, -1].         return [-1, -1]"	Time complexity: 𝑂(𝑛log⁡𝑛)Space complexity: 𝑂(1)
3Sum	Medium		binary search	loop and do binary search	class Solution:     def threeSum(self, nums: List[int]) -> List[List[int]]:         res = []         nums.sort()          for i, a in enumerate(nums):             if a > 0:                 break              if i > 0 and a == nums[i - 1]:                 continue              l, r = i + 1, len(nums) - 1             while l < r:                 threeSum = a + nums[l] + nums[r]                 if threeSum > 0:                     r -= 1                 elif threeSum < 0:                     l += 1                 else:                     res.append([a, nums[l], nums[r]])                     l += 1                     r -= 1                     while nums[l] == nums[l - 1] and l < r:                         l += 1                                  return res	
Container With Most Water	Medium		two pointer	first put pointers at start and end index  calculate area and keep track of max area continually move smaller bar inwards	class Solution:     def maxArea(self, heights: List[int]) -> int:         l, r = 0, len(heights) - 1         res = 0          while l < r:             area = min(heights[l], heights[r]) * (r - l)             res = max(res, area)             if heights[l] <= heights[r]:                 l += 1             else:                 r -= 1         return res	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(1)
Valid Parentheses	Easy		stack	create close to open dict loop through the chars, if it's an open bracket, append to stack if it's a close bracket and the stack exists, check it equals the last item on stack. if so, pop it	"class Solution:     def isValid(self, s: str) -> bool:         stack = []         closeToOpen = { "")"" : ""("", ""]"" : ""["", ""}"" : ""{"" }          for c in s:             if c in closeToOpen:                 if stack and stack[-1] == closeToOpen[c]:                     stack.pop()                 else:                     return False             else:                 stack.append(c)                  return True if not stack else False"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Minimum Stack	Medium		maintain a stack and minstack	maintain a minstack as well as the main stack. this way you can always have the minimum value on hand. keep in mind when you push, this means you have to compare the most recent value of the min stack and whether it's more or less than the number you're adding in.	class MinStack:     def __init__(self):         self.stack = []         self.minStack = []      def push(self, val: int) -> None:         self.stack.append(val)         val = min(val, self.minStack[-1] if self.minStack else val)         self.minStack.append(val)      def pop(self) -> None:         self.stack.pop()         self.minStack.pop()      def top(self) -> int:         return self.stack[-1]      def getMin(self) -> int:         return self.minStack[-1]	Time complexity: 𝑂(1)Space complexity: 𝑂(𝑛)
Evaluate Reverse Polish Notation	Medium		stack	if it's a number then append to the stack if it's an operator then pop the last two elements off the stack and do the necessary operation and then append that result to the stack. then return the last value on the stack	"class Solution:     def evalRPN(self, tokens: List[str]) -> int:         stack = []         for c in tokens:             if c == ""+"":                 stack.append(stack.pop() + stack.pop())             elif c == ""-"":                 a, b = stack.pop(), stack.pop()                 stack.append(b - a)             elif c == ""*"":                 stack.append(stack.pop() * stack.pop())             elif c == ""/"":                 a, b = stack.pop(), stack.pop()                 stack.append(int(float(b) / a))             else:                 stack.append(int(c))         return stack[0]"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Daily Temperatures	Medium		monotonic decreasing stack	The stack is used to keep track of temperatures that have not yet found a warmer day.For each temperature, the code checks if it is warmer than the temperature on the top of the stack (most recent unprocessed temperature).While the stack is not empty and the current temperature (t) is greater than the temperature at the top of the stack (stack[-1][0]):It means we have found the next warmer day for the temperature at stackInd.   - use the current temp to resolve previous temps saved in the stack. The temperatures in the  - stack have not have been resolved yet and they must necessarily be decreasing, otherwise  - some of them would be resolved. So, use the current temp to resolve as many on the stack as - possible.	"class Solution:     def dailyTemperatures(self, temperatures: List[int]) -> List[int]:         res = [0] * len(temperatures)         stack = []  # pair: [temp, index]          for i, t in enumerate(temperatures):             while stack and t > stack[-1][0]:                 stackT, stackInd = stack.pop()                 res[stackInd] = i - stackInd             stack.append((t, i))         return res"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Car Fleet	Medium		stack	zip the two arrays together to make pairs reverse the array of pairs iterate through the array and for each pair, append the time until the end for that car to the stack every time you add to the stack, check if there's an existing value on the top of the stack (where existing values are going to represent cars that are closer in terms of distance to the end). if the value you're adding is lower than or equal to the value at the top of the stack, that means you have a car that is further away from the end but will take an equal amount of time or less to get there... so they will form a fleet, so pop that value you just added rather than the one that existing one. return the length of the stack	"class Solution:     def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:         pair = [(p, s) for p, s in zip(position, speed)]         pair.sort(reverse=True)         stack = []         for p, s in pair:  # Reverse Sorted Order             stack.append((target - p) / s)             if len(stack) >= 2 and stack[-1] <= stack[-2]:                 stack.pop()         return len(stack)"	Time complexity: 𝑂(𝑛log⁡𝑛)Space complexity: 𝑂(𝑛)
Search a 2D Matrix	Medium		Treat the 2D array like it's a 1D array and do a Binary Search (because it's sorted)	l is the leftmost index (0), representing the first element in the matrix.r is the rightmost index (ROWS * COLS - 1), representing the last element in the matrix.Midpoint (m): The middle index of the current search range.Convert the 1D midpoint m into 2D coordinates using:row=𝑚//COLSrow=m//COLS (integer division).col=𝑚%COLScol=m%COLS (remainder).Compare the target with the matrix element at matrix[row][col]matrix[row][col]:If target is greater, search the right half by moving l to 𝑚+1m+1.If target is smaller, search the left half by moving r to 𝑚−1m−1.If target is equal, return True.	class Solution:     def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:         ROWS, COLS = len(matrix), len(matrix[0])          l, r = 0, ROWS * COLS - 1         while l <= r:             m = l + (r - l) // 2             row, col = m // COLS, m % COLS             if target > matrix[row][col]:                 l = m + 1             elif target < matrix[row][col]:                 r = m - 1             else:                 return True         return False	Time complexity: 𝑂(log⁡(𝑚∗𝑛))Space complexity: 𝑂(1)
Koko Eating Bananas	Medium		Binary Search The maximum eating speed, k, is going to be max(piles) The minimum eating speed is going to be 1. So do a binary search from 1 to max(piles)	When a valid k is found, the algorithm doesn't stop immediately. Instead, it continues to explore smaller values (𝑟=𝑘−1) to see if a smaller k also works.This ensures that the algorithm finds the smallest valid k before exiting.	class Solution:     def minEatingSpeed(self, piles: List[int], h: int) -> int:         l, r = 1, max(piles)         res = r          while l <= r:             k = (l + r) // 2              totalTime = 0             for p in piles:                 totalTime += math.ceil(float(p) / k)             if totalTime <= h:                 res = k                 r = k - 1             else:                 l = k + 1         return res	Time complexity: 𝑂(𝑛∗log⁡𝑚)Space complexity: 𝑂(1)
Find Minimum in Rotated Sorted Array	Medium		Binary search	use res to keep track of the minimum found so far if the array is rotated, the array will have two sorted portions and the minimum element will be the first element in the right portion. use binary search to find the switching point of the array res is initialized to the first element of the array (nums[0]). It keeps track of the minimum value found so far.If the subarray between l and r is sorted (nums[l] < nums[r]), the smallest element is at nums[l].Update res to the smaller value between res and nums[l].Exit the loop early since there’s no need to search further.m is the middle index of the current search window.Update res to the smaller value between res and nums[m].If the value at nums[m] is greater than or equal to nums[l], the left half is sorted, so the minimum must be in the right half. Move the left pointer: l = m + 1.Otherwise, the right half is unsorted, so the minimum must be in the left half. Move the right pointer: r = m - 1.return res outside the loop	class Solution:     def findMin(self, nums: List[int]) -> int:         res = nums[0]         l, r = 0, len(nums) - 1          while l <= r:             if nums[l] < nums[r]:                 res = min(res, nums[l])                 break                          m = (l + r) // 2             res = min(res, nums[m])             if nums[m] >= nums[l]:                 l = m + 1             else:                 r = m - 1         return res	Time complexity: 𝑂(log⁡𝑛)Space complexity: 𝑂(1)
Search in Rotated Sorted Array	Medium		binary search	the rotated array creates two sorted portions  Identify which portion is sorted:If nums[m] >= nums[l], the left portion is sorted.Otherwise, the right portion is sorted. Check if the target lies within the sorted portion:For the left portion: nums[l] <= target < nums[m].For the right portion: nums[m] < target <= nums[r]. Update pointers accordingly:Narrow down the search space based on whether the target is in the sorted or unsorted portion.	class Solution:     def search(self, nums: List[int], target: int) -> int:         l, r = 0, len(nums) - 1          while l <= r:             mid = (l + r) // 2             if target == nums[mid]:                 return mid              if nums[l] <= nums[mid]:                 if nums[l] <= target < nums[mid]:                     r = mid - 1                 else:                     l = mid + 1                                  else:                 if nums[m] < target <= nums[r]:                     l = mid + 1                 else:                     r = mid - 1         return -1	Time complexity: 𝑂(log⁡𝑛)Space complexity: 𝑂(1)
Time Based Key Value Store	Medium		Binary Search	"Notice these types of binary search problem where you aren't necessarily looking for an exact value but a value that most satisfies a condition. In these instances, we keep a running result that we update over time. Because our window is moving in the correct direction, so too will our result. And when the window correctly narrows down to a single value, so too will the result.  In this problem, the values are being set with increasing timestamps, so within each key the tuples are sorted according to timestamp. So we do a binary search to find the timestamp given, or if it does not exist we find the closest previous timestamp. If there's no key exists or there's no previous timestamp, we return """".  As mentioned above, even if we don't find the exact timestamp, we want to find the largest previous timestamp, so if the current mid value is smaller than the timestamp, then we want to move our window right, because either the exact timestamp is right, or there is no exact timestamp but we want to see if there is a larger timestamp that is still <= timestamp given."	"from collections import defaultdict  class TimeMap:      def __init__(self):         # value is a tuple of value given and timestamp         self.dict = defaultdict(list)      def set(self, key: str, value: str, timestamp: int) -> None:         self.dict[key].append((value, timestamp))      def get(self, key: str, timestamp: int) -> str:         # Binary search to find the timestamp or the most recent timestamp         if key not in self.dict:             return """"         vals = self.dict[key]         res = """"         l, r = 0, len(vals) - 1         while l <= r:             m = (l + r) // 2             if vals[m][1] == timestamp:                 return vals[m][0]             elif vals[m][1] < timestamp:                 res = vals[m][0]                 l = m + 1             else:                 r = m - 1         return res"	Time complexity: 𝑂(1) for set() and O(logn) for get().Space complexity:(m∗n)
Reverse Linked List	Easy		set prev=None and curr=head	set prev = None and curr = head  while curr: make a tmp pointer to curr.next and set curr.next equal to prev return prev	"# Definition for singly-linked list. # class ListNode: #     def __init__(self, val=0, next=None): #         self.val = val #         self.next = next  class Solution:     def reverseList(self, head: ListNode) -> ListNode:         prev, curr = None, head          while curr:             temp = curr.next             curr.next = prev             prev = curr             curr = temp         return prev"	Time complexity: O(n)Space complexity: O(1)
Merge Two Sorted LinkedLists	Easy		Use a dummy node at the start	Dummy Node:A dummy node is used as a starting point for the merged list. This simplifies the logic since you don't need special handling for the head of the merged list. Current Pointer:current keeps track of the last node in the merged list as you iterate through list1 and list2. Remaining Nodes:After exiting the while loop, either list1 or list2 may still have remaining nodes. These nodes are directly attached to the merged list. Returning the Result:The merged list starts at dummy.next since dummy is a placeholder node.	"# Definition for singly-linked list. # class ListNode: #     def __init__(self, val=0, next=None): #         self.val = val #         self.next = next  class Solution:     def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:         # Dummy node to start the merged list         dummy = ListNode()         current = dummy          # Merge the two lists         while list1 and list2:             if list1.val <= list2.val:                 current.next = list1                 list1 = list1.next             else:                 current.next = list2                 list2 = list2.next             current = current.next          # Attach the remaining nodes         if list1:             current.next = list1         if list2:             current.next = list2          # Return the merged list starting from the next node of dummy         return dummy.next"	Time complexity: 𝑂(𝑛+𝑚)Space complexity: 𝑂(1)
Invert Binary Tree	Easy		DFS	flip the two children and then call invert on them	"# Definition for a binary tree node. # class TreeNode: #     def __init__(self, val=0, left=None, right=None): #         self.val = val #         self.left = left #         self.right = right  class Solution:     def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:         if not root: return None          root.left, root.right = root.right, root.left                  self.invertTree(root.left)         self.invertTree(root.right)                  return root"	Time complexity: O(n)Space complexity: O(n)
Maximum Depth of Binary Tree	Easy		recursion	in each call, return 1 + maxDepth of left or right subtree	"# Definition for a binary tree node. # class TreeNode: #     def __init__(self, val=0, left=None, right=None): #         self.val = val #         self.left = left #         self.right = right  class Solution:     def maxDepth(self, root: Optional[TreeNode]) -> int:         if not root:             return 0          return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"	Time complexity: O(n)Space complexity: O(n)
Diameter of Binary Tree	Easy		dfs function	The key observation to make is:the longest path has to be between two leaf nodes. We can prove this with contradiction. Imagine that we have found the longest path, and it isnotbetween two leaf nodes. We can extend that path by 1, by adding the child node of one of the end nodes (as at least one must have a child, given that they aren't both leaves). This contradicts the fact that our path is the longest path. Therefore, the longest path must be between two leaf nodes. Moreover, we know that in a tree, nodes are only connected with their parent node and 2 children. Therefore we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized. This would hint at us to apply Depth-first search (DFS) to count each node's branch lengths, because it would allow us to dive deep into the leaves first, and then start counting the edges upwards. DFS is a widely-used graph traversal algorithm. If you are not familiar with it, feel free to visit ourExplore Cardswhere you will see different ways to traverse a binary tree with DFS including preorder, inorder, postorder :) Let's try to be more specific about how to apply DFS to this question. To count the lengths of each node's left and right branches, we can implement a recursion functionlongestPathwhich takes aTreeNodeas input and returns the longest path from it to the leaf node. It will recursively visit children nodes and retrieve the longest paths from them to the leaf first, and then add1to the longer one before returning it as the longest path. In the midst of DFS, we also need to take the following two cases into account:the current node's both left and right branches might be a part of the longest path;one of the current node's left/right branches might be a part of the longest path.  Figure 1. Two cases of the longest path. You will see we are going to address them by 1) applying DFS to recursively find the longest branches starting with the node's left and right children; 2) initializing a global variablediameterto keep track of the longest path and updating it at each node with the sum of the node's left and right branches; 3) returning the length of the longest branch between a node's left and right branches. AlgorithmInitalize an integer variablediameterto keep track of the longest path we find from the DFS.Implement a recursive functionlongestPathwhich takes aTreeNodeas input. It should recursively explore the entire tree rooted at the given node. Once it's finished, it should return the longest path out of its left and right branches:ifnodeisNone, we have reached the end of the tree, hence we should return0;we want to recursively explorenode's children, so we calllongestPathagain withnode's left and right children. In return, we get the longest path of its left and right childrenleftPathandrightPath;ifleftPathplusrightPathis longer than the current longest diameter found, then we need to updatediameter;finally, we return the longer one ofleftPathandrightPath. Remember to add1as the edge connecting it with its parent.CalllongestPathwithroot.	"# Definition for a binary tree node. # class TreeNode: #     def __init__(self, val=0, left=None, right=None): #         self.val = val #         self.left = left #         self.right = right  class Solution:     def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:         res = 0          def dfs(root):             nonlocal res              if not root:                 return 0             left = dfs(root.left)             right = dfs(root.right)             res = max(res, left + right)              return 1 + max(left, right)          dfs(root)         return res"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Level Order Traversal	Medium		deque	whlie q, iterate the through the queue adding nodes to the current level and adding the neighbours to the queue.	"# Definition for a binary tree node. # class TreeNode: #     def __init__(self, val=0, left=None, right=None): #         self.val = val #         self.left = left #         self.right = right  class Solution:     def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:         res = []          q = collections.deque()         q.append(root)          while q:             qLen = len(q)             level = []             for i in range(qLen):                 node = q.popleft()                 if node:                     level.append(node.val)                     q.append(node.left)                     q.append(node.right)             if level:                 res.append(level)                          return res"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑛)
Matrix Depth First Search	Medium		dfs and visit set	use a helper function and set to track vitisted nodes and from that node try all combinations of movements	class Solution:     def countPaths(self, grid: List[List[int]]) -> int:         ROWS, COLS = len(grid), len(grid[0])          def helper(grid: List[List[int]], r: int, c: int, visit: set) -> int:             if (min(r, c) < 0 or                 r == ROWS or c == COLS or                 (r, c) in visit or grid[r][c] == 1):                 return 0             if r == ROWS - 1 and c == COLS - 1:                 return 1              visit.add((r, c))              count = 0             count += helper(grid, r + 1, c, visit)             count += helper(grid, r - 1, c, visit)             count += helper(grid, r, c + 1, visit)             count += helper(grid, r, c - 1, visit)              visit.remove((r, c))             return count          return helper(grid, 0, 0, set())	Time Complexity: 𝑂(4^𝑚⋅𝑛) in the theoretical worst case; pruned significantly by constraints.Space Complexity: 𝑂(𝑚⋅𝑛).
Number of Islands	Medium		find number of connected components	find number of connected components. this means you have to loop over all of the 1s and see if they are not in visited. If this is the case, you want to increase count by one and dfs from that 1 to find all the ones connected to it and mark them all as visited.  return the count at the end. your helper dfs function should check the indices are in bound and then check if they have been visited before.	"from typing import List  class Solution:     def numIslands(self, grid: List[List[str]]) -> int:         ROWS, COLS = len(grid), len(grid[0])         visited = set()         count = 0          def dfs(r, c):             # Check bounds first to avoid IndexError             if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == '0' or (r, c) in visited:                 return             visited.add((r, c))             # Explore neighbors             dfs(r - 1, c)  # Up             dfs(r + 1, c)  # Down             dfs(r, c - 1)  # Left             dfs(r, c + 1)  # Right          for r in range(ROWS):             for c in range(COLS):                 if (r, c) not in visited and grid[r][c] == '1':                     count += 1  # Start of a new island                     dfs(r, c)          return count"	Time complexity: 𝑂(𝑚∗𝑛)Space complexity: 𝑂(𝑚∗𝑛)
Max Area of Island	Medium		similar to number of islands except here when we explore an island, we count up its area	we first loop through all the 1s and see if they are visited. if so, it means we have already explored them as part of a previous island. if not, we perform a dfs on it, counting up the nodes as we go and adding them to visited. Once we have calculated the area of an island, we record whether its bigger than the maximum. return maximum at the end.	"class Solution:     def maxAreaOfIsland(self, grid: List[List[int]]) -> int:         ROWS, COLS = len(grid), len(grid[0])         visited = set()         maxArea = 0          def dfs(r, c):             # Base case: Out of bounds, water, or already visited             if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == 0 or (r, c) in visited:                 return 0             # Mark the cell as visited             visited.add((r, c))             # Calculate the area recursively             area = 1             area += dfs(r + 1, c)  # Down             area += dfs(r - 1, c)  # Up             area += dfs(r, c + 1)  # Right             area += dfs(r, c - 1)  # Left             return area          # Iterate through the grid         for r in range(ROWS):             for c in range(COLS):                 if (r, c) not in visited and grid[r][c] == 1:                     # Calculate area of the island starting from (r, c)                     A = dfs(r, c)                     maxArea = max(maxArea, A)          return maxArea"	Time complexity: 𝑂(𝑚∗𝑛)Space complexity: 𝑂(𝑚∗𝑛)
Python Asynchronous Scraper	Medium	interview	define fetch function that takes a session and gets the url and returns the response define main function that creates the session and creates a list of tasks where each task is a fetch to a url. gather the tasks and save the htmls. then print		"import aiohttp import asyncio import time  async def fetch_page(session, url):     """"""Fetch the content of a page asynchronously.""""""     async with session.get(url) as response:         return await response.text()  async def main():     """"""Main function to fetch multiple pages concurrently.""""""     urls = [         ""https://www.scrapingcourse.com/ecommerce/"",         ""https://www.scrapingcourse.com/ecommerce/page/2/"",         ""https://www.scrapingcourse.com/ecommerce/page/3/"",     ]         async with aiohttp.ClientSession() as session:         tasks = [fetch_page(session, url) for url in urls]         htmls = await asyncio.gather(*tasks)      for url, html in zip(urls, htmls):         print(f""URL: {url}, Content: {html[:100]}..."")  # Print first 100 characters of content  asyncio.run(main())"	
Matrix Breadth-First Search	Medium		use queue and maintain length at each distance level away from starting node		class Solution:     def shortestPath(self, grid: List[List[int]]) -> int:         ROWS, COLS = len(grid), len(grid[0])         visit = set()         queue = deque()         queue.append((0, 0))         visit.add((0, 0))          length = 0         while queue:             for i in range(len(queue)):                 r, c = queue.popleft()                 if r == ROWS - 1 and c == COLS - 1:                     return length                  neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]                 for dr, dc in neighbors:                     if (min(r + dr, c + dc) < 0 or                         r + dr == ROWS or c + dc == COLS or                         (r + dr, c + dc) in visit or grid[r + dr][c + dc] == 1):                         continue                     queue.append((r + dr, c + dc))                     visit.add((r + dr, c + dc))             length += 1         return -1	Time Complexity:Each cell is visited once, and each edge is processed once.For an m×n grid, this gives O(m×n). Space Complexity:The queue and visited set store at most 𝑂(𝑚×𝑛)O(m×n) elements.Overall space complexity is O(m×n).
Rotten Fruit	Medium		Binary Search with matrix and various extra conditions	we don't need a queue in this one because we can just change the grid cell from a 1 to a 2 when we pop it. the general idea with this one is to loop through the whole grid and add all the rotting fruit to the queue.  then do a multisource bfs from the rotten fruits and see how long it takes for the whole grid to be rotten, if possible. when we loop through the first time, we should also count the number of fresh fruit. this way when we find a fresh fruit and turn it to a rotten fruit in the bfs later on, we can decrement the fresh fruit count. this means at the end we will know if all the fresh fruit have  been turned.  in the bfs, we want to remember to: avoid empty cells and cells with rotten fruitinclude the clause about freshCount > 0 in the while loopdecrement freshCount when we come across a fresh fruit and turn it rotten	"from collections import deque from typing import List  class Solution:     def orangesRotting(self, grid: List[List[int]]) -> int:         ROWS, COLS = len(grid), len(grid[0])         queue = deque()         freshCount = 0         minutes = 0          # Initialize queue with all rotten oranges and count fresh oranges         for r in range(ROWS):             for c in range(COLS):                 if grid[r][c] == 2:                     queue.append((r, c))                 elif grid[r][c] == 1:                     freshCount += 1          # Perform BFS         directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]         while queue and freshCount > 0:             for _ in range(len(queue)):                 r, c = queue.popleft()                 for dr, dc in directions:                     nr, nc = r + dr, c + dc                     # Check bounds and if the orange is fresh                     if 0 <= nr < ROWS and 0 <= nc < COLS and grid[nr][nc] == 1:                         grid[nr][nc] = 2  # Rot the orange                         queue.append((nr, nc))                         freshCount -= 1             minutes += 1  # Increment minutes after processing a level          # If there are fresh oranges left, return -1         return minutes if freshCount == 0 else -1"	Time complexity: O(m∗n)Space complexity: O(m∗n)
Happy Number	Easy		use a set	use a set to track numbers that you've come across before in the loop. if you've come across it before it means you're in an endless loop.	class Solution:     def isHappy(self, n: int) -> bool:         visit = set()          while n not in visit:             visit.add(n)             n = self.sumOfSquares(n)             if n == 1:                 return True         return False      def sumOfSquares(self, n: int) -> int:         output = 0          while n:             digit = n % 10             digit = digit ** 2             output += digit             n = n // 10         return output	Time complexity: 𝑂(log⁡𝑛)Space complexity: 𝑂(log⁡𝑛)
Best Time to Buy and Sell Stock	Easy		sliding window or dynamic programming	at each stage, we want to keep track of what the lowest is and then what the maximum increase is. so initialize both of these variables and iterate through prices once and update accordingly	"class Solution:     def maxProfit(self, prices: List[int]) -> int:         # Initialize the lowest price as the first price in the list         lowest = prices[0]         # Initialize the maximum profit to 0         maxIncrease = 0                  # Iterate through the prices starting from the second element         for price in prices[1:]:             # Update the lowest price seen so far             lowest = min(lowest, price)             # Calculate the potential profit and update the maximum profit             maxIncrease = max(maxIncrease, price - lowest)                  # Return the maximum profit         return maxIncrease"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(1)
Longest Substring Without Repeating Characters	Medium		sliding window/two pointer	keep track of chars seen using a set. iterate the right pointer over the chars and add to the set if you havent seen the char. check the max length of the set each you time you add to it if you have seen it, we need to remove the first occurence of that char and everything preceding it from seen so iterate the left pointer towards the right pointer until you find that first occurrence.	"class Solution:     def lengthOfLongestSubstring(self, s: str) -> int:         # Handle edge case for empty string         if len(s) == 0:             return 0                  # Initialize pointers and variables         l, r = 0, 0         longest = 0         seen = set()                  # Iterate through the string using the right pointer         while r < len(s):             if s[r] not in seen:                 # Add the character to the set and update the longest length                 seen.add(s[r])                 longest = max(longest, len(seen))                 r += 1             else:                 # Remove characters from the left until the duplicate is removed                 while l < r:                     if s[l] == s[r]:                         l += 1                         r += 1                         break                     else:                         seen.remove(s[l])                         l += 1                  return longest"	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑚) where n is the length and m is the number of unique characters
Longest Repeating Character Replacement	Medium		use a sliding window and a hashmap to maintain the most frequent character within the window.	this means as you iterate through the list, increase the count of the current char and save the max frequency, which could either be the previous maxf or the frequency of the char you just incremented. the number of other characters will be (r-l+1)-maxf because r-l+1 represents the length of the string and maxf is the most frequent char in the string. so then we check if the number of other characters in the string exceeds k. if it does, then we want to increment the left pointer by 1 and decrease its frequency in the map. what all this does is constantly maintain a valid window with respect to how many replacements you can make. this means that at the end of the iteration, you can check the maximum of the existing res and the current length of the window r-l+1.	class Solution:     def characterReplacement(self, s: str, k: int) -> int:         count = {}         res = 0                  l = 0         maxf = 0         for r in range(len(s)):             count[s[r]] = 1 + count.get(s[r], 0)             maxf = max(maxf, count[s[r]])              while (r - l + 1) - maxf > k:                 count[s[l]] -= 1                 l += 1             res = max(res, r - l + 1)          return res	Time complexity: 𝑂(𝑛)Space complexity: 𝑂(𝑚)
Permutation in String	Medium		hashmap to maintain frequency of window	create a freq map for both s1. then create a window the same size as s1 in s2 and the corresponding freq map for it and start shifting through s2, updating the frequencies  as you go. check at each iteration if the freq map for s1 is the same as the one for the sliding window for s2.	"from collections import Counter  class Solution:     def checkInclusion(self, s1: str, s2: str) -> bool:         # If s1 is longer than s2, permutation is not possible         if len(s1) > len(s2):             return False          # Initialize pointers and counters         l, r = 0, len(s1) - 1         countOne = Counter(s1)  # Frequency map of s1         countTwo = Counter(s2[:len(s1) - 1])  # Frequency map of first len(s1) - 1 characters in s2          # Sliding window loop         while r < len(s2):             # Include the rightmost character in the window             countTwo[s2[r]] = countTwo.get(s2[r], 0) + 1                          # Check if the current window matches the frequency map of s1             if countOne == countTwo:                 return True                          # Remove the leftmost character from the window             countTwo[s2[l]] -= 1             if countTwo[s2[l]] == 0:                 del countTwo[s2[l]]  # Clean up zero-count entries to maintain consistency                          # Move the window forward             l += 1             r += 1                  # If no permutation is found, return False         return False"	Time complexity: 𝑂(𝑛∗𝑚)Space complexity: 𝑂(1)
Clone Graph	Medium		dfs or bfs	we want to create a map that contains original nodes to copy nodes. this map ensures that we do not recurse infinitely as we can check in our base case whether a node  we have recursed to is already in the map. if it is, then we return the copy. then in each iteration we create a copy of the current node with the right value and then  assign as the value to the original node in the map. then we loop through all the neighbors and dfs those and append them to the neighbors of the copy. then return the copy.	""""""" # Definition for a Node. class Node:     def __init__(self, val = 0, neighbors = None):         self.val = val         self.neighbors = neighbors if neighbors is not None else [] """"""  class Solution:     def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:         oldToNew = {}          def dfs(node):             if node in oldToNew:                 return oldToNew[node]              copy = Node(node.val)             oldToNew[node] = copy             for nei in node.neighbors:                 copy.neighbors.append(dfs(nei))             return copy          return dfs(node) if node else None"	
Islands and Treasure	Medium		multi source bfs	we want to loop through and find the treasure chests. when we come across a treasure chest we perform a bfs from it. any land cell we come across starting from a particular treasure chest, we check if it has already been assigned a nearest distance from another chest. if the distance from the current chest is lower, then we assign the distance from the current chest to the land cell.  we also calculate the base cases and add to the visisted set as usual, making sure to avoid -1 cells which we can't cross and 0s.  we avoid the 0 cells because if we search through that 0, then any land cell we come across after that will be closer to that 0 cell rather than the 0 cell we started from. so we leave that to a future (or previous) bfs iteration. in this below solution, we set the value of the land cell equal to length + 1 because we are assigning it before we actually get to it. we know this because we  assign it in the neighbor for loop where we are looking at possible neighbors to the current cell.	"from collections import deque from typing import List  class Solution:     def islandsAndTreasure(self, grid: List[List[int]]) -> None:         # Dimensions of the grid         ROWS, COLS = len(grid), len(grid[0])                  def bfs(r, c):             queue = deque()             queue.append((r, c))             length = 0             visited = set()                          while queue:                 for i in range(len(queue)):                     r, c = queue.popleft()                     neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]]                                          for dr, dc in neighbors:                         nr, nc = r + dr, c + dc                                                  # Boundary and validity checks                         if (                             nr < 0 or nc < 0 or nr >= ROWS or nc >= COLS or                             (nr, nc) in visited or grid[nr][nc] == -1 or grid[nr][nc] == 0                         ):                             continue                                                  # Update grid distance if shorter path is found                         if length + 1 < grid[nr][nc] <= 2147483647:                             grid[nr][nc] = length + 1                                                  queue.append((nr, nc))                         visited.add((nr, nc))                                  # Increment distance for the next layer                 length += 1          # Perform BFS from each treasure chest         for r in range(ROWS):             for c in range(COLS):                 if grid[r][c] == 0:                     bfs(r, c)"	Time complexity: O(T∗V)Space complexity: O(T∗V) Where T is the number of chests and V is the number of cells in the grid.
Kth Largest Element in a Stream	Easy		Heap	Initializes nums as a min-heap using heapq.heapify(). A min-heap ensures that the smallest element is always at the root.Trims nums down to contain only the top k largest elements by repeatedly removing the smallest element (using heapq.heappop())with the add function:Adds the new number to the heap (heapq.heappush()).Checks if the heap size exceeds kkk. If so, removes the smallest element (ensuring the heap only contains the top kkk largest numbers).Returns the kkk-th largest number, which is the smallest element in the heap (self.minHeap[0]). Alternative Solution: this solution relies on the fact that if you want to return the kth largest number, then you should maintain the largest k numbers and return the smallest of them each time you add. Maintaining the largest k numbers means that whenever you get more than k numbers, you remove the smallest of them.	"class KthLargest:          def __init__(self, k: int, nums: List[int]):         self.minHeap, self.k = nums, k         heapq.heapify(self.minHeap)         while len(self.minHeap) > k:             heapq.heappop(self.minHeap)      def add(self, val: int) -> int:         heapq.heappush(self.minHeap, val)         if len(self.minHeap) > self.k:             heapq.heappop(self.minHeap)         return self.minHeap[0]   Alternative Solution: class KthLargest:     def __init__(self, k: int, nums: List[int]):         """"""Initialize the KthLargest object with a min-heap of size k.""""""         self.k = k  # Fixed the typo: 'ka' -> 'k'         self.heap = []         for num in nums:             self.add(num)  # Populate the heap using the add method      def add(self, val: int) -> int:         """"""Adds a new value and returns the kth largest element.""""""         heapq.heappush(self.heap, val)         if len(self.heap) > self.k:             heapq.heappop(self.heap)  # Maintain only k elements in the heap         return self.heap[0]  # The kth largest element (smallest in the heap)"	Time complexity: 𝑂(𝑚∗log⁡𝑘)Space complexity: 𝑂(𝑘) Where m is the number of calls made to 𝑎𝑑𝑑()
Last Stone Weight	Easy		Heap	Approach 1 found and removed the maximum stones inO(N)time, and added the new stone inO(1)time. Approach 2 inverted this, as finding and removing the maximum stones tookO(1)time, but adding the new stone tookO(N)time. In both cases, we're left with an overall time complexity ofO(N)per stone-smash turn. We want to find a solution that makes both removing the maximums, and adding a new stone,less than O(N). For this kind of maximum-maintenance, we use aMax-Heap, also known as aMax-Priority Queue. A Max-Heap is a data structure that can take items, and can remove and return the maximum, with both operations takingO(logN)time. It does this by maintaining the items in a special order (within the array), or as a balanced binary tree. We don't need to know these details though, almost all programming languages have a Heap data structure! Here is the pseudocode using a Heap.  define function last_stone_weight(stones):     heap = a new Max-Heap     add all stones to heap     while heap contains more than 1 stone:         heavy_stone_1 = remove max from heap         heavy_stone_2 = remove max from heap         if heavy_stone_1 is heavier than heavy_stone_2:             new_stone = heavy_stone_1 - heavy_stone_2             add new_stone to heap     if heap is empty:         return 0     return last stone on heap Algorithm While most programming languages have aHeap/ Priority Queuedata structure, some, such as Python and Java, only haveMin-Heap. Just as the name suggests, this is a Heap that instead of always returning the maximum item, it returns the minimum. There are two solutions to this problem:Multiply all numbers going into the heap by-1, and then multiply them by-1to restore them when they come out.Pass a comparator in (language-dependent).	"class Solution:     def lastStoneWeight(self, stones: List[int]) -> int:          # Make all the stones negative. We want to do this *in place*, to keep the         # space complexity of this algorithm at O(1). :-)         for i in range(len(stones)):             stones[i] *= -1          # Heapify all the stones.         heapq.heapify(stones)          # While there is more than one stone left, remove the two         # largest, smash them together, and insert the result         # back into the heap if it is non-zero.         while len(stones) > 1:             stone_1 = heapq.heappop(stones)             stone_2 = heapq.heappop(stones)             if stone_1 != stone_2:                 heapq.heappush(stones, stone_1 - stone_2)          # Check if there is a stone left to return. Convert it back         # to positive.         return -heapq.heappop(stones) if stones else 0"	Let N be thelength of stones. Time complexity: O(NlogN). Converting an array into a Heap takesO(N)time (it isn't actually sorting; it's putting them into an order that allows us to get the maximums, each inO(logN)time). Like before, the main loop iterates up toN−1times. This time however, it's doing up to threeO(logN)operations each time; two removes, and an optional add. Like always, the three is an ignored constant. This means that we're doingN⋅O(logN)=O(NlogN)operations. Space complexity :O(logN). In Python, converting a list to a heap is done in place, requiringO(1)auxiliary space, giving a total space complexity ofO(1). Modifying the input has its pros and cons; it saves space, but it means that other functions can't use the same array.
Pacific Atlantic Water Flow	Medium		dfs from the edges	- we perform a dfs from the edges directly connecting to the atlantic, pacific or both. - we create sets for pacific and atlantic to keep track of cells that can reach them.  - from each starting cell, we traverse to cells upstream and cells that aren't in either atlantic or pacific (depending on what the source was), adding to the  right pacific or atlantic set. - return the intersection of the pacific and atlantic set.	"class Solution:     def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:         ROWS, COLS = len(heights), len(heights[0])         pacific = set()         atlantic = set()          def dfs(r, c, visited):             visited.add((r, c))             for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:                 nr, nc = r + dr, c + dc                 if (                     0 <= nr < ROWS and 0 <= nc < COLS and  # Valid neighbor                     (nr, nc) not in visited and            # Not already visited                     heights[nr][nc] >= heights[r][c]       # Water can flow                 ):                     dfs(nr, nc, visited)          # Run DFS for Pacific and Atlantic edges         for r in range(ROWS):             dfs(r, 0, pacific)  # Left edge (Pacific)             dfs(r, COLS - 1, atlantic)  # Right edge (Atlantic)         for c in range(COLS):             dfs(0, c, pacific)  # Top edge (Pacific)             dfs(ROWS - 1, c, atlantic)  # Bottom edge (Atlantic)          # Intersection of cells reachable by both oceans         return list(pacific & atlantic)"	Time complexity: O(m∗n)Space complexity: O(m∗n)
Surrounded Regions	Medium		dfs	Step 1: Identify 'O' Regions Connected to the Boundary The capture function is a Depth-First Search (DFS) that marks all 'O' cells connected to the boundary with a temporary marker ('T').The algorithm starts by traversing the edges of the board:Top and bottom rows: Traverse all cells in the first and last rows.Left and right columns: Traverse all cells in the first and last columns.If an 'O' cell is found, the capture function is called recursively to:Mark the current cell as 'T'.Explore all 4 adjacent cells (up, down, left, right).Step 2: Process the Entire Board After marking all 'O' cells connected to the boundary, iterate through the entire board:Convert all remaining 'O' cells (which are completely surrounded) to 'X'.Convert all 'T' cells (connected to the boundary) back to 'O'.	"class Solution:     def solve(self, board: List[List[str]]) -> None:         ROWS, COLS = len(board), len(board[0])          def capture(r, c):             if (r < 0 or c < 0 or r == ROWS or                  c == COLS or board[r][c] != ""O""             ):                 return             board[r][c] = ""T""             capture(r + 1, c)             capture(r - 1, c)             capture(r, c + 1)             capture(r, c - 1)          for r in range(ROWS):             if board[r][0] == ""O"":                 capture(r, 0)             if board[r][COLS - 1] == ""O"":                 capture(r, COLS - 1)                  for c in range(COLS):             if board[0][c] == ""O"":                 capture(0, c)             if board[ROWS - 1][c] == ""O"":                 capture(ROWS - 1, c)          for r in range(ROWS):             for c in range(COLS):                 if board[r][c] == ""O"":                     board[r][c] = ""X""                 elif board[r][c] == ""T"":                     board[r][c] = ""O"""	Time complexity: O(m∗n)Space complexity: O(m∗n)
Plus One	Easy		start at the right keep incrementing as you go if needed.	Each digit in the array corresponds to a place value in the number (e.g., [1, 2, 3] represents the number 123).To increment the number:Start from the least significant digit (rightmost) and move leftward.If adding one causes the digit to become 10 (carry), reset it to 0 and propagate the carry to the next more significant digit.If a carry is still present after processing all digits, prepend a 1 to the array.	class Solution:     def plusOne(self, digits: List[int]) -> List[int]:         n = len(digits)         for i in range(n - 1, -1, -1):             if digits[i] < 9:                 digits[i] += 1                 return digits             digits[i] = 0                  return [1] + digits	Time complexity: O(n)Space complexity: O(1)
Jump Game	Medium		greedy approach	"we want to iterate in reverse from the end (second to the end) value to the beginning. we want to keep track of a ""goal"" index that represents the leftmost value that we have found that can reach the end. as we iterate backwards, if the current number has a high enough value that we can reach goal, then we set the new goal  equal to the current index and keep iterating in reverse. if we can't reach goal, it's possible that values further to the left can reach it so we just do nothing and keep iterating left. at the end, we check if goal == 0. if it does, this means that the leftmost value that can reach the end is the 0th index (i.e. the start index), which means the end is reachable from the start, so we return True."	class Solution:     def canJump(self, nums: List[int]) -> bool:         goal = len(nums) - 1          for i in range(len(nums) - 2, -1, -1):             if i + nums[i] >= goal:                 goal = i         return goal == 0	Time complexity: O(n)Space complexity: O(1)
Jump Game II	Medium		greedy	For the BFS greedy approach:   Initialization:Start with res = 0 (no jumps made yet).Set both l and r to 0, meaning our initial position is at index 0. Main Loop (while r < len(nums) - 1):Continue looping until the right boundary r reaches or surpasses the last index. This means we've found a path to the end. Find Farthest Reachable Index in Current Level:Initialize farthest = 0 for each level.Iterate over the current level (for i in range(l, r + 1)):For each index i in the current level, calculate how far we can reach from there using i + nums[i].Update farthest with the maximum value of i + nums[i].This represents the farthest index we can reach in the next jump from the current level. Prepare for Next Level:After processing the current level, update the boundaries for the next level:l = r + 1: The next level starts right after the current right boundary.r = farthest: The right boundary of the next level is the farthest index we found.Increment res because we have made another jump. Return Result:Once the loop ends (when r reaches or exceeds len(nums) - 1), return res, the total number of jumps made.	My first approach was:  class Solution:     def jump(self, nums: List[int]) -> int:         nums[-1] = 0         goal = len(nums) - 1                  if len(nums) == 1:             return 0                  for i in range(len(nums) - 2, -1, -1):             if i + nums[i] >= goal:                 shortestPathIndex = goal                 for j in range(goal - i, nums[i] + 1, 1):                     if i + j < len(nums):                         if nums[i + j] < nums[shortestPathIndex]:                             shortestPathIndex = i + j                 nums[i] = nums[shortestPathIndex] + 1                 goal = i             else:                 nums[i] = 101                  return nums[0]   BFS Greedy (most efficient):  class Solution:     def jump(self, nums: List[int]) -> int:         res = 0         l = r = 0          while r < len(nums) - 1:             farthest = 0             for i in range(l, r + 1):                 farthest = max(farthest, i + nums[i])             l = r + 1             r = farthest             res += 1         return res	my approach has: Time complexity: O(n^2)Space complexity: O(n) BFS Greedy has: Time complexity: O(n)Space complexity: O(1)
Gas Station	Medium		Greedy	First Check for Feasibility:sum(gas) < sum(cost) ensures that there’s no point wasting time on impossible cases. Simulate the Circuit:The loop iterates through each station, calculating the remaining gas (gas[i] - cost[i]).The variable total tracks the gas available as you move through the circuit starting from the current res. Reset When Total is Negative:If total becomes negative, it means the current starting point cannot work, so you reset the start to the next station (res = i + 1). Return the Result:At the end of the loop, if a solution exists, res will point to the correct starting station.	class Solution:     def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:         if sum(gas) < sum(cost):             return -1          total = 0         res = 0         for i in range(len(gas)):             total += (gas[i] - cost[i])              if total < 0:                 total = 0                 res = i + 1                  return res	Time complexity: O(n)Space complexity: O(1)
Maximum Sum Circular Subarray	Medium		Kadane's Algo	"This algorithm solves the problem by looking at two possible cases for the global sum. Case 1 is where the global max is circular (crosses back to the start of the array) and case 2 is when it is non-circular. - Case 1 is just the same as the maximum sum problem i.e. keep track of current sum and max sum and update as you go. - Case 2 implies that there is some ""split"" in the array, meaning there is some middle segment that is not included in the two halves of the subarray correponding to global max. In order to find this split array, we do total - globalMin. By subtracting the minimum subarray sum (globalMin), we effectively exclude the ""worst"" segment (i.e., the segment that minimizes the total sum) from the array. Why is globMax > 0 Checked? If globMax (the maximum non-circular subarray sum) is less than or equal to 0, all elements in the array are non-positive. In this case:The maximum circular sum would also be negative.We should directly return globMax, as it represents the maximum subarray sum in both circular and non-circular scenarios."	class Solution:     def maxSubarraySumCircular(self, nums: List[int]) -> int:         globMax, globMin = nums[0], nums[0]         curMax, curMin = 0, 0         total = 0          for num in nums:             curMax = max(curMax + num, num)             curMin = min(curMin + num, num)             total += num             globMax = max(globMax, curMax)             globMin = min(globMin, curMin)          return max(globMax, total - globMin) if globMax > 0 else globMax	Time complexity: O(n)Space complexity: O(1) extra space.
Longest Turbulent Subarray	Medium		Kadane's Algorithm	Here, res variable corresponds to the globalMax variable in other similar Kadane problems. We want to use res to keep track of the longest subarrays that have this turbulent property of alternating comparison operators. The currMax variable in other problems is equivalent to the r-l+1 in this problem and is the length of the current subarray that we check against res every iteration that it gets longer. The general idea in this problem is that we loop through the array elements and check that the comparison operator of the previous element and current element is the opposite of the previous operator. If it is, we increase the right side of the current window by 1. If not then we start a new window by moving the left pointer up. We also check res as we go and return that at the end.	"class Solution:     def maxTurbulenceSize(self, arr: List[int]) -> int:         l, r, res, prev = 0, 1, 1, """"          while r < len(arr):             if arr[r - 1] > arr[r] and prev != "">"":                 res = max(res, r - l + 1)                 r += 1                 prev = "">""             elif arr[r - 1] < arr[r] and prev != ""<"":                 res = max(res, r - l + 1)                 r += 1                 prev = ""<""             else:                 r = r + 1 if arr[r] == arr[r - 1] else r                 l = r - 1                 prev = """"          return res"	Time complexity: O(n)Space complexity: O(1) extra space.
Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold	Medium		Sliding Window	We want to use the runningTotal as the property that we are maintaining in our window. We do this by adding and subtracting the elements that will be/were in our window. Each iteration we check if the runningTotal is larger than threshold and increase the count variable by 1. There are various ways to construct the loop but one way is to initialize a left pointer and then use a for loop for the right pointer which starts at k-1th index. This means you have to initialize runningTotal with the sum of the first few elements.	class Solution:     def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:         count = 0         l = 0         runningTotal = sum(arr[:k-1])                  for r in range(k - 1, len(arr)):             runningTotal += arr[r]                          if runningTotal / k >= threshold:                 count += 1                          runningTotal -= arr[l]             l += 1                  return count    // Alternate (probably simpler) way of looping   class Solution:     def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:         res = 0         curSum = sum(arr[:k - 1])          for L in range(len(arr) - k + 1):             curSum += arr[L + k - 1]             if (curSum / k) >= threshold:                 res += 1             curSum -= arr[L]         return res	Time complexity: O(n)Space complexity: O(1) extra space.
Minimum Size Subarray Sum	Medium		Sliding window (variable)	use left and right pointers and a currentSum to maintain the sum property of the window. This means decreasing and increasing the currentSum when the window moves along the array.  We also want to make sure we are always trying to find the minimum subarray that satisfies the condition. This means if we find an array that does satisfy the condition of being larger than the target, we attempt to make the array smaller by increasing the left pointer. There would be no point in making it bigger as that would not be finding the minimum size subarray.  Else we increase the right pointer so we can satisfy the condition.	class Solution:     def minSubArrayLen(self, target: int, nums: List[int]) -> int:         if not nums:             return 0                  l, r = 0, 0         currentSum = 0         minimumSize = float('inf')                  while r < len(nums):             currentSum += nums[r]                          while currentSum >= target:                 minimumSize = min(minimumSize, r - l + 1)                 currentSum -= nums[l]                 l += 1                          r += 1                  return minimumSize if minimumSize != float('inf') else 0	Time complexity: O(n)Space complexity: O(1) extra space.
Range Sum Query - Immutable	Easy		Prefix Sum	create a prefix sum data structure for nums when you initialize the object. return the prefix sum for the right minus the prefix sum for the left.	class NumArray:     def __init__(self, nums):         self.prefix = []         cur = 0         for num in nums:             cur += num             self.prefix.append(cur)      def sumRange(self, left, right):         rightSum = self.prefix[right]         leftSum = self.prefix[left - 1] if left > 0 else 0         return rightSum - leftSum	Time complexity: O(1) for each sumRange() query, O(n) for building the prefix sum array.Space complexity: O(n)
Find Pivot Index	Easy		Prefix Sum	calculate total sum iterate from left calculate prefix sum as you go and compare to prefix sum to see when you're halfway	class Solution:     def pivotIndex(self, nums: List[int]) -> int:         total = sum(nums)         leftSum = 0         for i in range(len(nums)):             rightSum = total - nums[i] - leftSum             if leftSum == rightSum:                 return i             leftSum += nums[i]         return -1	Time complexity: O(n)Space complexity: O(1)
Subarray Sum Equals K	Medium		Prefix Sum/Hashmap	"This solution to the ""Subarray Sum Equals K"" problem uses a combination of the prefix sum technique and a hashmap for efficient computation. The idea is to keep track of the cumulative sum (curSum) of the array as we iterate through it. The prefix sum allows us to calculate the sum of any subarray in constant time by subtracting a previously seen cumulative sum (diff) from the current cumulative sum. If a subarray ending at the current index has a sum equal to k, the difference between curSum and k must have been encountered before in the prefix sums. To implement this, we use a hashmap (prefixSums) where keys represent cumulative sums and values represent the number of times each cumulative sum has been encountered. Initially, the hashmap is set to {0: 1} to handle cases where a subarray starting from the beginning of the array equals k. As we iterate through the array, we update curSum by adding the current element. We then compute diff = curSum - k, which represents the prefix sum that would result in a subarray sum of k. If this diff exists in the hashmap, it means there are one or more subarrays ending at the current index that sum to k, and we increment the result counter by the count stored in the hashmap for that diff. Finally, we update the hashmap with the current cumulative sum, either by incrementing its count if it already exists or initializing it to 1 if it doesn’t. This ensures that the hashmap always reflects the counts of prefix sums encountered up to the current index. By the end of the iteration, the result counter will hold the total number of subarrays whose sum equals k. This approach is efficient, with a time complexity of O(n)O(n)O(n) since it processes the array in a single pass, and a space complexity of O(n)O(n)O(n) for storing prefix sums in the hashmap.     4o"	class Solution:     def subarraySum(self, nums: List[int], k: int) -> int:         res = curSum = 0         prefixSums = { 0 : 1 }          for num in nums:             curSum += num             diff = curSum - k              res += prefixSums.get(diff, 0)             prefixSums[curSum] = 1 + prefixSums.get(curSum, 0)                  return res	Time complexity: O(n)Space complexity: O(n)
Middle of the Linked List	Easy		fast and slow pointers	Use fast and slow pointers. If the list has an odd number of nodes, the fast pointer should end up on the last node. If it has an even number of nodes, it should end up on the null terminator at the end of the list.	class Solution:     def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:         slow, fast = head, head          while fast and fast.next:             slow = slow.next             fast = fast.next.next         return slow	Time complexity: O(n)Space complexity: O(1) extra space.
Linked List Cycle II	Medium		fast and slow	Use fast and slow pointers to determine whether there is a cycle. If there is then fast and slow will equal each other at some point. If there is not, then the fast pointer will be null or fast.next will be none. Then initialize a new variable slow2. Keep increasing slow and slow2 by one node until they land on the same node. The node they land on will be the cycle head.	"class Solution:     def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:         # Initialize slow and fast pointers         slow = fast = head          # First, determine if a cycle exists using two pointers         while fast and fast.next:             fast = fast.next.next  # Move fast pointer by two steps             slow = slow.next       # Move slow pointer by one step              # If the pointers meet, a cycle exists             if slow == fast:                 break          # If no cycle is detected (fast pointer reaches the end), return None         if not fast or not fast.next:             return None          # A cycle is detected; find the start of the cycle         slow2 = head         while slow != slow2:             slow = slow.next       # Move slow pointer one step             slow2 = slow2.next     # Move slow2 pointer one step          # The meeting point is the start of the cycle         return slow"	Time complexity: O(n)Space complexity: O(1)
Maximum Twin Sum of a Linked List	Medium		Fast and Slow pointers	First, traverse the linked list using fast and slow pointers so that the slow pointer is halfway and the fast pointer is at the end. Then reverse the second half of the list so that the second member of the first pair is immediately after the middle, the second member of the second pair is two after the middle and so.... Then traverse the linked list from the start. Use a new variable that holds the max pair sum and record the max pair sum each iteration. return the max pair sum.	"class Solution(object):     def pairSum(self, head):         slow, fast = head, head         maximumSum = 0          # Get middle of the linked list.         while fast and fast.next:             fast = fast.next.next             slow = slow.next          # Reverse second half of the linked list.         curr, prev = slow, None         while curr:                    curr.next, prev, curr = prev, curr, curr.next                  start = head         while prev:             maximumSum = max(maximumSum, start.val + prev.val)             prev = prev.next             start = start.next          return maximumSum"	Time Complexity: O(n) Space Complexity: O(1)
Implement Trie (Prefix Tree)	Medium		Trie/Prefix Tree	Implement a TrieNode class that has two properties, children (hashmap) and endOfWord (boolean). Implement the PrefixTree: - initialize the root - insert: initialize a curr pointer to the root. Iterate through the chars in the word. If the character does not exist in the children hashmap of the current node, add it to the hashmap and assign an empty node. Move the pointer to the child. At the end of the loop, set endOfWord for the node pointed at by curr equal to True. - search: similar to insert. Initialize curr pointer. Loop through chars in the word and check if the char is in the children of the current node. If not return False. Move the pointer. At the end, return whether the final node is the end of the word. - startsWith: Initialize curr and loop through chars in prefix word. If c is not in the children of curr return false. Move the pointer to the child. If you finish the loop, return true.	class TrieNode:     def __init__(self):         self.children = {}         self.endOfWord = False  class PrefixTree:     def __init__(self):         self.root = TrieNode()      def insert(self, word: str) -> None:         cur = self.root         for c in word:             if c not in cur.children:                 cur.children[c] = TrieNode()             cur = cur.children[c]         cur.endOfWord = True      def search(self, word: str) -> bool:         cur = self.root         for c in word:             if c not in cur.children:                 return False             cur = cur.children[c]         return cur.endOfWord      def startsWith(self, prefix: str) -> bool:         cur = self.root         for c in prefix:             if c not in cur.children:                 return False             cur = cur.children[c]         return True	Time complexity: O(n) for each function call.Space complexity: O(t) Where n is the length of the string and t is the total number of TrieNodes created in the Trie.
Subsets I (Without Duplicates)	Medium		Backtracking	every item can either be included or not included every time we make a decision to include or not include a value, this should spawn future processes given this decision each process needs to make its own subset array	class Solution:     def subsets(self, nums: List[int]) -> List[List[int]]:         res = []          subset = []          def dfs(i):             if i >= len(nums):                 res.append(subset.copy())                 return             subset.append(nums[i])             dfs(i + 1)             subset.pop()             dfs(i + 1)          dfs(0)         return res	Time complexity: O(n∗2n)Space complexity: O(n)
Subsets (with Duplicates)	Medium		Backtracking	This is a very similar solution to subsets 1.   Sorting the List:The input list is sorted to group duplicate numbers together. This makes it easier to identify and skip over duplicates when generating subsets. Recursive Backtracking:The main logic is implemented using a helper function that explores all possible combinations of elements in the list (using a depth-first search approach).At each step, the algorithm decides whether to include the current element in the subset or skip it. Handling Duplicates:To ensure uniqueness, the algorithm skips over consecutive duplicate elements (after including or excluding the first occurrence of a duplicate group).This prevents generating subsets that are identical. Building Subsets:If the end of the list is reached, the current subset (a temporary list of chosen elements) is added to the final list of subsets.This process ensures that all valid subsets are collected. Final Output:Once all possibilities are explored, the function returns the list of unique subsets.	class Solution:     def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:         res = []         nums.sort()          def backtrack(i, subset):             if i == len(nums):                 res.append(subset[::])                 return              subset.append(nums[i])             backtrack(i + 1, subset)             subset.pop()              while i + 1 < len(nums) and nums[i] == nums[i + 1]:                 i += 1             backtrack(i + 1, subset)          backtrack(0, [])         return res	Time complexity: O(n∗2n)Space complexity: O(n)
Combinations	Medium		Backtracking	Recursive Backtracking:Use recursion to explore all possible subsets of size k.At each step, decide whether to include the current number (i) in the combination or skip it.Continue until you either:Reach a combination of size k (valid subset), orExhaust all numbers in the range. Base Cases:If the current subset has k elements, add it to the result.If the current number exceeds n, stop exploring further. Pruning:By iterating sequentially from 1 to n, avoid generating duplicate combinations (e.g., [1, 2] is the same as [2, 1]).	class Solution:     def combine(self, n: int, k: int) -> List[List[int]]:         res = []                  def backtrack(i, comb):             if i > n:                 if len(comb) == k:                     res.append(comb.copy())                 return                          comb.append(i)             backtrack(i + 1, comb)             comb.pop()             backtrack(i + 1, comb)                  backtrack(1, [])         return res	Time complexity: O(k∗n!/((n−k)!∗k!))Space complexity: O(k∗n!/((n−k)!∗k!)) for the output array.
Combination Sum	Medium		Backtracking	Base Cases:If total == target: A valid combination is found. Add it to res and stop exploring further along this path.If i is out of bounds (i >= len(nums)) or total > target: Terminate this path because it's either invalid or exceeds the target. Recursive Steps:Include the current number:Add nums[i] to the current combination (cur) and update the total.Recursively call dfs with the same index (i) to allow reusing the number.Exclude the current number:Remove the last added number (cur.pop()) to backtrack.Move to the next number (i + 1) and explore further.	class Solution:     def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:         res = []          def dfs(i, cur, total):             if total == target:                 res.append(cur.copy())                 return             if i >= len(nums) or total > target:                 return              cur.append(nums[i])             dfs(i, cur, total + nums[i])             cur.pop()             dfs(i + 1, cur, total)          dfs(0, [], 0)         return res	Time complexity: O(2^t/m)Space complexity: O(t/m) Where t is the given target and m is the minimum value in nums
Letter Combinations of a Phone Number	Medium		Backtracking/recursion	create a hashmap that maps the digits to the letters they represent.  create the backtracking helper function.  The base case of this function is when the string is completed. One digit can represent one letter so when the length of the current string is equal to the length of the digits, then we know we have created a full combination. Then, in the main body of the helper function, we loop through all the letters we could add that correspond to this digit add them to the current string.  For each of these new current string possibilities, we then recursively call the helper function with i+1 (signifying we are looking at the next digit) with this new string. Finally, we check if digits is empty. If not, make the initial call to the helper function with index 0 and an empty string.	"class Solution:     def letterCombinations(self, digits: str) -> List[str]:         res = []         digitToChar = {             ""2"": ""abc"",             ""3"": ""def"",             ""4"": ""ghi"",             ""5"": ""jkl"",             ""6"": ""mno"",             ""7"": ""qprs"",             ""8"": ""tuv"",             ""9"": ""wxyz"",         }          def backtrack(i, curStr):             if len(curStr) == len(digits):                 res.append(curStr)                 return             for c in digitToChar[digits[i]]:                 backtrack(i + 1, curStr + c)          if digits:             backtrack(0, """")          return res"	Time complexity: O(n∗4^n)Space complexity: O(n)
Flatten Array	Easy		Iterate		def flatten_array(array):     result = []     for i in array:         if isinstance(i, list):             result.extend(flatten_array(i))         else:             result.append(i)     return result	Time: O(n) Space: O(n)
Merge Intervals	Medium		Intervals	Sort the IntervalsSorts intervals by the start time to process them in increasing order. Initialize output ListStart with the first interval as the initial merged result. Iterate Over Each IntervalCheck for Overlapping (if start <= lastEnd)Merge the intervals by updating the end time of the last interval in output.If No Overlap (else)Append the new interval to output. Return the Merged List	"my solution:  class Solution:     def merge(self, intervals: List[List[int]]) -> List[List[int]]:         if not intervals:             return []                  # Sort intervals based on start times         intervals.sort()         ret = []         i = 0                  while i < len(intervals):             start, end = intervals[i]                          # Merge overlapping intervals             while i + 1 < len(intervals) and intervals[i + 1][0] <= end:                 end = max(end, intervals[i + 1][1])                 i += 1                          ret.append([start, end])             i += 1                  return ret   a bit cleaner but same runtime:  class Solution:     def merge(self, intervals: List[List[int]]) -> List[List[int]]:         intervals.sort(key=lambda pair: pair[0])         output = [intervals[0]]          for start, end in intervals:             lastEnd = output[-1][1]              if start <= lastEnd:                 output[-1][1] = max(lastEnd, end)             else:                 output.append([start, end])         return output"	Time complexity: O(nlog⁡n)Space complexity: O(1) or O(n) depending on the sorting algorithm.
Reorganize String	Medium		Max heap	"Step 1: Count Character FrequenciesCreate a frequency map freq to count occurrences of each character.Find the most frequent character's count (maxF).Step 2: Check if Rearrangement is PossibleIf any character appears more than (N + 1) // 2 times, return """" (impossible to rearrange).Step 3: Build a Max-HeapInsert all characters into a max-heap with their frequencies (negated for Python’s min-heap behavior).Step 4: Construct the Result StringInitialize res = [] to store the output string.Keep track of the previous character (prev_char) and its remaining count (prev_count).Step 5: Process Characters from HeapWhile the heap is not empty:Pop the most frequent character from the heap.Append the character to res.If the previous character (prev_char) still has occurrences left, push it back into the heap.Update prev_count and prev_char with the new character.Step 6: Return the Final ResultConvert res list into a string and return it."	"import heapq from collections import Counter  class Solution:     def reorganizeString(self, s: str) -> str:         # Count character frequencies         freq = Counter(s)         maxF = max(freq.values())         totalF = sum(freq.values())         others = totalF - maxF                  # If it's impossible to reorganize, return an empty string         if others < maxF - 1:             return """"                  # Create a max-heap (invert counts for min-heap behavior)         maxHeap = [(-count, char) for char, count in freq.items()]         heapq.heapify(maxHeap)                  # Reconstruct the string by placing characters in alternating positions         res = []         prev_count, prev_char = 0, ''                  while maxHeap:             count, char = heapq.heappop(maxHeap)  # Get the most frequent character             res.append(char)                          # If there was a previously used character, push it back into the heap             if prev_count < 0:                 heapq.heappush(maxHeap, (prev_count, prev_char))                          # Decrease count (since we used this character)             prev_count, prev_char = count + 1, char  # Add 1 because count is negative                  return """".join(res)"	Time Complexity: Heap Operations: O(Nlog⁡N)String Construction: O(N)Total: O(Nlog⁡N)   Final Space Complexity: O(N)
Climbing Stairs	Easy		DP	For space optimized solution  Step 1: Initialize Base CasesSet one = 1 (represents the number of ways to reach the last step).Set two = 1 (represents the number of ways to reach the second last step).Step 2: Iterate from 0 to n-2Repeat the following steps for n-1 iterations:Store the value of one in temp (to keep track of previous value).Update one = one + two (new number of ways is sum of previous two steps).Update two = temp (shift values forward).Step 3: Return the Final ResultReturn one (which now holds the total ways to reach n steps).	class Solution:     def climbStairs(self, n: int) -> int:         cache = [-1] * n         def dfs(i):             if i >= n:                 return i == n             if cache[i] != -1:                 return cache[i]             cache[i] = dfs(i + 1) + dfs(i + 2)             return cache[i]                      return dfs(0)  -----  class Solution:     def climbStairs(self, n: int) -> int:         if n <= 2:             return n         dp = [0] * (n + 1)         dp[1], dp[2] = 1, 2         for i in range(3, n + 1):             dp[i] = dp[i - 1] + dp[i - 2]         return dp[n]  -----  class Solution:     def climbStairs(self, n: int) -> int:         one, two = 1, 1          for i in range(n - 1):             temp = one             one = one + two             two = temp                  return one	For the first two: Time complexity: O(n)Space complexity: O(n)  For the last one: Time complexity: O(n)Space complexity: O(1)
Min Cost Climbing Stairs	Easy		DP	Step 1: Start from the End and Work BackwardsInstead of solving the problem from the first step, we work backwards from the third-to-last step.This ensures that when we compute the cost for a step, the future steps' minimum costs are already known.Step 2: Update Each Step with the Minimum Cost to Reach the TopFor each step, we calculate the minimum cost to climb from that position by adding the cheaper of the two next possible steps.This helps in building up the solution dynamically, avoiding redundant calculations.Step 3: Choose the Best Starting PositionSince the climb can start from either the first or second step, the final answer is the minimum cost between the first two steps.	class Solution:     def minCostClimbingStairs(self, cost: List[int]) -> int:         memo = [-1] * len(cost)                  def dfs(i):             if i >= len(cost):                 return 0             if memo[i] != -1:                 return memo[i]             memo[i] = cost[i] + min(dfs(i + 1), dfs(i + 2))             return memo[i]                  return min(dfs(0), dfs(1))  ------  class Solution:     def minCostClimbingStairs(self, cost: List[int]) -> int:         n = len(cost)         dp = [0] * (n + 1)                  for i in range(2, n + 1):             dp[i] = min(dp[i - 1] + cost[i - 1],                         dp[i - 2] + cost[i - 2])                  return dp[n]  -----  class Solution:     def minCostClimbingStairs(self, cost: List[int]) -> int:         for i in range(len(cost) - 3, -1, -1):             cost[i] += min(cost[i + 1], cost[i + 2])          return min(cost[0], cost[1])	For the first two: Time complexity: O(n)Space complexity: O(n)  For the last one: Time complexity: O(n)Space complexity: O(1)
House Robber	Medium		DP	For space optimized solution:   1. Define Two Variables to Track Maximum Profitrob1: Stores the maximum profit from two houses ago (previous to the previous house).rob2: Stores the maximum profit from the last house considered.2. Iterate Through Each House For each house (money amount num in nums), determine whether to rob it or skip it:Option 1: Rob the current houseAdd num to rob1 (since the previous house cannot be robbed).Option 2: Skip the current houseKeep rob2 as is (since we already stored the best profit from the previous house).Take the maximum of these two options and store it in temp.Update rob1 and rob2 for the next iteration.3. Return the Maximum Profit At the end, rob2 holds the maximum profit possible.	Dynamic Programming (Top-Down)class Solution:     def rob(self, nums: List[int]) -> int:         memo = [-1] * len(nums)          def dfs(i):             if i >= len(nums):                 return 0             if memo[i] != -1:                 return memo[i]             memo[i] = max(dfs(i + 1), nums[i] + dfs(i + 2))             return memo[i]                  return dfs(0)Dynamic Programming (Bottom-Up) class Solution:     def rob(self, nums: List[int]) -> int:         if not nums:             return 0         if len(nums) == 1:             return nums[0]                  dp = [0] * len(nums)         dp[0] = nums[0]         dp[1] = max(nums[0], nums[1])                  for i in range(2, len(nums)):             dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])                  return dp[-1]    Dynamic Programming (Space Optimized) class Solution:     def rob(self, nums: List[int]) -> int:         rob1, rob2 = 0, 0          for num in nums:             temp = max(num + rob1, rob2)             rob1 = rob2             rob2 = temp         return rob2	First two: Time complexity: O(n)O(n)Space complexity: O(n)O(n)  Space Optimized: Time complexity: O(n)Space complexity: O(1)
House Robber II	Medium		DP	Divide the problem into two subproblems:Find the maximum money robbed excluding the first house.Find the maximum money robbed excluding the last house.Since we must exclude one of them, we take the maximum of both cases. Use the standard House Robber solution for each case:The standard House Robber problem can be solved using dynamic programming with two variables to track the maximum profit at each step.At every house, decide:Rob this house → Add the money and skip the previous house.Skip this house → Take the previously computed maximum. Compute the final result:Compare the results from the two cases and return the maximum possible amount that can be robbed.	Dynamic Programming (Bottom-Up)class Solution:     def rob(self, nums: List[int]) -> int:         if len(nums) == 1:             return nums[0]         return max(self.helper(nums[1:]),                     self.helper(nums[:-1]))          def helper(self, nums: List[int]) -> int:         if not nums:             return 0         if len(nums) == 1:             return nums[0]                  dp = [0] * len(nums)         dp[0] = nums[0]         dp[1] = max(nums[0], nums[1])                  for i in range(2, len(nums)):             dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])                  return dp[-1]   ------ Dynamic Programming (Space Optimized)class Solution:          def rob(self, nums: List[int]) -> int:         return max(nums[0], self.helper(nums[1:]),                              self.helper(nums[:-1]))      def helper(self, nums):         rob1, rob2 = 0, 0          for num in nums:             newRob = max(rob1 + num, rob2)             rob1 = rob2             rob2 = newRob         return rob2	For bottom up:Time complexity: O(n)Space complexity: O(n) For space optimized: Time complexity: O(n)Space complexity: O(1)
Longest Palindromic Substring	Medium		DP	"Dynamic Programming:  Divide the problem into two subproblems:Find the maximum money robbed excluding the first house.Find the maximum money robbed excluding the last house.Since we must exclude one of them, we take the maximum of both cases. Use the standard House Robber solution for each case:The standard House Robber problem can be solved using dynamic programming with two variables to track the maximum profit at each step.At every house, decide:Rob this house → Add the money and skip the previous house.Skip this house → Take the previously computed maximum. Compute the final result:Compare the results from the two cases and return the maximum possible amount that can be robbed.     Two Pointer: 1. Initialize VariablesresIdx: Stores the starting index of the longest palindrome found so far.resLen: Stores the length of the longest palindrome found so far.2. Expand Around Each Character as a CenterWe iterate through each index i in the string, treating s[i] as a possible center of a palindrome.Expand outward while the substring remains a palindrome.Handling Two Cases for Expansion Odd-length palindromes (""racecar"")The center is a single character (l = i, r = i).Expand outward (l--, r++) while s[l] == s[r]. Even-length palindromes (""abba"")The center is between two characters (l = i, r = i + 1).Expand outward (l--, r++) while s[l] == s[r].3.  Update the Longest Palindrome FoundIf the expanded palindrome is longer than the previous one (r - l + 1 > resLen):Update resIdx (starting position).Update resLen (length of the palindrome).4.  Return the Longest Palindromic SubstringExtract s[resIdx : resIdx + resLen] as the result."	"Dynamic Programming   class Solution:     def longestPalindrome(self, s: str) -> str:         resIdx, resLen = 0, 0         n = len(s)          dp = [[False] * n for _ in range(n)]          for i in range(n - 1, -1, -1):             for j in range(i, n):                 if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):                     dp[i][j] = True                     if resLen < (j - i + 1):                         resIdx = i                         resLen = j - i + 1          return s[resIdx : resIdx + resLen]      Two Pointers class Solution:     def longestPalindrome(self, s: str) -> str:         resIdx = 0         resLen = 0          for i in range(len(s)):             # odd length             l, r = i, i             while l >= 0 and r < len(s) and s[l] == s[r]:                 if (r - l + 1) > resLen:                     resIdx = l                     resLen = r - l + 1                 l -= 1                 r += 1              # even length             l, r = i, i + 1             while l >= 0 and r < len(s) and s[l] == s[r]:                 if (r - l + 1) > resLen:                     resIdx = l                     resLen = r - l + 1                 l -= 1                 r += 1          return s[resIdx : resIdx + resLen]"	For DP:Time complexity: O(n^2)Time complexity: O(n^2) For Two Pointer:Space complexity: O(n^2)Space complexity: O(1)
Palindromic Substrings	Medium		DP	"Dynamic Programming1. Initialize the DP TableCreate a 2D boolean table dp[i][j], where:dp[i][j] = True if the substring s[i:j+1] is a palindrome.dp[i][j] = False otherwise.Initialize res = 0 to store the count of palindromic substrings.2. Iterate Over the String in Reverse OrderOuter loop (i): Traverse from right to left (n-1 to 0).Inner loop (j): Traverse from left to right, starting from i.3. Check If a Substring is a Palindrome For each substring s[i:j], check:If the two end characters match (s[i] == s[j]).If the substring between them is a palindrome:If j - i <= 2 (substring length 1, 2, or 3), it's automatically a palindrome.Otherwise, check if dp[i+1][j-1] is True (previously computed).4. Update DP Table and CountIf s[i:j] is a palindrome, set dp[i][j] = True and increment res.5. Return Total Count of Palindromic Substringsres contains the total count of palindromic substrings. Two Pointers (Optimal) 1. Iterate Through Each Character as a CenterWe loop through each character in s (i from 0 to len(s) - 1).Each character can be the center of a palindrome.2. Expand Around Each Center For each character at index i, we call countPali(s, l, r) twice: Odd-length palindromes (""racecar"")The center is a single character (l = i, r = i).Expand outward while s[l] == s[r]. Even-length palindromes (""abba"")The center is between two characters (l = i, r = i + 1).Expand outward while s[l] == s[r].3. Count Valid Palindromic SubstringsEvery time a palindrome is found, increment the count (res).The function countPali() returns the number of palindromic substrings found from the given center.4️⃣ Return Total CountThe total number of palindromic substrings is stored in res and returned."	Dynamic Programmingclass Solution:     def countSubstrings(self, s: str) -> int:         n, res = len(s), 0         dp = [[False] * n for _ in range(n)]          for i in range(n - 1, -1, -1):             for j in range(i, n):                 if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):                     dp[i][j] = True                     res += 1          return res  Two Pointers (Optimal) class Solution:     def countSubstrings(self, s: str) -> int:         res = 0          for i in range(len(s)):             res += self.countPali(s, i, i)             res += self.countPali(s, i, i + 1)         return res      def countPali(self, s, l, r):         res = 0         while l >= 0 and r < len(s) and s[l] == s[r]:             res += 1             l -= 1             r += 1         return res	Dynamic Programming: Time complexity: O(n^2)Space complexity: O(n^2) For Two Pointers Optimal: Time complexity: O(n^2)Space complexity: O(1)
Maximum Product Subarray	Medium		DP/Kadane's	Kadane's:  Since multiplication behaves differently from addition (due to negative numbers and zeros), the approach needs to handle:Positive numbers (which increase the product)Negative numbers (which can flip the sign)Zeros (which reset the product)1️⃣ Initialize Variablesres = nums[0] → Stores the maximum product found so far.curMin, curMax = 1, 1 → Keep track of:curMax → The maximum product subarray ending at the current index.curMin → The minimum product subarray ending at the current index (important for handling negatives).2️⃣ Iterate Through Each Number in nums For each num in nums: Store the previous curMax (tmp = curMax * num). Update curMax → The maximum possible product at this step:  ini   CopyEdit curMax = max(num * curMax, num * curMin, num) This considers:num * curMax: Extending the positive subarray.num * curMin: Handling negative numbers that flip signs.num: Starting fresh if needed. Update curMin → The minimum possible product at this step:  ini   CopyEdit curMin = min(tmp, num * curMin, num) This helps track negative products that may become positive in future steps. Update res to store the maximum product found so far:  ini   CopyEdit res = max(res, curMax) 3️⃣ Return resThe variable res will contain the maximum product of any subarray. Prefix & Suffix  Unlike the Kadane’s approach (which tracks curMax and curMin), this method leverages prefix and suffix products to avoid issues with negative numbers.1️⃣ Initialize Variablesres = nums[0] → Stores the maximum product found so far.prefix = 0 → Stores the product of numbers from the start to the current index.suffix = 0 → Stores the product of numbers from the end to the current index.2️⃣ Iterate Over the Array Twice in One PassPass 1: Compute Prefix ProductsIterate from left to right (0 → n-1).Multiply prefix by the current number.If prefix == 0, reset to 1 (since multiplying by 0 ruins a product).Track the maximum product seen so far (res = max(res, prefix)).Pass 2: Compute Suffix Products SimultaneouslyIterate backward (n-1 → 0).Multiply suffix by the current number.If suffix == 0, reset to 1.Again, track the maximum product seen so far (res = max(res, suffix)).	Kadane's Algorithmclass Solution:     def maxProduct(self, nums: List[int]) -> int:         res = nums[0]         curMin, curMax = 1, 1          for num in nums:             tmp = curMax * num             curMax = max(num * curMax, num * curMin, num)             curMin = min(tmp, num * curMin, num)             res = max(res, curMax)         return res  Prefix & Suffix class Solution:     def maxProduct(self, nums: List[int]) -> int:         n, res = len(nums), nums[0]         prefix = suffix = 0          for i in range(n):             prefix = nums[i] * (prefix or 1)             suffix = nums[n - 1 - i] * (suffix or 1)             res = max(res, max(prefix, suffix))         return res	For Kadane's:Time complexity: O(n)Space complexity: O(1) For Prefix and Suffix: Time complexity: O(n)Space complexity: O(1)
Merge Sorted Array	Easy		3 pointer	Approach 2 already demonstrates the best possible time complexity,O(n+m), but still uses additional space. This is because the elements of arraynums1have to be stored somewhere so that they aren't overwritten. So, what if instead we start to overwritenums1from the end, where there is no information yet? The algorithm is similar to before, except this time we setp1to point at indexm - 1ofnums1,p2to point at indexn - 1ofnums2, andpto point at indexm + n - 1ofnums1. This way, it is guaranteed that once we start overwriting the firstmvalues innums1, we will have already written each into its new position. In this way, we can eliminate the additional space. Interview Tip: Whenever you're trying to solve an array problem in place, always consider the possibility of iterating backwards instead of forwards through the array. It can completely change the problem, and make it a lot easier.	"class Solution:     def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:         """"""         Do not return anything, modify nums1 in-place instead.         """"""          # Set p1 and p2 to point to the end of their respective arrays.         p1 = m - 1         p2 = n - 1          # And move p backward through the array, each time writing         # the largest value pointed at by p1 or p2.         for p in range(n + m - 1, -1, -1):             if p2 < 0:                 break             if p1 >= 0 and nums1[p1] > nums2[p2]:                 nums1[p] = nums1[p1]                 p1 -= 1             else:                 nums1[p] = nums2[p2]                 p2 -= 1"	Complexity Analysis Time complexity:O(n+m). Same as Approach 2. Space complexity:O(1). Unlike Approach 2, we're not using an extra array.
Minimum Window Substring	Hard		Sliding Window	"Step 1: SetupCount the frequency of characters in t using a hash table (freq).Use a sliding window (l and r pointers) to track a valid substring in s.Track how many characters in t are fully matched in the window (have == required).Step 2: Expand the Window (r pointer moves right)Add characters to the window.If a character helps complete a match (i.e., its count in the window reaches the required count in t), update have.Step 3: Shrink the Window (l pointer moves right)If all characters from t are in the current window (have == required), try shrinking the window to get the smallest valid substring.Move l forward and update the frequency counts.Step 4: Track the Minimum WindowEvery time a valid window is found (have == required), compare it with the smallest one found so far.Store the new smallest substring if it's shorter than the previous one.Step 5: Return the Smallest Valid SubstringIf a valid window was found, return it.Otherwise, return """" if no valid substring exists."	"from collections import Counter  class Solution:     def minWindow(self, s: str, t: str) -> str:         if not t or not s:             return """"          # Frequency dictionary of t         freq = Counter(t)         required = len(freq)  # Unique characters to match         have = 0  # Number of chars matched correctly         window_counts = {}  # Track window character counts         res, res_len = """", float(""inf"")          l = 0  # Left pointer         for r in range(len(s)):  # Right pointer expanding window             char = s[r]             if char in freq:                 window_counts[char] = window_counts.get(char, 0) + 1                 if window_counts[char] == freq[char]:  # Exact match of char in window                     have += 1              # Try to shrink window when we have all characters             while have == required:                 # Update result if smaller window is found                 if (r - l + 1) < res_len:                     res = s[l:r + 1]                     res_len = r - l + 1                  # Shrink from left                 if s[l] in freq:                     window_counts[s[l]] -= 1                     if window_counts[s[l]] < freq[s[l]]:  # Lost a required character                         have -= 1                 l += 1  # Move left pointer forward          return res"	Time complexity: O(n)Space complexity: O(m) Where n is the length of the string s and m is the total number of unique characters in the strings t and s.
Sliding Window Maximum	Hard		Sliding Window	can use heap or deque. Queue solution is optimal. It relies on the fact that for every number that appears in the window, all smaller numbers before it are essentially irrelevant because as the window moves forward, these smaller numbers will never be as big as the bigger number, and so they will never be added to the output array in the future. And the same is true for that big number as we continue to move the window right. This means that we need a deque (which will be monotonically decreasing for the reason described). Each time we move the window forward, we pop all numbers from the queue that are smaller than the new number. We also have to remember to pop the number that is no longer in the window because we moved it forward. Since the queue is monotonically decreasing, the number on the left end of the queue will be the number we append to the result array.	"Max Heap:  class Solution:     def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:         heap = []         output = []         for i in range(len(nums)):             heapq.heappush(heap, (-nums[i], i))             if i >= k - 1:                 while heap[0][1] <= i - k:                     heapq.heappop(heap)                 output.append(-heap[0][0])         return output  Deque:   class Solution:     def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:         output = []         q = deque()  # index         l = r = 0          while r < len(nums):             while q and nums[q[-1]] < nums[r]:                 q.pop()             q.append(r)              if l > q[0]:                 q.popleft()              if (r + 1) >= k:                 output.append(nums[q[0]])                 l += 1             r += 1          return output"	Heap: Time complexity: O(nlog⁡n)Space complexity: O(n) Deque: Time complexity: O(n)Space complexity: O(n)
Largest Number	Medium		Use custom sorting	Convert each integer to a string Sort strings based on concatenated values Handle the case where the largest number is zero Concatenate sorted strings to form the largest number	"class Solution:     def largestNumber(self, nums: List[int]) -> str:         # Convert each integer to a string         num_strings = [str(num) for num in nums]          # Sort strings based on concatenated values         num_strings.sort(key=lambda a: a * 10, reverse=True)          # Handle the case where the largest number is zero         if num_strings[0] == ""0"":             return ""0""          # Concatenate sorted strings to form the largest number         return """".join(num_strings)"	Time Complexity:O(nlogn) Space Complexity:O(n+S) Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array.
Sort an Array (Selection Sort)	Medium	Sort		"# Outer loop iterates over each element in the array # Start by assuming the current index is the minimum # Find the smallest element in the unsorted portion # If the current index of the array has a smaller value than the current minimum, update index of the smallest element # Swap the smallest element found with the first unsorted element"	class Solution:     def sortArray(self, nums: List[int]) -> List[int]:         n = len(nums)         for i in range(n):             m = i              for j in range(i + 1, n):                 if nums[j] < nums[m]:                     m = j               nums[i], nums[m] = nums[m], nums[i]         return nums	Best Case Runtime: O(N^2) Average Case Runtime: O(N^2) Worst Case Runtime: O(N^2) Space Complexity: O(1) Stable? No
Sort an Array (Quick Sort)	Medium	Sort		Choose a Pivot: Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).Partition the Array: Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.Recursively Call: Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).Base Case: The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.	from typing import List  class Solution:     def sortArray(self, nums: List[int]) -> List[int]:         def partition(nums, low, high):             pivot = nums[high]               i = low - 1              for j in range(low, high):                 if nums[j] < pivot:                       i += 1                     nums[i], nums[j] = nums[j], nums[i]                nums[i + 1], nums[high] = nums[high], nums[i + 1]               return i + 1            def quicksort(nums, low, high):             if low < high:                   pi = partition(nums, low, high)                 quicksort(nums, low, pi - 1)                 quicksort(nums, pi + 1, high)            quicksort(nums, 0, len(nums) - 1)         return nums	Best Case Runtime: O(nlog(n)) Average Case Runtime: O(nlog(n)) Worst Case Runtime:O(n^2) Space Complexity: O(log(n))
Sort an Array (Merge Sort)	Medium		sort	"Create a helper function called merge which takes in the original array arr, indices left, mid, right, and a temporary array tempArr as parameters.Calculate the start indices and sizes of the two halves of the array. The first half starts from the left index and the second half starts from mid+1.Copy elements of both halves into the temporary array.Merge the sub-arrays from the temporary array tempArr back into the original array arr in a sorted order using a while loop. The loop runs until either the first half or second half is completely merged. In each iteration, the smaller of the two elements from the first and second half is copied into the original array ""arr"".Copy any remaining elements from the first half or second half into the original array. Create a recursive function called mergeSort which takes in the original array arr, indices left, right, and a temporary array tempArr as parameters.Check if the left index is greater than or equal to the right index. If it is, we return from the function.Calculate the mid index.Sort the first and second halves of the array recursively by calling the mergeSort function.Merge the sorted halves by calling the merge function. Create a temporary array temporaryArray with the same size as the nums array. Call the mergeSort function on the nums array with boundary, 0, and nums.size()-1. Return the sorted array nums."	"class Solution:     def sortArray(self, nums: List[int]) -> List[int]:         temp_arr = [0] * len(nums)                  # Function to merge two sub-arrays in sorted order.         def merge(left: int, mid: int, right: int):             # Calculate the start and sizes of two halves.             start1 = left             start2 = mid + 1             n1 = mid - left + 1             n2 = right - mid              # Copy elements of both halves into a temporary array.             for i in range(n1):                 temp_arr[start1 + i] = nums[start1 + i]             for i in range(n2):                 temp_arr[start2 + i] = nums[start2 + i]              # Merge the sub-arrays 'in tempArray' back into the original array 'arr' in sorted order.             i, j, k = 0, 0, left             while i < n1 and j < n2:                 if temp_arr[start1 + i] <= temp_arr[start2 + j]:                     nums[k] = temp_arr[start1 + i]                     i += 1                 else:                     nums[k] = temp_arr[start2 + j]                     j += 1                 k += 1              # Copy remaining elements             while i < n1:                 nums[k] = temp_arr[start1 + i]                 i += 1                 k += 1             while j < n2:                 nums[k] = temp_arr[start2 + j]                 j += 1                 k += 1          # Recursive function to sort an array using merge sort         def merge_sort(left: int, right: int):             if left >= right:                 return             mid = (left + right) // 2             # Sort first and second halves recursively.             merge_sort(left, mid)             merge_sort(mid + 1, right)             # Merge the sorted halves.             merge(left, mid, right)              merge_sort(0, len(nums) - 1)         return nums"	Here, n is the number of elements in the nums array. Time complexity: O(nlogn)We divide the nums array into two halves till there is only one element in the array, which will lead to O(logn) steps. n→n/2→n/4→...→1 (k steps) n/2(k−1)=1⟹ k≈lognAnd after each division, we merge those respective halves which will take O(n) time each.Thus, overall it takes O(nlogn) time. Space complexity: O(n)The recursive stack will take O(logn) space and we used an additional array temporaryArray of size n.Thus, overall we use O(logn+n)=O(n) space.
Minimum Swaps to Group All 1's Together	Medium		Sliding Window	Count the total number of ones in data which determines the required window size for grouping ones together.Initialize cnt_one to track the count of ones in the current window and max_one to store the maximum number of ones found in any valid window.Use two pointers, left and right, to define a sliding window.Iterate over data with right, adding each element to cnt_one to keep track of the number of ones in the current window.If the window size exceeds ones, shrink the window by removing the leftmost element and updating cnt_one accordingly.Update max_one with the maximum number of ones found in any valid window.Compute the minimum swaps needed as ones - max_one, representing the number of zeros that need to be swapped to group all ones together.Return the computed minimum swaps.	"class Solution:     def minSwaps(self, data: List[int]) -> int:         ones = sum(data)         cnt_one = max_one = 0         left = right = 0         while right < len(data):             # updating the number of 1's by adding the new element             cnt_one += data[right]             right += 1             # maintain the length of the window to ones             if right - left > ones:                 # updating the number of 1's by removing the oldest element                 cnt_one -= data[left]                 left += 1             # record the maximum number of 1's in the window             max_one = max(max_one, cnt_one)         return ones - max_one"	Let n be the size of the input array data. Time complexity: O(n) The algorithm iterates through the array once using a sliding window approach. The while loop runs until the right pointer reaches the end of the array, which takes O(n) time. Inside the loop, the operations (updating cnt_one, checking the window size, and updating max_one) are all constant time operations, O(1). The initial sum calculation also takes O(n) time. Therefore, the overall time complexity is O(n). Space complexity: O(1) The algorithm uses a constant amount of extra space. The variables ones, cnt_one, max_one, left, and right are all integers and do not depend on the input size. No additional data structures are used that scale with the input size. Therefore, the space complexity is O(1).
Merge Operations to Turn Array Into a Palindrome	Medium		Greedy/Two Pointer	Use two pointers: l starts from the left (0), r starts from the right (len(nums) - 1).Compare nums[l] and nums[r]:If nums[l] < nums[r]: Merge nums[l] with nums[l+1], move l right.If nums[l] > nums[r]: Merge nums[r] with nums[r-1], move r left.If they are equal, just move both pointers inward (l += 1, r -= 1).Keep track of the number of merge operations in res.Stop when l crosses r.	class Solution:     def minimumOperations(self, nums: List[int]) -> int:         res = 0         l, r = 0, len(nums) - 1          while l <= r:             if nums[l] < nums[r]:                 nums[l + 1] += nums[l]                 l += 1                 res += 1             elif nums[l] > nums[r]:                 nums[r - 1] += nums[r]                 r -= 1                 res += 1             else:                 l += 1                 r -= 1          return res	Time complexity: O(n) Each element is processed at most once. Space complexity: O(1) Only a few variables used, and no additional data structures required.
Maximum Number of Vowels in a Substring of Given Length	Medium		Sliding Window	"Algorithm Build a hash set vowels that contains all 5 vowel letters, initialize answer as 0. Record the number of vowel letters in the first k letters as count. Now we move the ""window"" to the right, let i be the index of its right boundary:If s[i] is in vowels, increment count by 1.If s[i - k] is in vowels, reduce count by 1.Update answer as the maximum count we have encountered. Return answer after the iteration ends."	"class Solution:     def maxVowels(self, s: str, k: int) -> int:         vowels = {'a', 'e', 'i', 'o', 'u'}                  # Build the window of size k, count the number of vowels it contains.         count = 0         for i in range(k):             count += int(s[i] in vowels)         answer = count                  # Slide the window to the right, focus on the added character and the         # removed character and update ""count"". Record the largest ""count"".         for i in range(k, len(s)):             count += int(s[i] in vowels)             count -= int(s[i - k] in vowels)             answer = max(answer, count)                  return answer"	Let n be the length of the input string s. Time complexity: O(n)We apply 1 iteration over s.At each step in the iteration, we check if the newly added character and the removed character are in vowels, which takes constant time.To sum up, the time complexity is O(n). Space complexity: O(1)We need to record several parameters, count and answer, which takes O(1) space.The set vowels contains 5 vowel letters which takes O(1) space.
Max Number of K-Sum Pairs	Medium		Two Pointer / HashMap	Two Pointer Algorithm Sort the nums array in increasing i.e ascending order. We can use the built-in sort function. Initialize the left pointer to point at the 0th index and the right pointer to point to the last index of the nums array. We could say that the left pointer points to the smallest element in the array, and the right points to the largest element. Add the values of array elements pointed by left and right pointer given by sum.If the value of sum is less than k, increment left pointer.If the value of sum is greater than k, increment the right pointer.Otherwise, we have found one pair with a sum equal to k. Increment left pointer and decrement right pointer so that we can go ahead and find another pair. The process would continue until the left pointer is less than the right pointer. Once the left and right pointer cross each other, we know that we have traversed all the elements and cannot find any other pair. Hence, we stop at that point.  HashMap Algorithm Build a hashmap map where the key is the value of elements in the array and value is the count of the number of times that value is present in the array. Iterate over every element in the array nums. Let current be the element currently being traversed. Find the complement of the current element with respect to k, complement = current - k. The complement is a pair of current element that we are trying to find. However, it is possible that the current element is also taken before and paired with some other element. Hence, we check if both elements of the pair, current and complement are present in the map. If yes, we form the pair and remove those elements from the map. Instead of removing the elements from the map, we could simply decrement its count by 1. An element with a count of 0 is as good as being non-existent in the map. Is there any other case where our algorithm may fail? If the value of the current element and complement element is the same, we need at least 2 occurrences of that element to be present in the array, otherwise, we cannot form a pair. For example, if k = 6 and the value of the current element is 3, the complement must be 3 as well. In this case, there must be 2 elements in the array with the value 3 to form a pair. Every time we find a suitable pair of 2 elements with sum equal to k, increment the variable count. At the end, return the total number of pairs, count found in the array.	"Two Pointer:  class Solution:     def maxOperations(self, nums: List[int], k: int) -> int:         nums.sort()         ret = 0         l, r = 0, len(nums) - 1                  while l < r:             pair_sum = nums[l] + nums[r]             if pair_sum == k:                 ret += 1                 l += 1                 r -= 1             elif pair_sum < k:                 l += 1             else:                 r -= 1                  return ret   HashMap:  count_map = defaultdict(int)     count = 0          # Build the hashmap with count of occurrences of every element in array     for num in nums:         count_map[num] += 1          for num in nums:         complement = k - num         if count_map[num] > 0 and count_map[complement] > 0:             if num == complement and count_map[num] < 2:                 continue             count_map[num] -= 1             count_map[complement] -= 1             count += 1          return count"	Two Pointer:  Time Complexity: O(nlog⁡n) The sorting operation (nums.sort()) takes O(nlog⁡n) time. The two-pointer traversal processes each element at most once, leading to an O(n) complexity. Combining both, the total time complexity is: O(nlog⁡n)+O(n)=O(nlog⁡n)  Space Complexity: O(1)O(1)O(1) or O(n)O(n)O(n)  Best Case: Python’s sort() function is implemented using Timsort, which has an average space complexity of O(1) for in-place sorting. Worst Case: Timsort allocates O(n) additional space in cases where a merge is required. Thus, the space complexity varies between O(1) and O(n) depending on the input. HashMap:   Time Complexity : O(n), where n is the length of array nums. We iterate over an element in the array twice which takes O(n) time. First, to build a map from the array. Second, to find a pair for every element in the array. Also, to add or update an element in a hashmap takes constant time. This gives us total time complexity as O(n). Space Complexity: O(n), where n is the length of array nums. We use an unordered map to store the values of the array with their count of occurrence. In the worst case, if every element in the array is unique, the maximum size of the map would grow up to n.
Max Consecutive Ones III	Medium		Sliding Window	"# start a sliding window from the left. move the right pointer right so long as you  # have less than or equal k 0s in the window and the rest are 1s. if you exceed   # k 0s in the window, move the left pointer to the right until you eliminate a zero  # from the window.  # we can keep a variable called kRemaining to keep track of how many zeroes we have  # in the window."	"class Solution:     def longestOnes(self, nums: List[int], k: int) -> int:         maxLength = 0         l = 0         zeroCount = 0                  for r in range(len(nums)):             if nums[r] == 0:                 zeroCount += 1                          while zeroCount > k:                 if nums[l] == 0:                     zeroCount -= 1                 l += 1  # Move left pointer to reduce zeroes in the window                          maxLength = max(maxLength, r - l + 1)                     return maxLength"	Time Complexity: O(n)  The right pointer (r) moves from 0 to n - 1, iterating once through nums, taking O(n). The left pointer (l) also moves forward when necessary, but each element is visited at most once. Since each element is processed at most twice (once by r and once by l), the worst-case runtime remains O(n).   Space Complexity: O(1)  The algorithm uses only a few integer variables (maxLength, l, r, kRemaining). There are no extra data structures used, so space usage is constant.
Maximum Average Subarray I	Easy		Sliding Window	"# use a sliding window of fixed size k.  # as you slide the window, keep track of the sum of the numbers in the window.  # divide by k to find the average and store the highest average."	"class Solution:     def findMaxAverage(self, nums: List[int], k: int) -> float:         # Compute the sum of the first window         windowSum = sum(nums[:k])         maxAv = windowSum / k  # Set max average initially          # Slide the window across the array         for i in range(k, len(nums)):             windowSum += nums[i] - nums[i - k]  # Add new element, remove old element             maxAv = max(maxAv, windowSum / k)   # Update max average                  return maxAv"	Time Complexity: O(N) Space Complexity: O(1)
Determine if Two Strings Are Close	Medium		Hashmap	"# using operation 1, if i can swap all characters with each other, then if word1 is   # an anagram of word2, then they are close.  # if a character exists in either word1 or word2 that does not exist in the other, they  # cannot be close  # while operation 1 is used to swap positions of characters, operation 2 is fundamentally  # about quantities of characters. if one character has the right quantity for another,   # and that character has the right quantity for this character then they should be   # swapped.  # in order to see if two words are close, we will first align quantity and then align   # position."	"class Solution:     def closeStrings(self, word1: str, word2: str) -> bool:         # Count character frequencies         word1Freq = Counter(word1)         word2Freq = Counter(word2)          # Words must have the same unique characters         if set(word1Freq.keys()) != set(word2Freq.keys()):             return False          # Words must have the same character frequency distribution         return sorted(word1Freq.values()) == sorted(word2Freq.values())"	Time Complexity Analysis O(nlogn+mlogm) Space Complexity Analysis  Counters: O(1) (since we store at most 26 character frequencies). Lists for sorting: O(1) if sorting is done in-place.   Thus, the space complexity is O(1) since we don't use additional space proportional to input size (aside from the counters and lists storing character counts).
Find the Difference of Two Arrays	Easy		HashSets	use sets and set comparisons	class Solution:     def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:         set1, set2 = set(nums1), set(nums2)         return [list(set1 - set2), list(set2 - set1)]	Time Complexity: O(N+M) as creating the set is O(N) and doing the set difference e.g. set1 - set2 is O(set1) Space Complexity: O(N+M)
Removing Stars From a String	Medium		Stack	use a stack iterate through the characters, if it's a star, pop from stack, if it's a letter, add to stack.	class Solution:     def removeStars(self, s):         st = []         for i in range(0, len(s)):             if s[i] == '*':                 st.pop()             else:                 st.append(s[i])          return ''.join(st)	Here, n is the length of s. Time complexity: O(n)We iterate over s and for every character we either push it in the stack or pop the top character from the stack which takes O(1) time per character. It takes O(n) time for n characters.To form the answer string, we remove all the characters from the stack. Because a stack can have maximum of n characters, it would also take O(n) time in that case.We also require O(n) time to reverse answer which can have n characters. Space complexity: O(n)The stack used in the solution can grow to a maximum size of n. We would need O(n) space in that case.
Delete The Middle Node of a Linked List	Medium		Fast/Slow Pointers	If there is only one node, return null.Otherwise, initialize two pointers slow and fast, with slow pointing to head and fast pointing to the second successor node of head.While neither fast and fast.next is null:we move fast forward by 2 nodes.we move slow forward by 1 node.Now slow is the predecessor of the middle node, delete the middle node.Return head.	"class Solution:     def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:            # Edge case: return None if there is only one node.         if head.next == None:             return None                  # Initialize two pointers, 'slow' and 'fast'.         slow, fast = head, head.next.next                  # Let 'fast' move forward by 2 nodes, 'slow' move forward by 1 node each step.         while fast and fast.next:             slow = slow.next             fast = fast.next.next                  # When 'fast' reaches the end, remove the next node of 'slow' and return 'head'.         slow.next = slow.next.next                  # The job is done, return 'head'.         return head"	Let n be the length of the input linked list. Time complexity: O(n)We stop the iteration when the pointer fast reaches the end, fast moves forward 2 nodes per step, so there are at most n/2 steps.In each step, we move both fast and slow, which takes a constant amount of time.Removing the middle node also takes constant time.In summary, the overall time complexity is O(n). Space complexity: O(1)We only need two pointers, so the space complexity is O(1).
Asteroid Collision	Medium		Stack	We don't really need to add negative asteroids into stack. Consider stack as a barrier of positive asteroids that negative should pass.   Direction, position, and magnitude matter. speed does not.  We can use a stack to keep track of the most recent asteroids that are travelling  In the right direction.	"class Solution:     def asteroidCollision(self, asteroids: List[int]) -> List[int]:         ans = []         stack = []          for x in asteroids:             if x > 0:                 # positive asteroid, moving right                 stack.append(x)             else:                 # negative asteroid, moving left — may collide                 while stack and stack[-1] < abs(x):                     # destroy smaller right-moving asteroids                     stack.pop()                  if not stack:                     # no more right-moving asteroids — x survives                     ans.append(x)                 else:                     if stack[-1] == abs(x):                         # both asteroids destroy each other                         stack.pop()                     # else: right-moving asteroid is larger — x is destroyed          return ans + stack"	Time complexity: O(N). We iterate over each asteroid in the list, and for each asteroid, we might iterate over the asteroids we have in the stack and keep popping until they explode. The important point is that each asteroid can be added and removed from the stack only once. Therefore, each asteroid can be processed only twice, first when we iterate over it and then again while popping it from the stack. Therefore, the total time complexity is equal to O(N). Space complexity: O(N). The only space required is for the stack; the maximum number of asteroids that could be there in the stack is N when there is no asteroid collision. The final list that we return, remainingAsteroids, is used to store the output, which is generally not considered part of space complexity. Hence, the total space complexity equals O(N).
Decode String	Medium		Stack	One Stack:  Intuition We have to decode the result in a particular pattern. We know that the input is always valid. The pattern begins with a number k, followed by opening braces [, followed by string. Post that, there could be one of the following cases :There is another nested pattern k[string k[string]]There is a closing bracket k[string] Since we have to start decoding the innermost pattern first, continue iterating over the string s, pushing each character to the stack until it is not a closing bracket ]. Once we encounter the closing bracket ], we must start decoding the pattern. As we know that stack follows the Last In First Out (LIFO) Principle, the top of the stack would have the data we must decode. Algorithm The input can contain an alphabet (a-z), digit (0-9), opening braces [ or closing braces ]. Start traversing string s and process each character based on the following rules: Case 1) Current character is not a closing bracket ]. Push the current character to stack. Case 2) Current character is a closing bracket ]. Start decoding the last traversed string by popping the string decodedString and number k from the top of the stack.Pop from the stack while the next character is not an opening bracket [ and append each character (a-z) to the decodedString.Pop opening bracket [ from the stack.Pop from the stack while the next character is a digit (0-9) and build the number k. Now that we have k and decodedString , decode the pattern k[decodedString] by pushing the decodedString to stack k times. Once the entire string is traversed, pop the result from stack and return. Two Stack:   Intuition In the previous approach, we used a single character stack to store the digits(0-9) as well as letters (a-z). We could instead maintain 2 separate stacks.countStack: The stack would store all the integer k.stringStack: The stack would store all the decoded strings. Also, instead of pushing the decoded string to the stack character by character, we could improve our algorithm by appending all the characters into the string first and then push the entire string into the stringStack. Let's look at the algorithm in detail. Algorithm Iterate over the string s and process each character as follows: Case 1) If the current character is a digit (0-9), append it to the number k. Case 2) If the current character is a letter (a-z), append it to the currentString. Case 3) If current character is a opening bracket [, push k and currentString into countStack and stringStack respectively. Case 4) Closing bracket ]: We must begin the decoding process, We must decode the currentString. Pop currentK from the countStack and decode the pattern currentK[currentString] As the stringStack contains the previously decoded string, pop the decodedString from the stringStack. Update the decodedString = decodedString + currentK[currentString]	"One Stack:  class Solution:     def decodeString(self, s: str) -> str:         stack = []          for i in range(len(s)):             if s[i] != ""]"":                 stack.append(s[i])             else:                 substr = """"                 while stack[-1] != ""["":                     substr = stack.pop() + substr                 stack.pop()                  k = """"                 while stack and stack[-1].isdigit():                     k = stack.pop() + k                 stack.append(int(k) * substr)          return """".join(stack)  Two Stack:  class Solution:     def decodeString(self, s: str) -> str:         string_stack = []         count_stack = []         cur = """"         k = 0          for c in s:             if c.isdigit():                 k = k * 10 + int(c)             elif c == ""["":                 string_stack.append(cur)                 count_stack.append(k)                 cur = """"                 k = 0             elif c == ""]"":                 temp = cur                 cur = string_stack.pop()                 count = count_stack.pop()                 cur += temp * count             else:                 cur += c          return cur"	One Stack:  Time complexity: O(n+N^2)Space complexity: O(n+N)Where n is the length of the input string and N is the length of the output string.  Two Stack:  Time complexity: O(n+N)Space complexity: O(n+N) Where n is the length of the input string and N is the length of the output string.
Greatest Common Divisor of Strings	Easy		use gcd function	"My Solution:   # have to find string that can be multiplied some number of times to equal str1 and  # str2. This must mean the gcd is a prefix of str1 and str2. We will test prefixes of  # the shorter of the two strings.  # to test whether a potential gcd is in fact the gcd, we take the length of str1 and  # str2 and divide tha its length,  Better Solution:  Algorithm Check if the concatenations of str1 and str2 in different orders are the same.If not, return """". Get the GCD gcdLength of the two lengths of str1 and str2. Return the prefix string with a length of gcdLength of either str1 or str2 as the answer."	"My Solution:  class Solution:     def gcdOfStrings(self, str1: str, str2: str) -> str:         # The GCD string must be a prefix of both strings         shorter_string = str1 if len(str1) <= len(str2) else str2         longest_gcd = ''          for i in range(1, len(shorter_string) + 1):             potential_gcd = shorter_string[:i]              if len(str1) % len(potential_gcd) != 0 or len(str2) % len(potential_gcd) != 0:                 continue              if potential_gcd * (len(str1) // len(potential_gcd)) == str1 and \                potential_gcd * (len(str2) // len(potential_gcd)) == str2:                 longest_gcd = potential_gcd          return longest_gcd  Better Solution:  class Solution:     def gcdOfStrings(self, str1: str, str2: str) -> str:         # Check if they have non-zero GCD string.         if str1 + str2 != str2 + str1:             return """"          # Get the GCD of the two lengths.         max_length = gcd(len(str1), len(str2))         return str1[:max_length]"	My Solution: Time Complexity: Worst Case O(min(n, m) * (n + m)) Space Complexity: O(n + m)  Better Solution:   Let m,n be the lengthes of the two input strings str1 and str2. Time complexity: O(m+n)We need to compare the two concatenations of length O(m+n), it takes O(m+n) time.We calculate the GCD using binary Euclidean algorithm, it takes log(m⋅n) time.To sum up, the overall time complexity is O(m+n). Space complexity: O(m+n) We need to compare the two concatenations of length O(m+n).
Can Place Flowers	Easy		While Loop	Loop through flowerbed one time using a while loop. Note: For this approach, you have to keep in mind that at any current position, we will always be backwards validated but not forwards validated. What this means is that we know we are able to place a flower in the current position from the perspective of the flowerbed to the left of the current position but not necessarily from the right. This is because at each iteration, we are moving forward responsibly, and skipping positions that we know to be impossible to place at.  If the current number is a 1, there is already a flower there and so we must skip forward 2 spaces as we could not place a flower in the next space. If the current number is a 0, there are multiple situations: - if we are on the last position in the flowerbed, this must be a position where we can place a flower. We know this because of the Note written above.  - if we are not on the last position, but we know that there are no flowers to the left of the current flower that are stopping us from placing, we must only check one to the right of the flower to see if we can place. if we can place, then we decremenet n and skip i forward by 2, because it is impossible to place on the immediate next place. -  if the next position is a 1, we must have to skip forward three positions.	class Solution:     def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:         i = 0         while i < len(flowerbed):             if flowerbed[i] == 1:                 i += 2             else:                 if i == len(flowerbed)-1:                     n -= 1                     i += 1                 elif flowerbed[i+1] != 1:                     n -= 1                     i += 2                 else:                     i += 3             if n == 0: return True         return n <= 0	Time complexity: O(n). A single scan of the flowerbed array of size n is done. Space complexity: O(1). Constant extra space is used.
Reverse Vowels of a String	Easy		Two Pointer	Initialize the left pointer start to 0, and the right pointer end to s.size() - 1.Keep iterating until the left pointer catches up with the right pointer:Keep incrementing the left pointer start until it's pointing to a vowel character.Keep decrementing the right pointer end until it's pointing to a vowel character.Swap the characters at the start and end.Increment the start pointer and decrement the end pointer.Return the string s.	"class Solution:     def reverseVowels(self, s: str) -> str:         # Define a set of vowels for quick lookup         vowels = set(""aeiouAEIOU"")                  # Convert string to list of characters since strings are immutable         s_chars = list(s)         start, end = 0, len(s_chars) - 1          # Two-pointer approach to find and swap vowels         while start < end:             while start < end and s_chars[start] not in vowels:                 start += 1             while start < end and s_chars[end] not in vowels:                 end -= 1             if start < end:                 s_chars[start], s_chars[end] = s_chars[end], s_chars[start]                 start += 1                 end -= 1          return ''.join(s_chars)"	Time complexity: O(N) It might be tempting to say that there are two nested loops and hence the complexity would be O(N2). However, if we observe closely the pointers start and end will only traverse the index once. Each element of the string s will be iterated only once either by the left or right pointer and not both. We swap characters when both pointers point to vowels which are O(1) operation. Hence the total time complexity will be O(N). Note that in Java we need to convert the string to a char array as strings are immutable and hence it would take O(N) time. Space complexity: O(N) In C++ we only need an extra temporary variable to perform the swap and hence the space complexity is O(1). However, in Java, we need to convert the string to a char array that would take O(N) space, and therefore the space complexity for Java would be O(N).  Now, here’s where the language difference matters:  In Python, strings are immutable, just like Java. To perform in-place swaps, you must convert the string to a list of characters: list(s)  This costs O(N) space.   The final result uses ''.join(...) to create a new string, which also takes O(N) space.
Odd Even Linked List	Medium		LinkedList	We want to iterate through the list, putting the odd nodes in one list and the even nodes in another list.  We should initialize two pointers, odd and even on the first node and second node respectively, representing the start of the two lists.  We also need to save a pointer to the start of the even list so we can attach it to the end of the odd list later. We then create a while loop with the condition of there being an even.next. In other words, we only need one node beyond where the even node is to continue the loop. After the loop, attach the end of the odd list to the start of the even list and return the head.	"# Definition for singly-linked list. # class ListNode: #     def __init__(self, val=0, next=None): #         self.val = val #         self.next = next  class Solution:     def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:         if not head or not head.next:             return head          odd = head         even = head.next         head_odd = odd         head_even = even          while even and even.next:             odd.next = even.next             odd = odd.next             even.next = odd.next             even = even.next          odd.next = head_even         return head_odd"	Time complexity : O(n). There are total n nodes and we visit each node once. Space complexity : O(1). All we need is the four pointers.
Keys and Rooms	Medium		DFS	Do a DFS and maintain a set of rooms visited. As a base case, check if the room has been visited before. If not, call the dfs on all the keys in the room. At the end, check if the length of the visited set is equal to the number of rooms.	class Solution:     def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:         visited = set()          def dfs(room):             if room in visited:                 return             visited.add(room)             for key in rooms[room]:                 dfs(key)          dfs(0)         return len(visited) == len(rooms)	Time Complexity: O(N+E), where N is the number of rooms, and E is the total number of keys. Space Complexity: O(N) in additional space complexity, to store stack and seen.
Number of Provinces	Medium		Graph DFS	we have an nxn adjacency matrix. it is a symmetric matrix because this is an undirected graph. it has 1s on the diagonal. we want to find the number of connected components in the graph. make a recursive function, find_connections that iterates through the connections of the given node and marks that node as visited.	"class Solution:     def findCircleNum(self, isConnected: List[List[int]]) -> int:         visited = set()         connected_components = 0          def find_connections(node, visited):             # Recursive DFS to visit all nodes in the current component             if node in visited:                 return             visited.add(node)             connections = isConnected[node]             for i in range(len(connections)):                 if connections[i] == 1 and i != node and i not in visited:                     find_connections(i, visited)          # Iterate through each node and start a DFS if it's unvisited         for node in range(len(isConnected)):             if node not in visited:                 connected_components += 1                 find_connections(node, visited)          return connected_components"	Here n is the number of cities. Time complexity: O(n^2).Initializing the visit array takes O(n) time.The dfs function visits each node once, which takes O(n) time because there are n nodes in total. From each node, we iterate over all possible edges using isConnected[node] which takes O(n) time for each visited node. As a result, it takes a total of O(n^2) time to visit all the nodes and iterate over its edges. Space complexity: O(n).The visit array takes O(n) space.The recursion call stack used by dfs can have no more than n elements in the worst-case scenario. It would take up O(n) space in that case.
Leaf-Similar Trees	Easy		Tree DFS	Let's find the leaf value sequence for both given trees. Afterwards, we can compare them to see if they are equal or not. To find the leaf value sequence of a tree, we use a depth first search. Our dfs function writes the node's value if it is a leaf, and then recursively explores each child. This is guaranteed to visit each leaf in left-to-right order, as left-children are fully explored before right-children.	class Solution:     def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:         def find_leaf_sequence(root):             if not root:                 return []             if not root.left and not root.right:                 return [root.val]             return find_leaf_sequence(root.left) + find_leaf_sequence(root.right)                  return find_leaf_sequence(root1) == find_leaf_sequence(root2)    Can also use iterator comparison:  class Solution:     def leafSimilar(self, root1, root2):         def dfs(node):             if node:                 if not node.left and not node.right:                     yield node.val                 yield from dfs(node.left)                 yield from dfs(node.right)          return list(dfs(root1)) == list(dfs(root2))	Let N be the number of nodes in root1 and M the number of nodes in root2. Time Complexity: O(N+M) The dfs function visits each node exactly once in both trees, resulting in a time complexity of O(N) for the first call and O(M) for the second call. After collecting all leaves in the leaves1 and leaves2 arrays, we compare them using the == operator. Comparing two arrays of size L has a worst-case time complexity of O(L), where L is the number of leaf nodes in the larger array. Since L≤min(N,M), the comparison time is O(min(N,M)), but this is dominated by the time spent traversing both trees. Overall, the time complexity is O(N+M). Space Complexity: O(N+M) The recursive dfs calls will require stack space for each node. In the worst case, if the trees are completely unbalanced (like a linked list), the recursion depth could be O(N) and O(M) respectively, leading to a total stack space complexity of O(N+M). Additionally, each dfs call collects leaf nodes into leaves1 and leaves2. The maximum number of leaves in a binary tree is 2N​ (for a full binary tree), resulting in O(N) and O(M) space for each array. Therefore, the total space complexity, combining both the recursion stack and the storage for the leaves, is O(N+M).
Nearest Exit from Entrance in Maze	Medium		BFS from entrance	Initialize an empty queue queue to store all the nodes to be visited.Add entrance and its distance 0 to queue and mark entrance as visited.While we don't reach an exit and queue still has cells, pop the first cell from queue. Suppose its distance from entrance is curr_distance. We check its neighboring cells in all four directions, if it has an unvisited neighbor cell:If this neighbor cell is an exit, return its distance from the starting position, curr_distance + 1, as the nearest distance.Otherwise, we mark it as visited, and add it to queue along with its distance curr_distance + 1.If we finish the iteration and no exit is found, return -1.	"from collections import deque  class Solution:     def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:         ROWS, COLS = len(maze), len(maze[0])         seen = set()         queue = deque()         queue.append((entrance[0], entrance[1]))         seen.add((entrance[0], entrance[1]))         directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]         steps = 0          while queue:             for _ in range(len(queue)):                 r, c = queue.popleft()                  if (r, c) != (entrance[0], entrance[1]) and (r in [0, ROWS - 1] or c in [0, COLS - 1]):                     return steps                  for dr, dc in directions:                     nr, nc = r + dr, c + dc                     if 0 <= nr < ROWS and 0 <= nc < COLS and (nr, nc) not in seen and maze[nr][nc] == ""."":                         queue.append((nr, nc))                         seen.add((nr, nc))              steps += 1          return -1"	Let m,n be the size of the input matrix maze. Time complexity: O(m⋅n)For each visited cell, we add it to queue and pop it from queue once, which takes constant time as the operation on queue requires O(1) time.For each cell in queue, we mark it as visited in maze, and check if it has any unvisited neighbors in all four directions. This also takes constant time.In the worst-case scenario, we may have to visit O(m⋅n) cells before the iteration stops.To sum up, the overall time complexity is O(m⋅n). Space complexity: O(max(m,n))We modify the input matrix maze in-place to mark each visited cell, it requires constant space.We use a queue queue to store the cells to be visited. In the worst-case scenario, there may be O(m+n) cells stored in queue.The space complexity is O(m+n)+O(max(m,n)).
Guess Number Higher or Lower	Easy		Binary Search	We can apply Binary Search to find the given number. We start with the mid number. We pass that number to the guess function. If it returns a -1, it implies that the guessed number is larger than the required one. Thus, we use Binary Search for numbers lower than itself. Similarly, if it returns a 1, we use Binary Search for numbers higher than itself	"# The guess API is already defined for you. # @param num, your guess # @return -1 if num is higher than the picked number #          1 if num is lower than the picked number #          0 if num is equal to the picked number # def guess(num: int) -> int:  class Solution:     def guessNumber(self, n: int) -> int:         left, right = 1, n          while left <= right:             mid = (left + right) // 2             res = guess(mid)              if res == 0:                 return mid             elif res == -1:                 right = mid - 1             else:  # res == 1                 left = mid + 1          return -1  # This line is technically unreachable if the input is valid"	Time complexity : O(log_2​n). Binary Search is used.Space complexity : O(1). No extra space is used.
Successful Pairs of Spells and Potions	Medium		Sorting and Binary Search	Sort the potions array in ascending order.Initialize variables:answer, an array to store the result.m, length of the potions array.maxPotion, the maximum value in the potions array.For each spell in the spells array:Calculate the minimum potion strength required to make the spell successful as minPotion using the formula minPotion = ceil(success / spell).If minPotion is greater than maxPotion, store 0 in the answer array and continue to the next spell.Otherwise, find the index of the first element in the potions array that is greater than or equal to minPotion using the inbuilt lower bound methods like lower_bound(), bisect.bisect_left(), sort.SearchInts(), etc. or by implementing it on your own.Calculate the number of successful pairs possible for the current spell as (m - index).Store the result in the answer vector.Return the answer array which contains the number of successful pairs for each spell.	"class Solution:     def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:         # Sort the potions array in increasing order.         potions.sort()         answer = []          m = len(potions)         maxPotion = potions[m - 1]          for spell in spells:             # Minimum value of potion whose product with current spell             # will be at least success or more.             minPotion = (success + spell - 1) // spell             # Check if we don't have any potion which can be used.             if minPotion > maxPotion:                 answer.append(0)                 continue             # We can use the found potion, and all potion in its right             # (as the right potions are greater than the found potion).             index = bisect.bisect_left(potions, minPotion)             answer.append(m - index)          return answer"	Here, n is the number of elements in the spells array, and m is the number of elements in the potions array. Time complexity: O((m+n)⋅logm)We sort the potions array which takes O(mlogm) time.Then, for each element of the spells array using binary search we find the respective minPotion which takes O(logm) time. So, for n elements it takes O(nlogm) time.Thus, overall we take O(mlogm+nlogm) time. Space complexity: O(logm) or O(m)The output array answer is not considered as additional space usage.But some extra space is used when we sort the potions array in place. The space complexity of the sorting algorithm depends on the programming language.In Python, the sort() method sorts a list using the Timsort algorithm which has O(m) additional space where m is the number of the elements.
N-th Tribonacci Number	Easy		DP	Create a hash map dp to store the value of computed tribonacci numbers, initialized with the base cases dp[0] = 0, dp[1] = 1, dp[2] = 1. Let dfs(i) be the value of ith tribonacci numbers: If i is in dp, return dp[i]. Otherwise, recursively solve answer = dfs(i - 1) + dfs(i - 2) + dfs(i - 3) and set dp[i] = answer. Then return answer.Return dfs(n).   OR     If n < 3, return the value of the nth term as indicated by the problem description. Initialize a, b, and c as the base cases. Set a = 0, b = 1, c = 1. For the next n - 2 steps, update a, b, c as a = b, b = c, c = a + b + c. Return c.	class Solution:     def tribonacci(self, n: int) -> int:         dp = {0: 0, 1: 1, 2: 1}         def dfs(i):             if i in dp:                 return dp[i]             dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)             return dp[i]                  return dfs(n)    OR     class Solution:     def tribonacci(self, n: int) -> int:         if n < 3:             return 1 if n else 0         a, b, c = 0, 1, 1         for _ in range(n - 2):             a, b, c = b, c, a + b + c         return c	Time complexity: O(n)We recursively call dfs on subproblems and each subproblem dfs(i) is computed once. Space complexity: O(n)The hash map dp contains at most n + 1 key-value pairs.   OR Time complexity: O(n)We have to update the value of a, b and c by n - 2 times, each update takes constant time. Thus it takes O(n) time. Space complexity: O(1)We only need to update several parameters a, b, c and tmp, which takes O(1) space.
Domino and Tromino Tiling	Medium		DP	f(k): The number of ways to fully cover a board of width k.p(k): The number of ways to partially cover a board of width k. We can determine the number of ways to fully or partially tile a board of width k by considering every possible way to arrive at f(k) or p(k) by placing a domino or a tromino. Let's find f(k) together and then you can pause to practice by finding p(k) on your own. All of the ways to arrive at a fully tiled board of width k are as follows:From f(k−1) we can add 1 vertical domino for each tiling in a fully covered board with a width of k−1, as shown in the second animation.From f(k−2) we can add 2 horizontal dominos for each tiling in a fully covered board with a width of k−2, as shown in the third animation.Note that we don't need to add 2 vertical dominos to f(k−2), since f(k−1) will cover that case and it will cause duplicates if we count it again.From p(k−1) we can add an L-shaped tromino for each tiling in a partially covered board with a width of k−1, as shown above (in the fourth animation).We will multiply by p(k−1) by 2 because for any partially covered tiling, there will be a horizontally symmetrical tiling of it. For example, the animation below shows two p(k−1) board states that are identical when reflected over the horizontal edge of the board. Logically, there must be an equal number of ways to fully tile the board from both p(k−1) states. So rather than count the number of ways twice, we simply multiply the number of ways from one p(k−1) state by 2. Summing the ways to reach f(k) gives us the following equation: f(k)=f(k−1)+f(k−2)+2∗p(k−1)    Now that we know where tilings on f(k) are coming from, how about p(k)? Can we apply the same logic and find that out? Absolutely yes! Take a pen and start drawing scenarios that contribute to p(4) (this is a good technique to aid critical thinking during an interview). Start by drawing p(4), remember p(4) is a board of width 4 with the first 3 columns fully covered and the last column half covered. Now, try removing a domino or a tromino to find which scenarios contribute to p(4). Notice that p(k) can come from the below scenarios:Adding a tromino to a fully covered board of width k−2 (i.e. f(k−2))Adding a horizontal domino to a partially covered board of width k−1 (i.e. p(k−1)) Thus, we arrive at the following conclusion for p(k): p(k)=p(k−1)+f(k−2)   If k is greater than 2, then we will make recursive calls to f and p according to the transition function: f(k)=f(k−1)+f(k−2)+2∗p(k−1) p(k)=p(k−1)+f(k−2)	class Solution:     def numTilings(self, n: int) -> int:         MOD = 1_000_000_007          @cache           def p(n):               if n == 2:                 return 1             return (p(n - 1) + f(n - 2)) % MOD          @cache           def f(n):               if n <= 2:                 return n             return (f(n - 1) + f(n - 2) + 2 * p(n - 1)) % MOD          return f(n)   many more solutions in editorial: https://leetcode.com/problems/domino-and-tromino-tiling/editorial/?envType=study-plan-v2&envId=leetcode-75	Let N be the width of the board. Time complexity: O(N) From top (N) to bottom (1), there will be N non-memoized recursive calls to f and to p, where each non-memoized call requires constant time. Thus, O(2⋅N) time is required for the non-memoized calls. Furthermore, there will be 2⋅N memoized calls to f and N memoized calls to p, where each memoized call also requires constant time. Thus O(3⋅N) time is required for the memoized calls. This leads to a time complexity of O(2⋅N+3⋅N)=O(N). Space complexity: O(N) Each recursion call stack will contain at most N layers. Also, each hashmap will use O(N) space. Together this results in O(N) space complexity.
Number of Recent Calls	Easy		Queue/Sliding Window	To implement the sliding window, we could use the LinkedList in Java or deque in Python. Then the ping(t) function can be implemented in two steps: Step 1): we append the current ping call to the tail of the sliding window. Step 2): starting from the head of the sliding window, we remove the outdated calls, until we come across a still valid ping call. As a result, the remaining calls in the sliding window are the ones that fall into the range of [t - 3000, t].	"class RecentCounter:      def __init__(self):         self.slide_window = deque()      def ping(self, t: int) -> int:         # step 1). append the current call         self.slide_window.append(t)          # step 2). invalidate the outdated pings         while self.slide_window[0] < t - 3000:             self.slide_window.popleft()          return len(self.slide_window)"	Time Complexity: O(1) The main time complexity of our ping() function lies in the loop, which in the worst case would run 3000 iterations to pop out all outdated elements, and in the best case a single iteration. Therefore, for a single invocation of ping() function, its time complexity is O(3000)=O(1). If we assume that there is a ping call at each timestamp, then the cost of ping() is further amortized, where at each invocation, we would only need to pop out a single element, once the sliding window reaches its upper bound. Space Complexity: O(1)As we estimated before, the maximal size of our sliding window is 3000, which is a constant.
Longest Subarray of 1's After Deleting One Element	Medium		Sliding Window	Initialize three variables: a. zeroCount to 0; this is the number of zeroes in the current window. b. longestWindow to 0; this is the longest window having at most one 0 we have seen so far. c. start to 0; this is the left end of the window from where it starts. Iterate over the array from index i to array.length - 1 (inclusive), and keep counting the zeroes in the variable zeroCount. After every element, check if the zeroCount exceeds 1; if yes, keep removing elements from the left until the value of zeroCount becomes <= 1. Update the variable longestWindow with the current window length, i.e. i - start. Note that this subtraction will give the number of elements in the window minus 1, as we need to delete one element too. Return longestWindow.	"from typing import List  class Solution:     def longestSubarray(self, nums: List[int]) -> int:         left = 0         zeroCount = 0         best = 0          for right, v in enumerate(nums):             if v == 0:                 zeroCount += 1              # shrink window until it contains ≤ 1 zero             while zeroCount > 1:                 if nums[left] == 0:                     zeroCount -= 1                 left += 1              # delete exactly one element (the single 0 if present,             # otherwise any element) → length is right‑left             best = max(best, right - left)          return best          # O(n) time, O(1) extra space"	Here, N is the size of the array nums. Time complexity: O(N) Each element in the array will be iterated over twice at most. Each element will be iterated over for the first time in the for loop; then, it might be possible to re-iterate while shrinking the window in the while loop. No element can be iterated more than twice. Therefore, the total time complexity would be O(N). Space complexity: O(1) Apart from the three variables, we don't need any extra space; hence the total space complexity is constant.
Equal Row and Column Pairs	Medium		HashTable	Create an empty hash map row_counter and set count to 0. For each row row in the grid, convert it into an equivalent hashable object and use it as a key to the row_counter. Increment the value of the corresponding key by 1. For each column in the grid, convert it into the same type of hashable object and check if it appears in the row_counter. If it does, increment count by the frequency. Return the answer count.	"class Solution:     def equalPairs(self, grid: List[List[int]]) -> int:         count = 0         n = len(grid)                  # Keep track of the frequency of each row.         row_counter = collections.Counter(tuple(row) for row in grid)          # Add up the frequency of each column in map.         for c in range(n):             col = [grid[i][c] for i in range(n)]             count += row_counter[tuple(col)]                       return count"	Let n×n be the size of grid. Time complexity: O(n^2)We iterate over each row and column only once, converting one array of length n into a hashable object takes O(n) time.Operations like adding or checking on hash map take O(1) time. Space complexity: O(n^2)We store each row of the grid in the hash map, in the worst-case scenario, row_counter might contains n distinct rows of length n.
